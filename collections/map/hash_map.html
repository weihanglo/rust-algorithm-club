<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>雜湊表 Hash map - Rust Algorithm Club</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Learn algorithms and data structures with Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "../../";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="../../index.html">Rust Algorithm Club</a></li><li class="spacer"></li><li><a href="../../concepts/index.html">基礎概念</a></li><li><ol class="section"><li><a href="../../concepts/asymptotic-notation/index.html">漸進符號 Asymptotic Notation</a></li></ol></li><li><a href="../../sorting/index.html">排序</a></li><li><ol class="section"><li><a href="../../sorting/simple-sorts.html">簡單排序</a></li><li><ol class="section"><li><a href="../../sorting/insertion_sort/index.html">插入排序 Insertion sort</a></li><li><a href="../../sorting/selection_sort/index.html">選擇排序 Selection sort</a></li><li><a href="../../sorting/bubble_sort/index.html">氣泡排序 Bubble sort</a></li><li><a href="../../sorting/shellsort/index.html">希爾排序 Shellsort</a></li></ol></li><li><a href="../../sorting/efficient-sorts.html">高效排序</a></li><li><ol class="section"><li><a href="../../sorting/heapsort/index.html">堆積排序 Heapsort</a></li><li><a href="../../sorting/quicksort/index.html">快速排序 Quicksort</a></li><li><a href="../../sorting/mergesort/index.html">合併排序 Mergesort</a></li></ol></li><li><a href="../../sorting/hybrid-sorts.html">混合排序</a></li><li><ol class="section"><li><a href="../../sorting/introsort/index.html">🚧 內省排序 Introsort</a></li><li><a href="../../sorting/timsort/index.html">🚧 自適應合併排序 Timsort</a></li><li><a href="../../sorting/pdqsort/index.html">🚧 模式消除快速排序 Pdqsort</a></li></ol></li><li><a href="../../sorting/special-purpose-sorts.html">特殊排序</a></li><li><ol class="section"><li><a href="../../sorting/counting_sort/index.html">計數排序 Counting sort</a></li><li><a href="../../sorting/bucket_sort/index.html">桶排序 Bucket sort</a></li><li><a href="../../sorting/radix_sort/index.html">基數排序 Radix sort</a></li></ol></li></ol></li><li><a href="../../collections/index.html">資料結構</a></li><li><ol class="section"><li><a href="../../collections/stack_queue/index.html">🚧 堆疊與佇列</a></li><li><ol class="section"><li><a href="../../collections/stack_queue/stack.html">🚧 堆疊 Stack</a></li><li><a href="../../collections/stack_queue/queue.html">🚧 佇列 Queue</a></li><li><a href="../../collections/stack_queue/deque.html">🚧 雙端佇列 Deque</a></li></ol></li><li><a href="../../collections/linked_list/index.html">鏈結串列</a></li><li><ol class="section"><li><a href="../../collections/linked_list/singly.html">單向鏈結串列 Singly linked list</a></li><li><a href="../../collections/linked_list/doubly.html">🚧 雙向鏈結串列 Doubly linked list</a></li><li><a href="../../collections/linked_list/circular.html">🚧 循環鏈結串列 Circular linked list</a></li></ol></li><li><a href="../../collections/map/index.html">關聯容器</a></li><li><ol class="section"><li><a href="../../collections/map/hash_map.html" class="active">雜湊表 Hash map</a></li><li><a href="../../collections/map/ordered_map.html">🚧 有序映射表 Ordered map</a></li><li><a href="../../collections/map/multimap.html">🚧 多重映射表 Multimap</a></li><li><a href="../../collections/map/set.html">🚧 集合 Set</a></li><li class="spacer"></li></ol></li></ol></li><li><a href="../../LICENSE.html">授權條款</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust Algorithm Club</h1> 

                        <div class="right-buttons">
                            <a href="../../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#a雜湊表-hash-map" id="a雜湊表-hash-map"><h1>雜湊表 Hash Map</h1></a>
<p>雜湊表是以雜湊函數實作的關聯容器。透過雜湊函數，計算鍵（key）對應到容器內部的索引位置，進而找到對應的值（value）。一般來說，雜湊表最常見的實作是以一個簡單陣列儲存資料。</p>
<p>雜湊表的優勢是：</p>
<ul>
<li>在資料量大時，仍然維持常數時間的高效能。</li>
<li>若資料數量上限已知，就可避免重新配置記憶體，效能更佳。</li>
<li>若資料形態已知，就可針對該資料形態找尋適合的雜湊函數最佳化。</li>
</ul>
<p>而雜湊表相對有以下短處：</p>
<ul>
<li>資料量不夠大時，單一操作需要雜湊計算，開銷相對高。</li>
<li>效能與雜湊函數息息相關，較差的函數容易雜湊碰撞，較佳函數計算成本通常較高。</li>
<li>只能以某種偽隨機的順序迭代雜湊表。</li>
</ul>
<a class="header" href="#a概念" id="a概念"><h2>概念</h2></a>
<p>建立雜湊表的第一步，就是配置一定大小的陣列（通常稱為 bucket array），來儲存對應索引的鍵值對。我們以建立電話簿為例，儲存人名與號碼的對應關係。</p>
<pre><code>Create an empty phone book with some blank slots.

          +--------------+
          | 0:           |
          +--------------+
          | 1:           |
          +--------------+
          | 2:           |
          +--------------+
          | 3:           |
          +--------------+
</code></pre>
<p>我們嘗試插入第一筆資料，記錄 Frodo 以及他的手機號碼 88-7-666。</p>
<ol>
<li>透過雜湊函數，計算出 Frodo 的索引值為 1。</li>
<li>將 88-7-666 插入 table[1] 的位置上。</li>
</ol>
<blockquote>
<p>table[1] 這種 bucket array 下的個別索引空間，通常稱為一個 slot 或 bucket。</p>
</blockquote>
<pre><code>Fordo: hash_function(Frodo) --&gt; 1

          +-------------+
          | 0:          |
          +-------------+
Frodo --&gt; | 1: 88-7-666 |
          +-------------+
          | 2:          |
          +-------------+
          | 3:          |
          +-------------+
</code></pre>
<p>嘗試插入另外二筆資料，記錄 Sam 的手機 11-2-333，以及 Gollum 的手機 00-0-000。</p>
<ol>
<li>透過雜湊函數，計算出 Sam 的索引值為 2。</li>
<li>將 11-2-333 插入 table[2] 的位置上。</li>
<li>透過雜湊函數，計算出 Gollumn 的索引值為 0。</li>
<li>將 00-0-000 插入 table[0] 的位置上。</li>
</ol>
<pre><code>Sam: hash_function(Sam) --&gt; 2

          +-------------+
          | 0:          |
          +-------------+
          | 1: 88-7-666 |
          +-------------+
Sam   --&gt; | 2: 11-2-333 |
          +-------------+
          | 3:          |
          +-------------+


Gollum: hash_function(Gollum) --&gt; 0

          +-------------+
Gollum -&gt; | 0: 00-0-000 |
          +-------------+
          | 1: 88-7-666 |
          +-------------+
          | 2: 11-2-333 |
          +-------------+
          | 3:          |
          +-------------+
</code></pre>
<p>若需要取得 Sam 的手機號碼，只要</p>
<ol>
<li>透過雜湊函數，計算出 Sam 的索引值為 2。</li>
<li>從 table[2] 的索引位置上，找到 Sam 的手機號碼</li>
</ol>
<pre><code>Sam: hash_function(Sam) --&gt; 2

          +-------------+
          | 0: 00-0-000 |
          +-------------+
          | 1: 88-7-666 |
          +-------------+
Sam   --&gt; | 2: 11-2-333 | --&gt; Sam's phone number
          +-------------+
          | 3:          |
          +-------------+
</code></pre>
<p>這就是最基本，以陣列實作的雜湊表了。</p>
<p>然而，你可能已經開始好奇了。</p>
<ul>
<li>雜湊是什麼？怎麼知道要映射到哪個索引位置？</li>
<li>雜湊函數是否會計算出相同的索引值？要如何解決？</li>
<li>若預先配置的陣列填滿了，該如何處理？</li>
</ul>
<p>接下來，將探討這幾個魔術般的因子，從簡單介紹雜湊函數，到如何解決雜湊碰撞，最後探討陣列塞滿重配置解決方案。</p>
<blockquote>
<p>註：雜湊表也可以搜尋樹等其他資料結構實作，在此不深入討論。</p>
</blockquote>
<a class="header" href="#a雜湊" id="a雜湊"><h3>雜湊</h3></a>
<p>所謂的雜湊函數，就是一種將「較寬的定義域映射到較窄值域」的函數。簡單來說，就是輸入任意值到此函數，則輸出值會落在一已知範圍。再白話一點，雜湊函數就是用來「化繁為簡」，把複雜多變的東西，透過函數生成簡化版本。此外，相同的輸入鍵，必須得到相同的輸出雜湊值，這是雜湊函數很重要的一個特性，以虛擬碼表示：</p>
<pre><code>key1 == key2 -&gt; hash(key1) == hash(key2)
</code></pre>
<p>「映射」這部分只是使用雜湊的一小步。雜湊表根據程式實作的不同，底層儲存資料的形式也不盡相同，為了完全放入陣列中，通常會對雜湊值（雜湊函數的計算結果）取模（modulo）。也就是說：假設有長度為 <em>n</em> 的陣列。1）先對 key 取雜湊值。2）再對雜湊值取模，確認索引值落在陣列內部。</p>
<pre><code>Assumed: array_size = n

hash_value = hash_function(key) // 1

index = hash_value % array_size // 2
</code></pre>
<p>如此一來，所有可能的值都會落在陣列內，這就是最簡單普遍的雜湊兩步驟：計算雜湊值﹢取模。</p>
<a class="header" href="#a選擇雜湊函數" id="a選擇雜湊函數"><h3>選擇雜湊函數</h3></a>
<p>接下來，你會緊接著向問第二個問題「函數計算出相同索引值該怎麼辦？」不同輸入產生相同雜湊值，多個值映射到同個索引上，這種狀況科學家稱之<strong>雜湊碰撞（hash collision）</strong>。</p>
<p>首先，要瞭解雜湊函數本身就是時空間的權衡，如果記憶體空間夠多，那讓輸入值與雜湊值呈一對一的完美關係，就不會出現碰撞；大多數情況，尤其是實作泛用的雜湊函式庫，無法預期輸入資料的範圍，實務上會鎖定一個輸出雜湊值的範圍，僧多粥少，難免碰撞。</p>
<p>好的雜湊函數還必須符合一些條件：</p>
<ol>
<li>同一筆輸入資料，必須得到相同的雜湊值。</li>
<li>結果必須能夠高效的計算出來（預期為常數時間）。</li>
<li>任意輸入資料所得之雜湊值在值域內需接近<a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)">均勻分佈（uniform distribution）</a>，才能減少碰撞機率。</li>
</ol>
<p>但總歸一句，欲達成上述條件，就是一種權衡取捨，例如，<a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">加密雜湊函數（cryptographic hash function）</a>即是非常優秀的雜湊函數，但相對需付出更高的計算成本。</p>
<p>更多雜湊函數相關的討論，會另撰<a href="../hash">專文</a>。</p>
<a class="header" href="#a處理雜湊碰撞" id="a處理雜湊碰撞"><h3>處理雜湊碰撞</h3></a>
<p>既然雜湊函數人生在世難免碰撞，科學家也研究幾個處理雜湊碰撞的策略，分別是 separate chaining 與 open addressing。</p>
<p><strong>Separate chaining</strong> 可以說是最直觀的做法，就是設法讓同一個索引下，可以儲存多個碰撞的值。依據儲存資料的形式，可分為幾種實作：</p>
<ul>
<li><strong>鏈結串列</strong>：以<a href="../linked_list">鏈結串列（linked list）</a>儲存元素。發生碰撞時，新的元素串接在既有元素之後。</li>
<li><strong>動態陣列</strong>：新增元素時，在該位址配置<a href="../dynamic_array">動態陣列（dynamic array）</a>儲存元素。發生碰撞時，直接將新元素加在陣列尾端。</li>
</ul>
<p>不同實作方式有各自優缺點，例如串列版本容易實作，但需額外儲存指標資訊；用動態陣列，則會有更好的 CPU caching，但相對地碰撞過多則需要重配置陣列。</p>
<p>以 ASCII 表述使用串列實作 separate chaining 示意圖如下：</p>
<pre><code>... assumed hash values of Gimli and Gollum collided.

                          +----------------+
                      +-&gt; |Gollum, 00-0-000| (linked list)
                      |   +----------------+
                      |            |
Gimli -+              |            v
       |              |   +---------------+
       |  +--------+  |   |Gimli, 99-9-999|
Gollum --&gt;|0: ptr  |--+   +---------------+
          +--------+
Frodo  --&gt;|1: ptr  |----&gt; +---------------+ 
          +--------+      |Frodo, 88-7-666|
Sam    --&gt;|2: ptr  |--+   +---------------+
          +--------+  |
          |3: null |  +-&gt; +---------------+
          +--------+      | Sam, 11-2-333 |
     (main bucket array)  +---------------+
</code></pre>
<p>而這邊也有精美的實作示意圖，將串列首個元素 head 直接放置在 slot 中的作法，減少一次指標操作。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/Hash_table_5_0_1_1_1_1_0_LL.svg/1280px-Hash_table_5_0_1_1_1_1_0_LL.svg.png" alt="" /></p>
<p><em>(利用 separate chaining 實作的雜湊表，並將串列第一個元素放在 bucket array 中)</em></p>
<p>另一方面 <strong>Open addressing</strong> 則走完全不同的套路，不額外配置儲存空間給碰撞的元素，而是繼續在同個陣列內「探測」其他可用的 slot，再把資料塞進尚未被佔據的 slot 中。而 Open addressing 依據不同探測序列（probe sequence）有不同實作，常見的有：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Linear_probing"><strong>Linear probing</strong></a>：從發生碰撞索引開始，依序往下一個 slot 探測是否可用，因此得名「線性」。</li>
<li><a href="https://en.wikipedia.org/wiki/Quadratic_probing"><strong>Quadratic probing</strong></a>：從碰撞索引開始，間隔以二次式增加往下探測可用 slot，如 \(i + 1^2, i + 2^2, i + 3^2\)。</li>
<li><a href="https://en.wikipedia.org/wiki/Double_hashing"><strong>Double hashing</strong></a>：以固定間隔大小 \(k\)（probe distance），依序探測 \(i + k, i + k \cdot 2 ...\) 的 slot 是否為空。而這個間隔是以另外一個雜湊函數計算所得，因此得名「雙雜湊」。</li>
</ul>
<blockquote>
<p>\(i\) 為發生碰撞的索引位置。</p>
</blockquote>
<p>這些方法的差異主要在於 CPU caching 的效能，以及 HashMap 資料的群聚效應（clustering）的敏感程度。當然，論 caching 絕對非 linear probing 莫屬，但 linear probing 以線性一個挨一個探勘，效能較容易受雜湊值群聚影響。</p>
<p>以下是 linear probing（間隔 = 1）的示意圖。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/90/HASHTB12.svg/1280px-HASHTB12.svg.png" alt="" /></p>
<a class="header" href="#a動態調整雜湊表大小" id="a動態調整雜湊表大小"><h3>動態調整雜湊表大小</h3></a>
<p>若資料的筆數已知，那初始配置的陣列大小設定與資料筆數成比例，就不必擔心雜湊表空間不夠，需要重新配置（reallocate）儲存空間的困擾。倘若資料量未知，而最初配置的 bucket array 滿了，該如何重新配置呢？</p>
<p>動態調整大小對雜湊表來說，不同於一般動態陣列，舊的雜湊表若要對應到新雜湊表，是每個鍵都需要重新計算雜湊值（rehash），成本相對較高。因此，減少動態調整的次數，可說是調教雜湊表的重點之一。說到調教雜湊表，必定要瞭解一個重要指標：<em>load factor</em>。</p>
<p>$$\text{load factor} = \frac{n}{k}$$</p>
<blockquote>
<p>\(n\)：已放入雜湊表內的資料總數。
\(k\)：雜湊表配置的儲存空間（bucket 總數）。</p>
</blockquote>
<p>Load factor 代表目前雜湊表的「使用率」，若三筆資料放在四個 bucket 內，則 load factor 為 \(3/4 = 75%\)。Load factor 太大會更容易碰撞，會有效能上的影響；太小則代表過多冗餘空間沒有使用。如何維持 load factor 在一定範圍內至關重要。一般來說，75% 的 load factor 就可以準備重新配置雜湊表了，當然，這個門檻仍要以實作經驗為主，例如 Rust 的 <a href="https://doc.rust-lang.org/stable/std/collections/hash_map/index.html"><code>HashMap</code></a> 使用了 <a href="https://doc.rust-lang.org/stable/src/std/collections/hash/map.rs.html#82-103">Robin Hood Hashing</a>，將 load factor 調教到 90%。</p>
<p>重配置雜湊表與動態陣列的動態調整大小雷同，達到某個門檻值，就會將底層陣列大小翻倍。為了避免開銷過高，通常元素減少時，不會主動調整大小，而是提供一個 <code>shrink_to_fit</code> 一類的方法，讓呼叫端自行決定釋放多餘空間的時機。</p>
<a class="header" href="#a架構設計" id="a架構設計"><h2>架構設計</h2></a>
<p>在介紹架構設計之前，我們先來瞭解 Rust 雜湊相關的觀念與 trait。</p>
<a class="header" href="#hash-and-eq" id="hash-and-eq"><h3>Hash and Eq</h3></a>
<p>要實作雜湊函數，當然可以自幹計算雜湊值的函式來用，那為什麼還要使用 Rust 定義好的 <a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a> 呢？當然是希望將雜湊的介面抽象化，只要型別宣告符合 <code>Hash</code> trait，任何人都可以輕鬆計算雜湊值。而實作 <a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a> 很簡單，只要寫一個 <code>fn hash()</code>，呼叫端就能透過它計算雜湊，例如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::hash::{Hash, Hasher};

struct Car {
  brand: String,
}

impl Hash for Car {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.brand.hash(state);
    }
}
#}</code></pre></pre>
<p>光是計算雜湊值還不夠，要確定「當鍵相等時，其雜湊值也相等」這極為重要的雜湊特性，這時候除了實作 <code>Hash</code> trait，<code>Eq</code> trait 也要同時實作，該型別才能夠「被比較」，標準函式庫的 <code>HashMap</code> 的鍵就是實作 <code>Hash + Eq</code> 的型別，詳情請參閱 trait 的文件說明。</p>
<p>綜合以上，可以大膽定論，我們將實作的雜湊表的 key 一定符合 <code>K: Hash + Eq</code>，key 本身才能相互比較（實作 <code>Eq</code>），並開放呼叫端自定義型別實作不同的雜湊計算方式（實作 <code>Hash</code>）。</p>
<p>為了方便計算雜湊值，我們寫了一個輔助函式，以達成雜湊兩步驟：<strong>計算雜湊值﹢取模</strong>。其中，我們使用了 Rust 預設的雜湊演算法 <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.DefaultHasher.html">DefaultHasher</a>，省下實作雜湊函數的功夫。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn make_hash&lt;X&gt;(x: &amp;X, len: usize) -&gt; usize
    where X: Hash + ?Sized,                   // 1
{
    let mut hasher = DefaultHasher::new();    // 2
    x.hash(&amp;mut hasher);
    hasher.finish() as usize % len
}
#}</code></pre></pre>
<ol>
<li><code>X</code> 泛型參數除了 <code>Hash</code>，還必須是 <a href="https://doc.rust-lang.org/book/2018-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait">Dynamically sized type</a>（DSTs，型別記作 <code>?Sized</code>）</li>
<li>Rust 的 hasher 是一狀態機，每餵他吃資料，<code>hasher.finish()</code> 產生的雜湊值就不同，為了確保雜湊相同，這裡每次呼叫就建立一個全新的 hasher。</li>
</ol>
<blockquote>
<p>所謂 <strong>Dynamically sized type</strong> 是指無法靜態得知大小的型別，例如 slice，或是一個函式的參數接受實作某個 trait 型別（<a href="https://doc.rust-lang.org/book/2018-edition/ch17-02-trait-objects.html">trait object</a>），而在 Rust 幾乎所有基礎型別預設都是 <code>Sized</code> 編譯期就可得知大小。而在這裡我們不關心知道實作該型別可否靜態決定大小，只需知道它是否實作 <code>Hash</code>，所以明確添加 <code>?Sized</code> 表示接受 DST。</p>
</blockquote>
<a class="header" href="#a記憶體佈局" id="a記憶體佈局"><h3>記憶體佈局</h3></a>
<p>我們嘗試建立可以儲存 key-value pair 的結構體，裡面配置一個 bucket array <code>buckets</code>。其中 <code>K</code> 泛型參數是準備計算雜湊的鍵，而 <code>V</code> 則是與鍵配對的資料。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct HashMap&lt;K, V&gt; where K: Hash + Eq {
    buckets: Vec&lt;(K, V)&gt;,
}
#}</code></pre></pre>
<p>可是，用單一 <code>Vec</code> 儲存所有資料，萬一雜湊碰撞，不同鍵指向同個索引值該如何？這次先挑選相對容易的方案 separate chaining 處理碰撞，並以 <code>Vec</code> 動態陣列作為每個 bucket 儲存碰撞元素的容器，因此，<code>buckets</code> 陣列裡面改存 <code>Bucket</code> 陣列，而 <code>Bucket</code> 則儲存真正的 key-value pair。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Bucket&lt;K, V&gt; = Vec&lt;(K, V)&gt;;              // 1

pub struct HashMap&lt;K, V&gt; where K: Hash + Eq {
   buckets: Vec&lt;Bucket&lt;K, V&gt;&gt;,                // 2
   len: usize,                                // 3
}
#}</code></pre></pre>
<ol>
<li>宣告 bucket 的型別 <code>Bucket</code>，實際上是一個 type alias 指向儲存鍵值 <code>(K, V)</code> 的動態陣列。</li>
<li>將 <code>HashMap.buckets</code> 改為儲存 <code>Bucket</code> 的動態陣列。</li>
<li>新增 <code>len</code> 記錄容器當前鍵值對數目，在增刪資料時， <code>len</code> 都會同步更新。</li>
</ol>
<p>之所以使用額外的成員記錄資料數目，是為了計算數目能在 O(1) 時間內完成，nested array 動態迭代每個 <code>Bucket</code> 計算的成本太高。</p>
<p>這就是 <strong>Vector-based separate chaining HashMap</strong> 的記憶體佈局，來看張精美的雜湊表架構佈局圖吧！</p>
<p><img src="hash_map_layout.svg" alt="" /></p>
<a class="header" href="#a基本操作" id="a基本操作"><h2>基本操作</h2></a>
<p>雜湊表有以下幾個基本操作：</p>
<ul>
<li><code>new</code>：初始化一個空雜湊表。</li>
<li><code>with_capacity</code>：配置特定數量 bucket 的雜湊表。</li>
<li><code>get</code>：取得指定鍵對應的資料。</li>
<li><code>get_mut</code>：取得指定鍵對應的資料，並可寫入修改（mutable）。</li>
<li><code>insert</code>：在任意位置插入一組鍵值對。</li>
<li><code>remove</code>：移除任意位置下的鍵值對。</li>
<li><code>clear</code>：清除所有鍵值對。</li>
<li><code>is_empty</code>：檢查雜湊表是否沒有任何鍵值對。</li>
<li><code>len</code>：檢查目前鍵值對的數目。</li>
<li><code>bucket_count</code>：檢查目前 bucket 的數目。</li>
</ul>
<p>以及幾個內部方法：</p>
<ul>
<li><code>try_resize</code>：根據給定條件，決定調整 bucket 數目的時機，讓 load factor 維持最適狀態。</li>
<li><code>make_hash</code>：從輸入資料產生雜湊值，再模除 bucket 數，得到輸入資料對應的索引位置。</li>
</ul>
<p>接下來解釋實作的重點。</p>
<a class="header" href="#a初始化與預設值" id="a初始化與預設值"><h3>初始化與預設值</h3></a>
<p>雜湊表初始化相對容易，一樣慣例使用 <code>new</code>。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;K, V&gt; HashMap&lt;K, V&gt; where K: Hash + Eq {
    pub fn new() -&gt; Self {
        Default::default()
    }
    /// ...
}

impl&lt;K, V&gt; Default for HashMap&lt;K, V&gt; 
    where K: Hash + Eq 
{
    fn default() -&gt; Self { 
        Self { buckets: Vec::&lt;Bucket&lt;K, V&gt;&gt;::new(), len: 0 }
    }
}
#}</code></pre></pre>
<p>這裡為了符合人因工程，使用了 <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> trait 設定初始值。此外，由於 Rust 的容器型別慣例上沒有任何元素時，不會配置任何記憶體空間，僅有初始的 pointer。所以 HashMap 初始化後，記憶體空間僅</p>
<ul>
<li><code>buckets</code> 的 <code>Vec</code> 佔據 3 個 usize 大小（一個 heap 指標，兩個記錄容量與長度的 usize。</li>
<li><code>len</code> 本身佔據 1 個 usize 大小。</li>
</ul>
<p>所以預設初始化的 HashMap 在 64bit machine 上僅佔 4 * usize = 32 bytes。</p>
<p>為了後續實作 rezie 容易些，同時實作了指定 bucket 數目的建構式。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]

#fn main() {
pub fn with_capacity(cap: usize) -&gt; Self {
    let mut buckets: Vec&lt;Bucket&lt;K, V&gt;&gt; =  Vec::new();
    for _ in 0..cap {
        buckets.push(Bucket::new());
    }
    Self { buckets, len: 0 }
} 
#}</code></pre></pre>
<p>很清楚地，同樣建立一個空的 bucket array，再預先配置給定數量的 <code>Bucket</code> 。<code>len</code> 則因為沒有開始增加新值，而設定為 0。</p>
<a class="header" href="#a存取單一元素" id="a存取單一元素"><h3>存取單一元素</h3></a>
<p>存取元素的實作也非常直觀，</p>
<ol>
<li>使用 <code>make_hash</code> 計算出 key 對應的索引位置，</li>
<li>再透過 <code>Vec::get</code> 取得該索引下的 bucket，找不到時則返回 <code>None</code>，</li>
<li>找到 bucket 後則對整個 bucket 線性搜索與 key 相同的鍵值對。</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn get(&amp;self, key: &amp;K) -&gt; Option&lt;&amp;V&gt; {
    let index = self.make_hash(key);
    self.buckets.get(index).and_then(|bucket|
        bucket.iter()
            .find(|(k, _)| *k == *key)
            .map(|(_, v)| v)
    )
}
#}</code></pre></pre>
<p>這邊需要加強人因工程，當我們透過 <code>HashMep::get</code> 搜尋特定鍵時，必須傳入一模一樣的型別，例如 <code>HashMap&lt;&amp;str, u8&gt;</code> 就只能透過相同的 borrowed value <code>&amp;str</code> 搜索，而不能透過 owned value <code>&amp;String</code> 尋找，就算兩個型別可無痛轉換也無法。而 Rust 標準函式庫有做到這一點，因為其泛型參數 <code>K</code> 實作了 <a href="https://doc.rust-lang.org/stable/std/borrow/trait.Borrow.html">Borrow</a> trait，抽象化 owned 與 borrowed 間的型別，讓呼叫端無論傳 owned 或 borrowed 型別都可以有相同的行為。</p>
<blockquote>
<p><code>fn get_mut()</code> 與 <code>fn get()</code> 的差異只在於呼叫了 <code>self.bucket.get_mut</code> 取得 mutable reference。</p>
</blockquote>
<a class="header" href="#a插入與刪除元素" id="a插入與刪除元素"><h3>插入與刪除元素</h3></a>
<p>插入與刪除比較特別，需要做些額外的功夫：</p>
<ul>
<li>在操作完成之後需依據操作結果增減 <code>HashMap.len</code>，確保 <code>len</code> 永遠記錄正確的鍵值對數目。</li>
<li>在執行插入之前，需額外「動態調整」儲存空間，確保記憶體配置足夠空間新增元素。</li>
</ul>
<p>先來看看刪除怎麼實作。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn remove(&amp;mut self, key: &amp;K) -&gt; Option&lt;V&gt; {
    let index = self.make_hash(key);                    // 1
    self.buckets.get_mut(index).and_then(|bucket| {     // 2
        bucket.iter_mut()
            .position(|(k, _)| *k == *key)
            .map(|index| bucket.swap_remove(index).1)
    }).map(|v| {                                        // 3
        self.len -= 1; // Length decreases by one.
        v
    })
}
#}</code></pre></pre>
<ol>
<li>所有涉及搜尋的操作，第一步一定是計算雜湊值。</li>
<li>建立 mutable 的迭代器，利用 <a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.position"><code>posiion</code></a> 找到對應的鍵值對，再呼叫 <code>Vec::swap_remove</code> 移除。</li>
<li>前一步驟若有 return value 產生，表示移除一個元素，因此 <code>self.len</code> 需手動減一。</li>
</ol>
<blockquote>
<p><code>Vec::swap_remove</code> 不需要 resize array，而是取得最後一個元素填補該空間，由於雜湊表的排序不重要，我們選擇 <code>swap_remove</code> 減少一點開銷。</p>
</blockquote>
<p>而插入與移除非常相似。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn insert(&amp;mut self, key: K, value: V) -&gt; Option&lt;V&gt; {
    self.try_resize();                                      // 1
    let index = self.make_hash(&amp;key);                       // 2
    self.buckets.get_mut(index).and_then(|bucket|
        match bucket.iter_mut().find(|(k, _)| *k == key) {  // 3
            Some((_ , v)) =&gt;  Some(mem::replace(v, value)), // 3.1
            None =&gt; {                                       // 3.2
                bucket.push((key , value));
                None
            }
        }
    ).or_else(|| { //  Length increase by one.              // 4
        self.len += 1;
        None
    })
}
#}</code></pre></pre>
<ol>
<li>嘗試調整雜湊表大小，以確保 load factor 在閾值之間。</li>
<li>同樣地，根據鍵計算雜湊值，以取得對應的內部 bucket 位置。</li>
<li>迭代整個 bucket 尋找鍵相同的鍵值對。
<ol>
<li>若找到，使用 <a href="https://doc.rust-lang.org/stable/std/mem/fn.replace.html"><code>mem::replace</code></a> 取代資料部分，不需取代整個鍵值對。</li>
<li>若找無，則新增一組新鍵值對到該 bucket 中。</li>
</ol>
</li>
<li>決定是否該將長度記錄加一。若插入操作實際上是更新（update）原有鍵值對的資料，則會回傳被更新的舊資料 <code>Some((K, V))</code>；若是實際新增元素（push），我們回傳一個 <code>None</code>，<code>or_else</code> 就可以根據 <code>None</code> 判斷需要將長度加一。</li>
</ol>
<a class="header" href="#a動態調整儲存空間" id="a動態調整儲存空間"><h3>動態調整儲存空間</h3></a>
<p>動態調整儲存空間大概是整個實作中最 tricky 的一部分。首先，我們需要知道</p>
<ul>
<li>容器內鍵值對的總數：透過 <code>self.len</code>，我們將取得 <code>self.len</code> 的邏輯包裝在 <code>fn len(&amp;self)</code>，以免未來長度移動至別處儲存計算。</li>
<li>容器內 bucket 的總數：計算 <code>self.bucket.len()</code>，同樣地，將之包裝在 <code>fn bucket_count(&amp;self)</code>，並開放給外界呼叫。</li>
<li>Load factor 閾值：記錄在 <code>const LOAD_FACTOR</code>，設定為 0.75。</li>
</ul>
<p>前情提要完畢，接下來就是程式碼的部分了。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn try_resize(&amp;mut self) {
    let entry_count = self.len();                               // 1
    let capacity = self.bucket_count();

    // Initialization.
    if capacity == 0 {                                          // 2
        self.buckets.push(Bucket::new());
        return
    }

    if entry_count as f64 / capacity as f64 &gt; LOAD_FACTOR {     // 3
        // Resize. Rehas. Reallocate!
        let mut new_map = Self::with_capacity(capacity &lt;&lt; 1);   // 4
        self.buckets.iter_mut()                                 // 5
            .flat_map(|bucket| mem::replace(bucket, vec![])) 
            .for_each(|(k, v)| { new_map.insert(k, v); });
        *self = new_map;                                        // 6
    }
}
#}</code></pre></pre>
<ol>
<li>取得所有需要用到的長度資料。</li>
<li>若當前容量為 0，表示尚未新增任何元素，我們 push 一個空 bucket 進去，讓其他操作可以正常新增鍵值對。</li>
<li>判斷 load factor，決定需不需要動態調整大小。</li>
<li>透過 <code>HashMap::with_capacity</code> 建立容量兩倍大的空雜湊表。</li>
<li>開始迭代舊的 bucket，並利用 <a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.flat_map"><code>flat_map</code></a> 打平 nested vector，在利用 <a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.for_each"><code>for_each</code></a> 將每個元素重新 insert 到新雜湊表。</li>
<li>把 <code>self</code> 的值指向新雜湊表，舊雜湊表的記憶體空間會被釋放。</li>
</ol>
<a class="header" href="#a效能" id="a效能"><h2>效能</h2></a>
<p>以陣列實作的雜湊表各操作複雜度如下</p>
<table><thead><tr><th> Operation    </th><th> Best case    </th><th> Worst case </th></tr></thead><tbody>
<tr><td> add(k, v)    </td><td> \(O(1)\)~  </td><td> \(O(n)\) </td></tr>
<tr><td> update(k, v) </td><td> \(O(1)\)   </td><td> \(O(n)\) </td></tr>
<tr><td> remove(k)    </td><td> \(O(1)\)~  </td><td> \(O(n)\) </td></tr>
<tr><td> search(k)    </td><td> \(O(1)\)   </td><td> \(O(n)\) </td></tr>
</tbody></table>
<blockquote>
<p>\(n\)：資料筆數。<br />
\(k\)：欲綁定資料的鍵。<br />
\(v\)：欲與鍵綁定的資料。<br />
<strong>~</strong>：平攤後的複雜度（amortized）。</p>
</blockquote>
<a class="header" href="#a時間複雜度" id="a時間複雜度"><h3>時間複雜度</h3></a>
<p>在預期情況下，只要雜湊函數品質穩定，大部分操作都可達到在常數時間， 但由於部分操作，尤其是新增或刪除元素的操作，會需要調整 bucket array 的空間，重新配置記憶體空間，所以需要平攤計算複雜度。</p>
<p>而最差複雜度出現在每個元素都發生雜湊碰撞。若使用 open addressing 處理碰撞，則會把雜湊表配置的每個位置都填滿，而所有操作都從同個位置開始，搜尋對應的鍵，複雜度與陣列的線性搜索相同為 \(O(n)\)；若使用 separate chaining，碰撞代表所有元素都會在同一個 bucket 裡面，也就是只有一個 bucket 上會有一個長度為 <em>n</em> ，被塞滿的陣列或鏈結串列，結果同樣是線性搜索的 \(O(n)\)。</p>
<p>我們嘗試使用數學表示搜索的複雜度。另</p>
<ul>
<li>\(n\)：已放入雜湊表內的資料總數。</li>
<li>\(k\)：雜湊表配置的儲存空間（bucket 總數）。</li>
<li>\(\text{load factor} = \frac{n}{k}\)
<ul>
<li>預期每個 bucket 儲存的資料筆數</li>
</ul>
</li>
</ul>
<p>則預期執行時間為</p>
<p>$$\Theta(1+\frac{n}{k}) = O(1)  \text{ if } \frac{n}{k} = O(1)$$</p>
<p>而 <strong>1</strong> 為計算雜湊與取得索引（random access）的執行時間，\(\frac{n}{k}\) 則是搜尋陣列的執行時間。只要 load factor 越接近 \(n\)，執行時間就相對增加。</p>
<a class="header" href="#a空間複雜度" id="a空間複雜度"><h3>空間複雜度</h3></a>
<p>雜湊表的空間複雜度取決於實作預先配置的陣列大小，並與維持 <em>load factor</em> 息息相關。一般來說，仍與資料筆數成線性關係，因此空間複雜度只有資料本身 \(O(n)\)。而以 separate chaining 會額外配置陣列或鏈結串列儲存碰撞元素，理論上需負擔更多額外的指標儲存空間。</p>
<a class="header" href="#a參考資料" id="a參考資料"><h2>參考資料</h2></a>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/collections/hash_map/index.html">Rust Documentation: HashMap</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hash_table">Wiki: Hash table</a></li>
<li><a href="https://en.wikipedia.org/wiki/Open_addressing">Wiki: Open addressing</a></li>
<li><a href="https://algs4.cs.princeton.edu/34hash/">Algorithms, 4th Edition by R. Sedgewick and K. Wayne: 3.4 Hash Tables</a></li>
<li><a href="https://courses.csail.mit.edu/6.006/fall11/notes.shtml">MIT 6.006: Introduction to Algorithms, fall 2011: Unit 3 Hashing</a></li>
<li>Map graph by Jorge Stolfi <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA-3.0</a> via Wikimedia Commons.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../collections/map/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../collections/map/ordered_map.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../../collections/map/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../../collections/map/ordered_map.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-118441906-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
