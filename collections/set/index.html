<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>集合 Set - Rust Algorithm Club</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Learn algorithms and data structures with Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Algorithm Club</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/weihanglo/rust-algorithm-club" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="集合-set"><a class="header" href="#集合-set">集合 Set</a></h1>
<p>集合是一種抽象資料型別（Abstract data type），概念衍生自數學的<a href="https://en.wikipedia.org/wiki/Set_theory">集合論</a>，和陣列類似，為不同元素所組成的資料結構，不同在於集合有些重要的特性：</p>
<ul>
<li>無序性：集合內各元素無特定排序或排序不重要。</li>
<li>互異性：集合內每個元素且只能出現一次。</li>
</ul>
<p>一般來說，集合的實作會盡量貼近集合論中的有限集合定義，本次實作同樣遵照數學定義。</p>
<blockquote>
<p>本次實作的程式碼置於 <a href="/doc/rust_algorithm_club/collections/struct.HashSet.html"><code>rust_algorithm_club::collections::HashSet</code></a> API 文件中。</p>
</blockquote>
<h2 id="架構設計"><a class="header" href="#架構設計">架構設計</a></h2>
<h3 id="以雜湊表為底層容器"><a class="header" href="#以雜湊表為底層容器">以雜湊表為底層容器</a></h3>
<p>集合能以許多不同的資料結構實現，通用的集合實作多會最佳化取得、增加、移除元素等運算，這讓我們想到了「<a href="../hash_map">雜湊表</a>」，雜湊表正是能將集合運算最佳化的一種資料結構，我們將借用<strong>雜湊表作為底層儲存容器</strong>，進一步實作集合。</p>
<p>你可能好奇，集合明明只有元素，並沒有<strong>鍵值對</strong>，跟雜湊表有啥關係？讓我們回想雜湊表一個重要的特性：每一個鍵（key）只會出現一次，利用雜湊表這個特性，即可達成上述集合兩大特性。</p>
<p>既然選用雜湊表作為底層容器，集合的結構體就非常簡單了，我們可以將集合想像為在 HashMap 薄薄的一層封裝。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct HashSet&lt;T&gt;
where
    T: Hash + Eq,
{
    hash_map: HashMap&lt;T, ()&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>比較特別的是雜湊表的鍵值，這裡使用空的 tuple <code>()</code>，也就是以 <a href="https://doc.rust-lang.org/std/primitive.unit.html">unit type</a> 作為雜湊表之值，只要將集合的元素作為雜湊表鍵，忽略對應的值，就是貨真價實的集合結構。</p>
<h3 id="不佔空間的-unit-type"><a class="header" href="#不佔空間的-unit-type">不佔空間的 Unit Type</a></h3>
<p>這樣多儲存一個 <code>()</code> 會不會造成額外的儲存空間負擔？事實上，Unit type <code>()</code> 在 Rust 語言中是一種 <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">Zero Sized Types (ZSTs)</a>，在編譯時期 Rust 會將 ZST 當作一種型別來操作，但真正輸出的機器碼中，ZST 並不會佔用任何運算空間。<code>Set = HashMap&lt;T, ()&gt;</code> 完全體現了 Rust 零成本抽象的語言特性。</p>
<h2 id="基本操作"><a class="header" href="#基本操作">基本操作</a></h2>
<p>身為一個容器，集合有以下幾個基本操作：</p>
<ul>
<li><code>new</code>：初始化一個集合。</li>
<li><code>contains</code>：檢查集合內有無特定元素。</li>
<li><code>is_empty</code>：檢查集合內是否沒有任何元素。</li>
<li><code>insert</code>：新增一個元素。</li>
<li><code>remove</code>：移除特定元素。</li>
<li><code>len</code>：檢查集合內的元素數目。</li>
<li><code>iter</code>：產生一個疊代集合內所有元素的疊代器。</li>
</ul>
<p>這些基本操作的實作上，只是對雜湊表的簡單封裝，詳細實作可以參考 <a href="../hash_map">HashMap</a>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; HashSet&lt;T&gt;
where
    T: Hash + Eq,
{
    pub fn len(&amp;self) -&gt; usize {
        self.hash_map.len()
    }

    pub fn is_empty(&amp;self) -&gt; bool {
        self.hash_map.is_empty()
    }

    pub fn insert(&amp;mut self, value: T) -&gt; bool { // 1
        self.hash_map.insert(value, ()).is_none()
    }

    pub fn contains&lt;Q&gt;(&amp;self, value: &amp;Q) -&gt; bool // 2
    where
        T: Borrow&lt;Q&gt;,
        Q: Hash + Eq + ?Sized,
    {
        self.hash_map.get(value).is_some()
    }

    pub fn remove&lt;Q&gt;(&amp;mut self, value: &amp;Q) -&gt; bool // 3
    where
        T: Borrow&lt;Q&gt;,
        Q: Hash + Eq + ?Sized,
    {
        self.hash_map.remove(value).is_some()
    }

    pub fn iter(&amp;self) -&gt; impl Iterator&lt;Item = &amp;T&gt; { // 4
        self.hash_map.iter().map(|(k, _)| k)
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li><code>insert</code> 將元素置於 key 上，value 則設為 <code>()</code>。</li>
<li><code>contains</code> 利用 <code>HashMap::get</code> 回傳的 <code>Option&lt;()&gt;</code> 判斷是否已有該的元素。</li>
<li><code>remove</code> 同樣直接呼叫 <code>HashMap::remove</code>，並透過回傳 <code>Option&lt;()&gt;</code> 判斷實際上是否有移除任何元素。</li>
<li><code>iter</code> 則直接利用 <code>HashMap::iter</code> 並捨棄 value。</li>
</ol>
<h2 id="集合運算"><a class="header" href="#集合運算">集合運算</a></h2>
<p>電腦科學的集合型別衍生自<a href="https://en.wikipedia.org/wiki/Set_theory">集合論</a>，當然也得符合<a href="https://en.wikipedia.org/wiki/Algebra_of_sets">集合代數（set algebra）</a>的特性，和算術的加減乘除，集合也有自己的二元運算，我們會實作以下幾個基本方法：</p>
<ul>
<li><code>intersection</code>：交集，A ∩ B 定義為 A 與 B 共有的元素。</li>
<li><code>union</code>：聯集，A ∪ B 定義為 A 與 B 所有的元素。</li>
<li><code>symmetric_difference</code>：對稱差集，定義為 A △ B = (A ∪ B) - (A ∩ B)，就是只出現在 A 或 B，不會在兩集合內同時出現的元素。</li>
<li><code>difference</code>：差集，A \ B 定義為 A 中所有未在 B 中出現的元素。</li>
</ul>
<p><img src="https://i.imgur.com/jeLakB0.png" alt="venn digrams" /></p>
<p>此外，也會介紹許多方便的方法：</p>
<ul>
<li><code>is_disjoint</code>：兩集合是否不交集。</li>
<li><code>is_subset</code>：包含於 ⊆，是否為子集。</li>
<li><code>is_superset</code>：包含 ⊇，是否為超集。</li>
</ul>
<p>哇！好多方法要實作。那就事不宜遲！</p>
<h3 id="實作聯集"><a class="header" href="#實作聯集">實作聯集</a></h3>
<h4 id="第一次嘗試---建立新的聯集集合"><a class="header" href="#第一次嘗試---建立新的聯集集合">第一次嘗試 - 建立新的聯集集合</a></h4>
<p>要取得兩個集合的聯集，最直覺的想法可能是創造一個新的集合，再把 A 和 B 兩個集合的元素通通 <code>insert</code> 進去，就像這樣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 利用 Clone 實現的聯集。完整實作見 bit.ly/caab7fb
pub fn union(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; HashSet&lt;T&gt; {
    // 複製一整份 other 到新的 set
    let mut new_set: HashSet&lt;T&gt; = other.clone();

    // 把現有的 item 一一塞到新的 set，重複的 item 會直接覆寫掉
    self.hash_map.iter().for_each(|(k, _)| {
        new_set.insert(k.clone());
    });

    // 回傳 self 與 other 的聯集
    new_set
}
<span class="boring">}</span></code></pre></pre>
<p>然而，上述做法有兩個缺點：</p>
<ol>
<li>建立了一個全新的 HashSet 實例，花了額外的時間與空間</li>
<li>必須為 <code>HashSet</code> 和 item 的型別 <code>T</code> 額外加上 <code>Clone</code> trait 的限制</li>
</ol>
<p>因此接下來我們嘗試利用 Rust 的 <code>iterator</code> 的特性實現更節省資源的版本！</p>
<blockquote>
<p>更多詳情可參考實作過程的<a href="https://github.com/weihanglo/rust-algorithm-club/pull/15#issuecomment-427587785">討論串</a>與<a href="https://github.com/weihanglo/rust-algorithm-club/pull/15/commits/caab7fbc5323e09eb1e30ea374eb21a59f955bad">第一次嘗試的完整實作</a>。</p>
</blockquote>
<h4 id="第二次嘗試---lazy-iterator"><a class="header" href="#第二次嘗試---lazy-iterator">第二次嘗試 - Lazy Iterator</a></h4>
<p>有了第一次嘗試的經驗，第二次決定讓 <code>union()</code> 回傳一個 lazy iterator，會疊代聯集的元素，必要才從疊代器收集所有元素，再建立新的集合，如此可以節省許多運算資源。</p>
<p>至於實作步驟，我們可以：</p>
<ol>
<li>先製造一個疊代器，包含所有 <code>other</code> 集合的元素，但過濾掉與 <code>self</code> 共有的元素。</li>
<li>再將 <code>self</code> 的疊代器與步驟一產生的疊代器，利用 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain"><code>Iterator::chain</code></a> 連起來。</li>
</ol>
<p>這樣其實就是 <code>other \ self</code> 這個差集，加上 <code>self</code> 自身，剛好就是聯集。程式碼如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 使用 impl trait 語法，避免宣告不同疊代器型別的麻煩。
pub fn union(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;T&gt; {
    // 實際上就是差集
    let other_but_not_self = other.iter().filter(|item| !self.contains(item));
    // 差集 + self 本身
    self.iter().chain(other_but_not_self)
}
<span class="boring">}</span></code></pre></pre>
<h4 id="lifetime-elision"><a class="header" href="#lifetime-elision">Lifetime Elision</a></h4>
<p>但很不幸地，Compiler error E0623（甚至查不到 E0623 是什麼）。</p>
<pre><code class="language-bash">error[E0623]: lifetime mismatch
   --&gt; src/collections/set/mod.rs:117:48
    |
117 |     pub fn union(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;T&gt; {
    |                                -----------     ^^^^^^^^^^^^^^^^^^^^^^^^
    |                                |               |
    |                                |               ...but data from `other` is returned here
    |                                this parameter and the return type are declared with different lifetimes...
</code></pre>
<p>是 <code>self</code> 與 <code>other</code> 的生命週期不同導致，當這兩個集合的疊代器被 chain 起來後回傳，編譯器無法確認 Iterator 的 Item 生命週期多長。你可能很好奇為什麼 <code>self</code> 與 <code>other</code> 生命週期不同，事實上，Rust 為了讓語法輕鬆一點，允許函數省略部分生命週期標註，這個行為稱作 <a href="https://doc.rust-lang.org/nomicon/lifetime-elision.html">Lifetime Elision</a>，會在各種不同的條件下加註生命週期，其中有一條是「<strong>每個被省略的生命週期都會成為獨立的生命週期</strong>」。因此，<code>union()</code> 加上被省略的生命週期，會長得像：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn union&lt;'a, 'b&gt;(&amp;'a self, other: &amp;'b HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;'a ??? &amp;'b ???T&gt;;
<span class="boring">}</span></code></pre></pre>
<p>於是乎，編譯器無法理解 Iterator&lt;Item = &amp;T&gt; 的 <code>&amp;T</code> 到底生命週期是 ’a 還是 ’b，就不給編譯。</p>
<p>解法也很簡單，合併 <code>self</code> 與 <code>other</code> 的生命週期到同一個，不論是語意上（兩個集合至少活得一樣長）還是編譯條件都說得通。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 加上 'a ，讓 self、other 的生命週期至少在這個函數內一樣長
pub fn union&lt;'a&gt;(&amp;'a self, other: &amp;'a HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;T&gt; {
    let other_but_not_self = other.iter().filter(|item| !self.contains(item));
    self.iter().chain(other_but_not_self)
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>更多 Lifetime Elision 的資訊，可以參考 <a href="https://doc.rust-lang.org/nomicon/lifetime-elision.html">Rust 黑魔法 Nomicon</a> 與 <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">Rust TRPL 的解釋</a>，還有相關的 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0141-lifetime-elision.md">RFC</a> 可以看。</p>
</blockquote>
<h4 id="move-closure"><a class="header" href="#move-closure"><code>move</code> closure</a></h4>
<p>解決了生命週期，編譯看看就知道誰沒穿褲子。<a href="https://doc.rust-lang.org/error-index.html#E0373">Compiler error E0373</a>，是野生的 borrow checker！</p>
<pre><code class="language-bash">error[E0373]: closure may outlive the current function, but it borrows `self`, which is owned by the current function
   --&gt; src/collections/set/mod.rs:118:53
    |
118 |         let other_but_not_self = other.iter().filter(|item| !self.contains(item));
    |                                                     ^^^^^^  ---- `self` is borrowed here
    |                                                     |
    |                                                     may outlive borrowed value `self`
    |
note: closure is returned here
   --&gt; src/collections/set/mod.rs:119:9
    |
119 |         self.iter().chain(other_but_not_self)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `self` (and any other referenced variables), use the `move` keyword
    |
118 |         let other_but_not_self = other.iter().filter(move |item| !self.contains(item));
</code></pre>
<p>讓我們嘗試理解，當我們回傳 iterator 時，整個過濾共同元素的 closure 會連帶一起回傳，若 closure 沒有使用 <code>move</code> 關鍵字修飾，編譯器會嘗試以傷害最小的方式去捕獲變數，在這裡會是 immutable borrow <code>&amp;T</code> 捕獲。這裡的 <code>self</code> 實際型別是 <code>&amp;'a mut HashSet&lt;T&gt;</code>，可以想像成 closure 捕獲了 <code>&amp;(&amp;'a mut HashSet&lt;T&gt;)</code>。</p>
<blockquote>
<p>Rust 編譯器遇到 closure 需要捕獲變數時，如果沒有用 <code>move</code> 修飾，會嘗試使用以下順序來捕獲： <code>&amp;T</code> &gt; <code>&amp;mut T</code> &gt; <code>T</code>。若用了 <code>move</code> 修飾，則會直接將所有權轉移進 clousure 中，也就是捕獲 <code>T</code>。</p>
</blockquote>
<p>可惜的是，多出來的這層 borrow 並沒有相同的生命週期 <code>'a</code>，編譯器無法識別它會活到什麼時候，可能 <code>self</code> 的資源已被釋放，但 closure 還沒結束，有機會產生 <a href="https://en.wikipedia.org/wiki/Dangling_pointer">dangling pointer</a>，編譯器因此禁止這種危險操作。</p>
<p>編譯器也十分好心地提示，只要使用 <code>move</code> 關鍵字，將 <code>self</code> 的所有權轉移至 closure 中，就能避免生命週期不一致的問題。你可能有些疑惑，把 <code>self</code> move 進 closure 之後，<code>self</code> 不就會被 drop 釋放掉了？可以這樣理解，轉移進 closure 的型別是整個 <code>self</code>，也就是 <code>&amp;'a mut HashSet&lt;T&gt;</code> 型別，解讀為編譯器將 <code>self</code> 的型別看作新的 owned type，所有權可合法轉移，但底層仍保留指向原始資料的 borrow，巧妙避開生命週期問題。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn union&lt;'a&gt;(&amp;'a self, other: &amp;'a HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;T&gt; {
    // 用 move 修飾 closure
    // self（&amp;'a HashSet&lt;T&gt;）被整個轉移進 closure
    let other_but_not_self = other.iter().filter(move |item| !self.contains(item));
    self.iter().chain(other_but_not_self)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="實作交集差集與對稱差集"><a class="header" href="#實作交集差集與對稱差集">實作交集、差集與對稱差集</a></h3>
<p>呼，上面解決了最困難的生命週期和 borrow checker 問題，接下來的實作只要關注數學上的集合定義就能輕鬆解決了。</p>
<p>首先，交集的定義為「你有，而且我也有的」，簡單，疊代 <code>self</code> 並過濾出 <code>other</code> 也有的元素就好，秒殺！</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn intersection&lt;'a&gt;(&amp;'a self, other: &amp;'a HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;T&gt; {
    self.iter().filter(move |item| other.contains(item))
}
<span class="boring">}</span></code></pre></pre>
<p>再來是差集，概念是就是「我有，但你沒有的」，一樣疊代 <code>self</code> 並過濾出 <code>other</code> 沒有的元素。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn difference&lt;'a&gt;(&amp;'a self, other: &amp;'a HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;T&gt; {
    self.iter().filter(move |item| !other.contains(item))
}
<span class="boring">}</span></code></pre></pre>
<p>剛剛實作 <code>union</code> 有用到差集，我們可以稍微改寫，讓 <code>union</code> 的程式碼更神清氣爽。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn union&lt;'a&gt;(&amp;'a self, other: &amp;'a HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;T&gt; {
    // self ∪ (other \ self)
    self.iter().chain(other.difference(self))
}
<span class="boring">}</span></code></pre></pre>
<p>最後，對稱差集可以透過組合上面的操作算出，可以是：「我有加上你有的，減去我們共同有的」，也可以是「我有但你沒有的，加上你有但我沒有的」，這裡我們選擇第二種實作。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn symmetric_difference&lt;'a&gt;(&amp;'a self, other: &amp;'a HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;T&gt; {
    // (self \ other) ∪ (other \ self)
    self.difference(other).chain(other.difference(self))
}
<span class="boring">}</span></code></pre></pre>
<p>整個集合的基礎在這邊大功告成了！</p>
<h3 id="子集超集與不交集"><a class="header" href="#子集超集與不交集">子集、超集與不交集</a></h3>
<p>經歷 Rust 編譯器的摧殘，來實作比較簡單的方法吧。集合運算常要比較兩個集合的關係，例如 A ⊆ B 代表 A 是 B 的子集，定義是 A 裡面的元素 B 都有。</p>
<p>我們先來實作 <code>is_subset</code> 檢查 <code>self</code> 是否為 <code>other</code> 的子集。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn is_subset(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; bool {
    // 若 self 的元素比 other 多，就不可能是 self ⊆ other
    // 所以提前回傳 false
    if self.len() &gt; other.len() {
        return false;
    }
    // 利用 all 確認 other 內包含 self 的所有元素
    self.iter().all(|item| other.contains(&amp;item))
}
<span class="boring">}</span></code></pre></pre>
<p><code>is_superset</code> 檢查 <code>self</code> 是否為 <code>other</code> 的超集就更簡單了，只要把 <code>is_subset</code> 反過來使用就行了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn is_superset(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; bool {
    // self ⊇ other = other ⊆ self
    other.is_subset(self)
}
<span class="boring">}</span></code></pre></pre>
<p>最後，我們常會檢查兩個集合是否沒有交集（disjoint），這個方法只要檢查交集 <code>intersection()</code> 疊代器的長度是否為 0 就可以了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn is_disjoint(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; bool {
    self.intersection(other).count() == 0
}
<span class="boring">}</span></code></pre></pre>
<h2 id="二元運算與運算子"><a class="header" href="#二元運算與運算子">二元運算與運算子</a></h2>
<p>上面的方法好冗，能不能和 <a href="https://docs.python.org/3/library/stdtypes.html#set">Python</a> 一樣，用簡單明瞭的語法操作集合的二元運算？當然行，Rust 的表達性很強，完全不輸 Python，透過<a href="https://en.wikipedia.org/wiki/Operator_overloading">運算子多載（operator overloading）</a>。</p>
<h3 id="運算子多載"><a class="header" href="#運算子多載">運算子多載</a></h3>
<p>Rust 提供許多 trait 供使用者多載運算子，可以簡化集合的二元運算：</p>
<ul>
<li><code>set | other</code>：bitwise or 運算子，效果同 <code>union</code> 聯集。</li>
<li><code>set &amp; other</code>：bitwise and 效果同 <code>intersection</code> 交集。</li>
<li><code>set - other</code>：substraction 運算子，效果同 <code>difference</code> 差集。</li>
<li><code>set ^ other</code>：bitwise xor 運算子，效果同 <code>symmetric_difference</code> 對稱差集。</li>
</ul>
<p>由於四個運算子實作的概念相同，這裡挑 <code>|</code> <strong>bitwise or</strong> 來解釋如何客製化運算子邏輯。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 實作 BitOr 多載 `|` 運算子
impl&lt;'a, 'b, T&gt; BitOr&lt;&amp;'b HashSet&lt;T&gt;&gt; for &amp;'a HashSet&lt;T&gt;
where
    T: Hash + Eq + Clone, // 實作 Clone 讓 Set 可透過 FromIterator 建立實例
{
    type Output = HashSet&lt;T&gt;;

    fn bitor(self, rhs: &amp;'b HashSet&lt;T&gt;) -&gt; Self::Output {
        // 利用 FromIterator 提供的 collect() 蒐集元素，產生新 Set
        self.union(&amp;rhs).cloned().collect()
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>要多載 bit or 運算子，代表型別要實作 <code>BitOr</code> trait。</li>
<li>由於運算子的 required method 通常會 consume <code>self</code> 的所有權，因此我們要在 impl 動手腳，改以 <code>&amp;HashSet&lt;T&gt;</code> 作為 <code>BitOr</code> 實作的對象。</li>
<li>為了簡化實作，交集聯集等運算子改為產生一個新的 Set 實例，也就是說，<code>T</code> 泛型型別需要實現 <code>Clone</code> trait，才能複製舊的值產生新的 Set。</li>
</ol>
<blockquote>
<p>多載運算子，可以參考 <a href="https://doc.rust-lang.org/beta/std/ops/index.html">Overloadable operators</a> 一頁的說明。</p>
</blockquote>
<h3 id="比較運算子"><a class="header" href="#比較運算子">比較運算子</a></h3>
<p>除了交集、聯集等運算，我們還可以實作集合間的比較，作為檢查是否為子集或超集的運算子。</p>
<ul>
<li><code>A &lt;= B</code>：效果同 <code>is_subset</code>，A 是否為 B 的子集 A ⊆ B。</li>
<li><code>A &lt; B</code>：A 是否為 B 的子集且不等於 B，等同於 A ⊂ B。</li>
<li><code>A &gt;= B</code>：效果同 <code>is_superset</code>，A 是否為 B 的超集 A ⊇ B。</li>
<li><code>A &gt; B</code>：A 是否為 B 的超集且不等於 B，等同於 A ⊃ B。</li>
</ul>
<p>但眼尖的 Rustacean 肯定會發現，<a href="https://doc.rust-lang.org/beta/std/ops/index.html"><code>std::ops</code></a> 裡面根本沒有 <code>lt</code>、<code>gt</code> 等比較運算子。Rust 的「比較」是透過實作幾個 Trait 後，自動推導生成的方法，這些 trait 放在 <a href="https://doc.rust-lang.org/std/cmp/index.html"><code>std::cmp</code></a> module 中，分別是<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>、<a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>ParitalEq</code></a>、<a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>，以及 <a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>ParitalOrd</code></a>。</p>
<p>在開始介紹如何實作比較前，先讓複習一下離散數學學到的二元關係：</p>
<p>若 ∼ 為一種二元關係，A 為任意集合。</p>
<ul>
<li>自反性（Reflexive）：對所有 x ∈ A : x ∼ x。</li>
<li>對稱性（Symmetric）：對所有 x, y ∈ A ，若 x ∼ y 則 y ∼ x。</li>
<li>傳遞性（Transitive）：對所有 x, y, z ∈ A ，若 x ∼ y 且 y ∼ z 則 x ∼ z。</li>
<li>反對稱（Antisymmetric）：對所有 x, y ∈ A，若 x ∼ y 且 x ≠ y 則 y ∼ x 不成立。</li>
</ul>
<p>Rust 中的相等關係有其理論背景，<code>Eq</code> 就是數學上的 <a href="https://en.wikipedia.org/wiki/Equivalence_relation">Equivalence relation</a>，須符合自反性、對稱性，及傳遞性；與之對應的是 <code>PartialEq</code>，<a href="https://en.wikipedia.org/wiki/Partial_equivalence_relation">Partial equivalence</a> 具有對稱性和傳遞性，但並無自反性，有名的例子是 <a href="https://ieeexplore.ieee.org/document/4610935">IEEE754 的浮點數</a> 定義了 <code>NaN == NaN -&gt; false</code>，浮點數因此不符合自反性定義。</p>
<p>回到集合，集合論中的集合相等（set equality）定義為：x = y ⇒ ∀z, (z ∈ x ⇔ z ∈ y)，也就所有屬於集合 x 的元素必屬於集合 y，反之亦然。因此，集合相等具有自反性、對稱性、傳遞性。實作 <code>==</code> 運算子，我們會</p>
<ol>
<li>比較集合 x, y 內元素數目（cardinality）是否一致，以及</li>
<li>疊代集合 x，並檢查是否每個屬於 x 的元素都屬於 y。</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; PartialEq for HashSet&lt;T&gt;
where
    T: Hash + Eq,
{
    fn eq(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; bool {
        // 1. 檢查 cardinality，不同長度就不可能相等
        if self.len() != other.len() {
            return false;
        }
        // 2. 利用 Iterator::all 確保每個 self 的元素都屬於 other。
        self.iter().all(|item| other.contains(&amp;item))
    }
}

/// `Eq` 並沒有 required method，只要實作 `Partial::eq` 方法，就能直接推斷出 `Eq`。
impl&lt;T&gt; Eq for HashSet&lt;T&gt; where T: Hash + Eq {}
<span class="boring">}</span></code></pre></pre>
<p>與相等關係相同，Rust 的排序關係同樣有理論依據，<code>Ord</code> 是數學上的 <a href="https://en.wikipedia.org/wiki/Total_order">Total order</a>，符合反對稱性、傳遞性，以及 <a href="https://en.wikipedia.org/wiki/Connex_relation">connex relation</a>；而 <code>ParitalOrd</code> 則接近數學上的 partial order，Rust 的文件中描述該 trait 須符合反對稱性與傳遞性。</p>
<blockquote>
<p>Connex relation：在集合 X 下，所有 (x, y) pair 都會符合 x ∼ y 或 y ∼ x 的關係。在排序關係上，意指不是 x ≥ y 就是 y ≥ x。</p>
</blockquote>
<p>要把集合的「包含於但不相等」關係 ⊂ 映射到排序關係 <code>x &lt; y</code> 前，先來檢驗 ⊂ 有什麼特性。</p>
<ul>
<li>具反對稱性：若 x ⊂ y 且 x ≠ y 則 y ⊄ x，換句話說，若 x ⊂ y 且 y ⊂ x 則 x = y。</li>
<li>具傳遞性：若 x ⊂ y 且 y ⊂ z 則 x ⊂ z。</li>
<li>不具 connex relation：若 x = {1,2}, y = {3,4}，則 x, y 無法以 ⊂ 表示兩者間的關係。</li>
</ul>
<p>很明顯地，「包含於但不相等」符合 partial order 但不是 total order。我們選擇實作 <code>PartialOrd</code> trait，其有一個 required method <code>PartialOrd::partial_cmp</code>。</p>
<ol>
<li><code>partial_cmp</code> 回傳 <code>Option&lt;Ordering&gt;</code>，因為兩個集合可能無交集，導致無法相互比較。</li>
<li>先檢查 <code>other</code> 是不是子集，再檢查是不是長度相同，得到兩個 <code>bool</code>。</li>
<li>有了上述兩個 <code>bool</code>，就可以用 pattern matching 把所有情況列舉出來。
<ul>
<li>是子集且同長度：相等 <code>=</code>。</li>
<li>是子集但長度不同：包含於 ⊂（<code>&lt;</code>）。</li>
<li>不是子集但長度相同：不相交（disjoint）。</li>
<li>不是子集且長度不同：先假設 self 是 other 的超集，再透過 <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.filter"><code>Option::filter</code></a> 過濾，是超集則回傳 <code>Some(Ordering::Greater)</code>，不是則回傳 <code>None</code>。</li>
</ul>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; PartialOrd for HashSet&lt;T&gt;
where
    T: Hash + Eq,
{
    fn partial_cmp(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; Option&lt;Ordering&gt; { // 1
        let is_subset = self.is_subset(other);                      // 2
        let same_size = self.len() == other.len();
        match (is_subset, same_size) {                              // 3
            (true, true) =&gt; Some(Ordering::Equal),
            (true, false) =&gt; Some(Ordering::Less),
            (false, true) =&gt; None,
            _ =&gt; Some(Ordering::Greater).filter(|_| self.is_superset(other)),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>實作 <code>PartialEq</code>，<code>Eq</code> 與 <code>PartialOrd</code> 後，我們的集合型別終於能和 Python 的集合互別苗頭，有更高層次的表達性！</p>
<blockquote>
<p>有人可能會認為，比較運算還要透過 <code>partial_cmp</code> 判斷 <code>Option</code> 多麻煩，事實上，C++ 20 也帶來了 <code>&lt;=&gt;</code> 運算子以及 <a href="https://en.cppreference.com/w/cpp/language/operator_comparison#Three-way_comparison">three way comparison</a> 衍生的各種型別，partial order 或 parital equal 可說是更精確且必要的比較運算，也是一種趨勢。</p>
</blockquote>
<h2 id="效能"><a class="header" href="#效能">效能</a></h2>
<p>以雜湊表為底層儲存容器的集合，各操作複雜度如下</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Best case</th><th>Worst case</th></tr></thead><tbody>
<tr><td>insert(v)</td><td>$O(1)$~</td><td>$O(n)$</td></tr>
<tr><td>remove(v)</td><td>$O(1)$~</td><td>$O(n)$</td></tr>
<tr><td>contains(v)</td><td>$O(1)$</td><td>$O(n)$</td></tr>
<tr><td>union</td><td>$O(n)$</td><td>$O(n)$</td></tr>
<tr><td>intersection</td><td>$O(n)$</td><td>$O(n)$</td></tr>
<tr><td>difference</td><td>$O(n)$</td><td>$O(n)$</td></tr>
<tr><td>symmetric difference</td><td>$O(n)$</td><td>$O(n)$</td></tr>
</tbody></table>
</div>
<blockquote>
<p>$n$：資料筆數。<br />
$v$：資料值。<br />
<strong>~</strong>：平攤後的複雜度（amortized）。</p>
</blockquote>
<p>操作的時間與空間複雜度，與其底層儲存容器的實作有關，本次集合實作只是對雜湊表的簡單封裝，詳細演算法複雜度可以參考 <a href="../hash_map#%E6%95%88%E8%83%BD">HashMap</a>。</p>
<h2 id="參考資料"><a class="header" href="#參考資料">參考資料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/collections/hash_set/struct.HashSet.html">Rust Documentation: HashSet</a></li>
<li><a href="https://docs.python.org/3/library/stdtypes.html#set">Python 3: Set</a></li>
<li><a href="https://en.wikipedia.org/wiki/Set_theory">Wiki: Set theory</a></li>
<li>Venn diagrams are screenshoot from Wikipedia via public domain.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../collections/hash_map/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../collections/bloom_filter/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../collections/hash_map/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../collections/bloom_filter/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/custom.js"></script>


    </div>
    </body>
</html>
