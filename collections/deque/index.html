<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>雙端佇列 Deque - Rust Algorithm Club</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Learn algorithms and data structures with Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Algorithm Club</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/weihanglo/rust-algorithm-club" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="雙端佇列-deque"><a class="header" href="#雙端佇列-deque">雙端佇列 Deque</a></h1>
<p>雙端佇列（double-ended queue，通常縮寫為 deque）是一般化（generalize）的<a href="../queue">佇列</a>或<a href="../stack">堆疊</a>。比起佇列只能「先進先出 FIFO」，以及堆疊只有「後進先出 LIFO」，雙端佇列可以從最前端或最末端任意方向，在常數時間複雜度內增刪元素，更為方便。</p>
<p>雙端佇列常見用動態陣列或是鏈結串列實作，動態陣列的實作會因空間不夠，需要重新配置記憶體，但通常會支援隨機存取（random access）；鏈結串列的實作版本雖無法隨機存取，相對地增刪元素不需記憶體重配置。</p>
<p>雙端佇列顯著的缺點是：無論以動態陣列或連結串列實作，基本款實作通常無法在 $O(k)$ 時間複雜度的情況下，選定範圍內 k 個元素並取得單一切片（slice）。這肇因於動態陣列的實作通常內部儲存空間經過多次增刪，空間利用會不連續；而用鏈結串列實作者，則因不支援隨機存取而無法達到相應的複雜度。</p>
<blockquote>
<p>本次實作的程式碼置於在 <a href="/doc/rust_algorithm_club/collections/struct.Deque.html"><code>rust_algorithm_club::collections::Deque</code></a> API 文件中。</p>
</blockquote>
<h2 id="架構設計"><a class="header" href="#架構設計">架構設計</a></h2>
<p>雙端佇列有個實作重點：可在<strong>常數時間</strong>從頭尾兩端增刪元素。在資料結構設計上，會儲存分別指向頭尾的兩個指標，長相可能如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Deque {
    head: usize,
    tail: usize,
    storage: SomeStorageType,
}
<span class="boring">}</span></code></pre></pre>
<p>第一直覺肯定是選用<a href="../doubly_linked_list">雙向鏈結串列</a>可以雙向增刪節點的特性，作為解決方案。不過這裡我們採用動態陣列實作，更精確來說，底層儲存容器同樣是有兩個分別指向頭尾的指標的「環形緩衝區（Ring buffer）」。</p>
<h3 id="環形緩衝區"><a class="header" href="#環形緩衝區">環形緩衝區</a></h3>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/Circular_buffer.svg/240px-Circular_buffer.svg.png" alt="" /></p>
<p><a href="https://en.wikipedia.org/wiki/Circular_buffer">環形緩衝區（Ring buffer）</a> 是一個長度大小固定的緩衝區，可以視為頭尾相連的記憶體區塊，上圖雖以環狀呈現，但在計算機架構中儲存方式通常是線性陣列，再搭配指向頭端的 <code>head</code> 與指向尾端的 <code>tail</code> 兩個指標構成。</p>
<p>環形緩衝區有分兩種，一種是有循環的，緩衝區寫滿了就覆蓋尾端舊的資料，另一種是不會循環，緩衝區會放滿的，後者就是本次實作會用到的，以下將來探討：</p>
<ul>
<li>如何表示環形緩衝區為空</li>
<li>如何表示環形緩衝區已滿</li>
<li>環形緩衝區如何增加元素</li>
</ul>
<p>這節以 ASCII chart 表示之。</p>
<ul>
<li><code>h</code>: head</li>
<li><code>t</code>: tail</li>
<li><code>x</code>: no data</li>
<li><code>[number]</code>: has data</li>
</ul>
<p>下面一個容量為 8，尚未有任何元素存入的環形緩衝區，這裡觀察到，若 head 與 tail 指向的儲存單元相同，換句話說<strong>兩者索引值相同，則緩衝區為空</strong>。</p>
<pre><code>scenario: empty buffer

h
t
---------------
x x x x x x x x
---------------
</code></pre>
<p>再來，從頭端增加一個元素，此時 head 指向的儲存單元會存入元素，並且 head 索引加一。</p>
<pre><code>scenario: add one data onto head

t h
---------------
1 x x x x x x x
---------------
</code></pre>
<p>我們再連續加幾個元素，可以觀察到，head 最終指向的儲存單元永遠為空：</p>
<pre><code>scenario: add more data onto head

t   h
---------------
1 2 x x x x x x
---------------

t     h
---------------
1 2 3 x x x x x
---------------

t       h
---------------
1 2 3 4 x x x x
---------------
</code></pre>
<p>再來，我們從尾端增加元素，首先 tail 減一，並在移動過後的 tail 指向的儲存單元放入元素。因為 tail 原本為 0，減一之後為 -1，但索引不該有 -1，所以我們採取類似環繞算術運算（wrapping arithmetic operation）處理<a href="https://en.wikipedia.org/wiki/Integer_overflow">整數溢位</a>，因此 tail 索引從 0 變成 7（總共 8 個儲存單元）。</p>
<pre><code>scenario: add data onto tail

        h     t
---------------
1 2 3 4 x x x 5
---------------

</code></pre>
<blockquote>
<p>日常生活中，環繞算術運算可見於汽車儀錶板或是電錶，9999 轉過頭後會自動變成 0000，可以想像成在萬分位進位了，但我們看不到。上述減一也可以想像二進位退一位，但我們看不到，所以從 <code>0b000</code>（0）變成了 <code>0b111</code>（7）。</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/5/53/Odometer_rollover.jpg" width="300px">
</blockquote>
<p>我們從尾端加更多資料到緩衝區：</p>
<pre><code>scenario: add more data onto tail

        h   t
---------------
1 2 3 4 x x 6 5
---------------

        h t
---------------
1 2 3 4 x 7 6 5 --&gt; full
---------------
</code></pre>
<p>欸，怎麼加到第七個就停了？</p>
<p>由於目前僅探討<strong>不循環</strong>的環形緩衝區，已經規範 <code>head = tail</code> 代表緩衝區為空，如果貿然加上第八個元素，就無法分辨緩衝區是空是滿，恐導致轉盈為空。所以當緩衝區容量減去元素個數為 1 時，換句話說就是當剩餘最後一個空儲存單元時，表示該緩衝區已滿，不能再增加元素。由此推論環形緩衝區永遠會剩下一個沒使用的儲存單元。</p>
<p>至此，環形緩衝區的特性很符合雙端佇列的需求，總結一下：</p>
<ol>
<li><code>head = tail</code> 時，表示緩衝區為空。</li>
<li>容量僅剩一個儲存單元時，表示緩衝區已滿。</li>
<li>head 永遠指向一個空的儲存單元。</li>
<li>邏輯索引的映射會利用環繞算術運算配合<a href="https://en.wikipedia.org/wiki/Modulo_operation">模除運算</a>，將索引值限制在緩衝區範圍內。</li>
</ol>
<p>第四點很難懂齁？免驚，下面實作範例「<a href="#%E9%82%8F%E8%BC%AF%E7%B4%A2%E5%BC%95%E6%98%A0%E5%B0%84">邏輯索引映射</a>」段落就會解釋給你聽！</p>
<h3 id="手動配置記憶體"><a class="header" href="#手動配置記憶體">手動配置記憶體</a></h3>
<p>這一段，我們將為環形緩衝區打造屬於它自己的底層儲存空間。你可能想問，既然環形緩衝區是一個固定長度的陣列，為什麼不直接利用 Rust 標準函式庫的 <code>Vec</code> 呢？因為 <a href="https://doc.rust-lang.org/1.49.0/alloc/vec/struct.Vec.html#capacity-and-reallocation"><code>Vec</code> 的容量和記憶體配置</a>屬於實作細節，雖然目前是滿了才擴充容量重新配置空間，但難保未來改變，為了更細緻控制記憶體，決定弄髒手，自行配置記憶體。</p>
<blockquote>
<p>⚠️ 以下範例有 <code>unsafe</code> 程式碼，未經審計，請謹慎使用。</p>
</blockquote>
<p>首先，宣告一個 <code>RawVec</code> 結構體，儲存了兩個欄位：</p>
<ul>
<li><code>ptr</code>：指向陣列最前端的指標，因為底層陣列會變化，所以是可變裸指標 <a href="https://doc.rust-lang.org/1.49.0/std/primitive.pointer.html"><code>*mut T</code></a>。</li>
<li><code>cap</code>：當前 <code>RawVec</code> 的容量。注意，容量需永遠大於等於元數個數，否則會發生<a href="https://en.wikipedia.org/wiki/Buffer_overflow">緩衝區溢位</a>。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RawVec&lt;T&gt; {
    ptr: *mut T,
    cap: usize,
}
<span class="boring">}</span></code></pre></pre>
<p>接下來，我們要為 <code>RawVec</code> 實作三個方法，完成自我管理記憶體的偉大志向：</p>
<ul>
<li><code>with_capacity</code>：建立指定容量的 <code>RawVec</code>，會在堆疊上配置一塊記憶體。</li>
<li><code>try_grow</code>：嘗試將 <code>RawVec</code> 的容量加倍，會觸發記憶體的重新配置。</li>
<li><code>drop</code>：實作 <a href="https://doc.rust-lang.org/1.49.0/core/ops/trait.Drop.html"><code>Drop</code></a> 特徵，會釋放在堆疊上手動配置的記憶體。</li>
</ul>
<p>先來看 <code>with_capacity</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; RawVec&lt;T&gt; {
    // ...
    pub fn with_capacity(cap: usize) -&gt; Self {
        let layout = Layout::array::&lt;T&gt;(cap).unwrap(); // 1

        // 2
        if layout.size() == 0 {
            // This is safe for zero sized types. However, be careful when facing
            // zero capacity layouts. It must be replaced with an actual pointer
            // before operations such as dereference or read/write.
            let ptr = ptr::NonNull::dangling().as_ptr(); // 3
            Self { ptr, cap: 0 }
        } else {
            // This is safe because it conforms to the [safety contracts][1].
            //
            // [1]: https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-1
            let ptr = unsafe { alloc(layout) }; // 4
            if ptr.is_null() {
                handle_alloc_error(layout);
            }
            Self {
                ptr: ptr.cast(),
                cap,
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>首先，我們先透過 <a href="https://doc.rust-lang.org/1.49.0/alloc/alloc/struct.Layout.html#method.array"><code>Layout::array</code></a> 取得給定長度給定型別的陣列的記憶體佈局，這個佈局包含<a href="https://en.wikipedia.org/wiki/Data_structure_alignment">記憶體對齊</a>（二的倍數的位元組）與佔用記憶體大小等資訊。</li>
<li>再來這個 <code>layout.size()</code> 條件式是因為 <a href="https://doc.rust-lang.org/1.49.0/alloc/alloc/fn.alloc.html"><code>alloc</code></a> 為 <code>unsafe</code> 函式，需遵守其安全條款：<a href="https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-1">不允許配置大小為零的空間</a>。因此，必須判斷實際上需要配置記憶體與否，有兩種情況不需配置：
<ul>
<li><code>T</code> 是 <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">Zero Sized Types（ZSTs）</a>，也就是不需要空間的型別。</li>
<li><code>cap</code> 為零，所以不需要容量。</li>
</ul>
</li>
<li>若記憶體佈局所佔空間大小為零，則配置一個 <a href="https://doc.rust-lang.org/1.49.0/core/ptr/struct.NonNull.html"><code>NonNull</code></a> 的迷途指標。
<ul>
<li>對 ZST 來說，<code>NonNull</code> 是安全的，ZST 的指標算術操作無論如何加減，都會指向原始的指標位址，所以上層可以零成本的抽象操作容器的各種方法，完全不需要配置額外記憶體區塊。</li>
<li>對非 ZST 但容量為零的記憶體佈局來說，<code>NonNull</code> 不會有危害但要非常小心，只有在容量大於 0 且內容有初始化時，才該允許指標算術，否則可能存取到未初始化的記憶體位址，進而引發未定義行為。</li>
</ul>
</li>
<li>很簡單地呼叫 <a href="https://doc.rust-lang.org/1.49.0/alloc/alloc/fn.alloc.html"><code>alloc</code></a> 讓 Rust 全域預設的配置器幹一塊空間資源來。因為 <code>alloc</code> 發生記憶體配置錯誤時會回傳空指標，所以這裡按照官方建議用 <code>handle_alloc_error</code> 捕捉這個行為，防止空指標被當作合法指標使用。</li>
</ol>
<blockquote>
<p>Rust 1.28 導入 <a href="https://doc.rust-lang.org/edition-guide/rust-2018/platform-and-target-support/global-allocators.html">Global allocators</a> 的功能，讓使用者使用 <a href="https://doc.rust-lang.org/1.49.0/std/alloc/trait.GlobalAlloc.html"><code>#[global_allocator]</code></a> 屬性，替標準函式庫註冊全域的記憶體配置器，也因此，上述的 <code>alloc</code>、<code>realloc</code>、<code>dealloc</code> 即將在 <a href="https://github.com/rust-lang/rust/issues/32838">allocator_api</a> 穩定後被取代。</p>
</blockquote>
<p>看完配置記憶體，來看如何手動釋放記憶體。Rust 的 <a href="https://doc.rust-lang.org/1.49.0/core/ops/trait.Drop.html"><code>Drop</code></a> 特徵有 <code>drop()</code> 方法，會在數值不需要時呼叫，類似其他語言的解構函式（destructor）。我們將釋放記憶體的邏輯放在 <code>RawVec::drop</code> 裡面，當 <code>RawVec</code> 不被需要時，就會協助我們釋放手動配置的記憶體。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Drop for RawVec&lt;T&gt; {
    /// Deallocates the underlying memory region by calculating the type layout
    /// and number of elements.
    ///
    /// This only drop the memory block allocated by `RawVec` itself but not
    /// dropping the contents. Callers need to drop the contents by themselves.
    fn drop(&amp;mut self) {
        let layout = Layout::array::&lt;T&gt;(self.cap).unwrap(); // 1
        if layout.size() &gt; 0 {
            // This is safe because it conforms to the [safety contracts][1].
            //
            // [1]: https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-2
            unsafe { dealloc(self.ptr.cast(), layout) }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>實作上，第一步取得當前記憶體佈局，並透過 <a href="https://doc.rust-lang.org/1.49.0/alloc/alloc/fn.dealloc.html"><code>dealloc</code></a> 配合指標來釋放記憶體。當然，ZST 或是容量為零的狀況並沒有配置記憶體，額外判斷無需釋放。</p>
<p>最後，來瞧瞧 <code>try_grow</code>，為了簡化實作，每次呼叫時，記憶體區塊就單純加倍。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; RawVec&lt;T&gt; {
    // ...
    pub fn try_grow(&amp;mut self) {
        if mem::size_of::&lt;T&gt;() == 0 {
            return; // 1
        }

        if self.cap == 0 {
            *self = Self::with_capacity(1); // 2
            return;
        }

        let old_layout = Layout::array::&lt;T&gt;(self.cap).unwrap(); // 3
        let new_cap = self.cap &lt;&lt; 1;
        let new_size = old_layout.size() * new_cap;
        // This is safe because it conforms to the [safety contracts][1].
        //
        // [1]: https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-4
        let ptr = unsafe { realloc(self.ptr.cast(), old_layout, new_size) };
        if ptr.is_null() {
            handle_alloc_error(old_layout);
        }
        // ...Old allocation is unusable and may be released from here at anytime.

        self.ptr = ptr.cast(); // 4
        self.cap = new_cap;
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>ZST 的空間不需加倍，直接返回。</li>
<li>原本空間容量為零的狀況，直接配置容量為一的空間。</li>
<li>準備 <code>realloc</code> 需要的參數：容量超過零的，取得舊的記憶體佈局，並乘上翻倍後的容量，算出新的空間大小。這讓之後呼叫 <code>realloc</code> 時符合其安全條款：合法指標、空間大於零、記憶體佈局為該區塊的舊佈局。</li>
<li>呼叫 <code>realloc</code> 之後，原先記憶體區塊可能被釋放，因此不該繼續用舊指標，此以新指標取代之。</li>
</ol>
<p>終於將手動配置記憶體的邏輯封裝在 <code>RawVec</code> 裡面，外部不需要弄髒手搞記憶體了！</p>
<h3 id="deque"><a class="header" href="#deque"><code>Deque</code></a></h3>
<p>有了 <code>RawVec</code>，現在可以將先前缺失的 <code>SomeStorageType</code> 補上，初始化的方法也異常單純。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Deque&lt;T&gt; {
    tail: usize,
    head: usize,
    ring_buf: RawVec&lt;T&gt;,
}

impl&lt;T&gt; Deque&lt;T&gt; {
    pub fn new() -&gt; Self {
        Self {
            tail: 0,
            head: 0,
            ring_buf: RawVec::with_capacity(DEFAULT_CAPACITY),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>至此，<code>Deque</code> 結構體的佈局設計告一段落，接下來就是各種方法實作。</p>
<h2 id="基本操作"><a class="header" href="#基本操作">基本操作</a></h2>
<p>身為一個雙端佇列，會有以下符合定義的基本操作：</p>
<ul>
<li><code>new</code>：初始化一個容器。</li>
<li><code>push_front</code>：在容器最前端新增一個元素。</li>
<li><code>push_back</code>：在容器最末端新增一個元素。</li>
<li><code>pop_front</code>：移除在容器最前端的元素。</li>
<li><code>pop_back</code>：移除在容器最末端的元素。</li>
</ul>
<p>另外為了提升方便性，也提供了一些方法：</p>
<ul>
<li><code>front</code>：查看容器最前端的元素。</li>
<li><code>back</code>：查看容器最末端的元素。</li>
<li><code>len</code>：檢查容器內的元素數目。</li>
<li><code>is_empty</code>：檢查容器內是否沒有任何元素。</li>
<li><code>iter</code>、<code>iter_mut</code>、<code>into_iter</code>：產生一個疊代容器內所有元素的疊代器。</li>
</ul>
<p>因為需要比較動態精細地控制記憶體，少不了一些內部方法：</p>
<ul>
<li><code>is_full</code>：檢查底層環形緩衝區是否滿載。</li>
<li><code>try_grow</code>：嘗試動態增加底層儲存空間。</li>
<li><code>wrapping_add</code>、<code>wrapping_sub</code>：確保邏輯索引的增減正確映射到底層實際索引位址。</li>
</ul>
<h3 id="邏輯索引映射"><a class="header" href="#邏輯索引映射">邏輯索引映射</a></h3>
<p><a href="#%E7%92%B0%E5%BD%A2%E7%B7%A9%E8%A1%9D%E5%8D%80">前一段</a>提及環形緩衝區可以從頭尾增加元素，這一段來說明「如何封裝環形緩衝區內部的物理索引」，讓外部的邏輯索引可映射到內部已儲存合法數值的緩衝區位址。</p>
<p>再回來看容量為 8 的雙端佇列的例子，已進行一系列操作：</p>
<ol>
<li>push_back 1</li>
<li>push_back 2</li>
<li>push_back 3</li>
<li>push_back 4</li>
<li>push_front 5</li>
<li>push_front 6</li>
</ol>
<pre><code>        h   t
---------------
1 2 3 4 x x 6 5
---------------
</code></pre>
<p>如果我們要按照順序，從佇列的 tail 到 head 印出所有元素，應該從 tail 開始，逐一增加索引，依序 6 5 1 2 3 4 印出，我們畫上虛擬的元素對應位置：</p>
<pre><code>~: virtual element

        h   t --&gt;
-----------------------
1 2 3 4 x x 6 5 1 2 3 4
-----------------------
                ~ ~ ~ ~
</code></pre>
<p>顯而易見，虛擬元素對應的索引是 8、9、10、11，已經超過緩衝區的長度，可以利用<a href="https://en.wikipedia.org/wiki/Modulo_operation">模除運算</a>計算物理索引，將索引固定在一定長度內。目前緩衝區容量為 8，所以將索引全部
模除 8：</p>
<ul>
<li><code>8 % 8 = 0</code>：對應到 [0] 的元素 1</li>
<li><code>9 % 8 = 1</code>：對應到 [1] 的元素 2</li>
<li><code>10 % 8 = 2</code>：對應到 [2] 的元素 3</li>
<li><code>11 % 8 = 3</code>：對應到 [3] 的元素 4</li>
</ul>
<p>模除是直觀的作法，但還有更神奇的思路：位元運算（bitwise arithmetic）。只要拿 7 跟這些索引做 <code>&amp;</code> 位元 AND 運算，也能得到相同結果。</p>
<pre><code>       8        9       10       11 &lt;- Logical

  0b1000   0b1001   0b1010   0b1011
&amp; 0b0111   0b0111   0b0111   0b0111
-----------------------------------
  0b0000   0b0001   0b0010   0b0011
=      0        1        2        3 &lt;- Actual
</code></pre>
<p>這邊使用 7 有其意義：</p>
<ol>
<li>7 是 $2^3 - 1$，剛好 $2^n - 1$ 在是二進位制中全部位元都會是 1 ，任意數與 $2^n - 1$ 做位元 AND 運算，可以得到低位 n 位中有多少 1，同時捨棄大於 n 的位元。這個特性不偏不倚和模除的結果相同。</li>
<li>還記得環形緩衝區有個特性嗎：<strong>容量僅剩一個儲存單元時，表示緩衝區已滿</strong>。若能保證環形緩衝區的容量必為 $2^n$，當緩衝區滿時，元素個數定為 $2^n - 1$，完全符合前一點的特性。</li>
</ol>
<p>綜合以上，只需要保證緩衝區容量是 $2^n$，將邏輯索引映射到實際索引，只要將索引和實際可用容量（$2^n - 1$）做位元 AND 運算即可：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn wrap_index(index: usize, size: usize) -&gt; usize {
    debug_assert!(size.is_power_of_two());
    index &amp; (size - 1)
}
<span class="boring">}</span></code></pre></pre>
<p>接下來，就可以推出 <code>wrapping_add</code> 和 <code>wrapping_sub</code> 這兩支正確增減索引的方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Deque&lt;T&gt; {
    // ...
    fn wrapping_add(&amp;self, index: usize, addend: usize) -&gt; usize {
        wrap_index(index.wrapping_add(addend), self.cap())
    }

    fn wrapping_sub(&amp;self, index: usize, subtrahend: usize) -&gt; usize {
        wrap_index(index.wrapping_sub(subtrahend), self.cap())
    }

    fn cap(&amp;self) -&gt; usize {
        self.ring_buf.cap()
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>上面用環繞算術運算（wrapping arithmetic operation） 可以使開發更方便，例如遇上 index 0 而 subtrahend 1 時，巧妙避開 $0 - 1 = -1$ 但 <code>usize</code> 不能為負的限制，直接環繞回 <code>usize::MAX</code>。</p>
</blockquote>
<p>值得一提的是，在 <code>Deque::cap</code> 這個簡單的封裝上呼叫了 <code>RawVec::cap</code>，這是新增的方法，旨在提供 ZST 一個很大很大的虛擬容量，但同時保證是 2 的次方：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; RawVec&lt;T&gt; {
    // ...
    pub fn cap(&amp;self) -&gt; usize {
        if mem::size_of::&lt;T&gt;() == 0 {
            1usize &lt;&lt; (mem::size_of::&lt;usize&gt;() * 8 - 1)
        } else {
            self.cap
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="動態增加記憶體空間"><a class="header" href="#動態增加記憶體空間">動態增加記憶體空間</a></h3>
<p>前面提及環形緩衝區是長度固定的陣列，但雙端佇列若必須固定長度就太沒路用，直觀作法就是透過加倍 <code>RawVec</code> 容量，再繼續新增元素。這個想法沒錯，但會遇到一個問題：如何確保邏輯索引在記憶體加倍後依然正確映射到實際索引？這裡舉一個實際案例：</p>
<pre><code>Before:
         h   t
[o o o o x x o o]

Resize:
         h   t
[o o o o x x o o | x x x x x x x x]
</code></pre>
<p>同樣一個容量為 8 的佇列，觸發了記憶體重新配置，所以記憶體加倍，無奈今非昔比，現在的邏輯索引 tail 無法映射到實際索引，環形緩衝區的「環」已經斷掉。若我們繼續 <code>push_back</code> 往 head 添加元素，就會覆蓋掉 tail 和後面的元素。</p>
<pre><code>after 4 push_back:

overwritten: ⌀
newly added: _

             t h
[o o o o o o ⌀ ⌀ | x x x x x x x x]
         _ _ _ _
</code></pre>
<p>有鑑於此，需要修正將斷掉的環，最簡單的作法就是將緩衝區首個索引到 head 之前的索引這段記憶體空間，複製到新翻倍的空間上，讓 tail 在 head 前面，合法的記憶體區塊再次變得連續：</p>
<pre><code>Before:
         h   t
[o o o o x x o o]

Resize:
         h   t
[o o o o x x o o | x x x x x x x x]

Copy:
             t           h
[x x x x x x o o | o o o o x x x x]
 _ _ _ _           _ _ _ _
</code></pre>
<p>了解實作的目標後，先定義個容量已滿的方法暖暖身：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn is_full(&amp;self) -&gt; bool {
        self.cap() - self.len() == 1
    }
<span class="boring">}</span></code></pre></pre>
<p>然後是 <code>try_grow</code> 的實作：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn try_grow(&amp;mut self) {
        if self.is_full() {
            let old_cap = self.cap(); // 1
            self.ring_buf.try_grow(); // 2

            // 3
            if self.tail &gt; self.head {
                // The content of ring buffer won't overlapped, so it's safe to
                // call `copy_nonoverlapping`. It's also safe to advance the
                // pointer by `old_cap` since the buffer has been doubled.
                unsafe {
                    let src = self.ptr(); // 4-1
                    let dst = self.ptr().add(old_cap); // 4-2
                    ptr::copy_nonoverlapping(src, dst, self.head);
                }
                self.head += old_cap; // 5
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>將舊的容量存起來，因為當 <code>ring_buf</code> 容量翻倍後，<code>cap()</code> 返回的容量就會翻倍。</li>
<li>呼叫 <code>RawVec::try_grow()</code> 讓容量翻倍。</li>
<li>在 <code>tail</code> 大於 <code>head</code> 時，代表環在翻倍後會不連續，所以需要複製元素。</li>
<li>這裡用 <a href="https://doc.rust-lang.org/1.49.0/std/ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a> 進行位元複製，此函式語義上與 C 的 <a href="https://en.cppreference.com/w/c/string/byte/memcpy"><code>memcpy</code></a> 相同。
<ol>
<li>取得緩衝區首個索引的位址，作為複製的起始位址。</li>
<li>取擴增後部分的首個索引位址，作為複製的目標位址。</li>
<li>實際呼叫 <code>memcpy</code> ，因為 head 永遠比最後一個元素索引多 1，剛好可作為元素數目。</li>
</ol>
</li>
<li>被複製的元素位移了 <code>old_cap</code>，因此更新 <code>head</code> 映射到正確的 <code>head + old_cap</code>。</li>
</ol>
<p>我們完成了動態增加容量的方法的同時，也維持邏輯索引映射的正確性。</p>
<blockquote>
<p>這裡維持索引正確性有稍微簡化，更高效優美的解法請參考標準函式庫 <a href="https://github.com/rust-lang/rust/blob/a118ee2/library/alloc/src/collections/vec_deque/mod.rs#L405-L447"><code>VecDeque::handle_capacity_increase</code></a> 。</p>
</blockquote>
<h3 id="查看元素"><a class="header" href="#查看元素">查看元素</a></h3>
<p>查看首末兩段的元素非常簡單，不過由於涉及底層儲存空間的指標操作，所以需要寫 Unsafe Rust：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        if self.is_empty() {
            return None;
        }
        // This is safe because the offset is wrapped inside valid memory region.
        unsafe { Some(&amp;*self.ptr().add(self.tail)) }
    }

    pub fn back(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        if self.is_empty() {
            return None;
        }
        let head = self.wrapping_sub(self.head, 1);
        // This is safe because the offset is wrapped inside valid memory region.
        unsafe { Some(&amp;*self.ptr().add(head)) }
    }
<span class="boring">}</span></code></pre></pre>
<p>兩個函式都先判斷雙端佇列是否為空，再做指標位移運算，head - 1 是 <code>back</code> 的指標位移量，而 <code>front</code> 就直接回傳 tail 指向的值。其中 <code>&amp;*</code> 是常見的 Rust 模式，可視為<strong>將裸指標「升級」為更安全的引用型別</strong>，步驟如下：</p>
<ol>
<li>解引用裸指標，得到底下的裸數值。</li>
<li>建立一個安全的引用，指向裸數值。</li>
</ol>
<p>這裡再來品嚐 <code>is_empty</code> 和 <code>len</code> 的實作：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn is_empty(&amp;self) -&gt; bool {
        self.len() == 0
    }

    pub fn len(&amp;self) -&gt; usize {
        self.head.wrapping_sub(self.tail) &amp; (self.cap() - 1)
    }
<span class="boring">}</span></code></pre></pre>
<p><code>len</code> 用了環繞算術運算，讓 <code>head - tail</code> 能正確算出兩者的距離，並在用前面提及的「容量 - 1」的 $2^n - 1$ 做位元 AND 運算來捨棄高位。</p>
<h3 id="增刪元素"><a class="header" href="#增刪元素">增刪元素</a></h3>
<p>來看從頭尾刪除元素的 <code>pop_front</code> 和 <code>pop_back</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.is_empty() {
            return None; // 1
        }

        let tail = self.tail;
        self.tail = self.wrapping_add(self.tail, 1); // 2

        // This is safe because the offset is wrapped inside valid memory region.
        unsafe { Some(self.ptr().add(tail).read()) } // 3
    }

    pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.is_empty() {
            return None; // 1
        }

        self.head = self.wrapping_sub(self.head, 1); // 2

        // This is safe because the offset is wrapped inside valid memory region.
        unsafe { Some(self.ptr().add(self.head).read()) } // 3
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>同樣先判斷雙端佇列是否為空。</li>
<li>再來移動到下一個合法的索引上，會是 head - 1 或 tail + 1。</li>
<li>最後是指標位移再讀取，注意，雖然 <a href="https://doc.rust-lang.org/1.49.0/core/ptr/fn.read.html"><code>ptr::read</code></a> 會複製指標指向的值，但可視為所有權轉移到回傳值上了，這是因為倘若原始 <code>src</code> 指向的資料帶有其他指標，那麼繼續使用 <code>src</code> 就可能導致記憶體安全問題。</li>
</ol>
<p>再來看增加元素的 <code>push_front</code> 與 <code>push_back</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn push_front(&amp;mut self, elem: T) {
        self.try_grow(); // 1
        self.tail = self.wrapping_sub(self.tail, 1); // 2

        // This is safe because the offset is wrapped inside valid memory region.
        unsafe { self.ptr().add(self.tail).write(elem) } // 3
    }

    pub fn push_back(&amp;mut self, elem: T) {
        self.try_grow(); // 1
        let head = self.head;
        self.head = self.wrapping_add(self.head, 1); // 2

        // This is safe because the offset is wrapped inside valid memory region.
        unsafe { self.ptr().add(head).write(elem) } // 3
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>同樣先判斷雙端佇列是否為空。</li>
<li>再來移動到下一個合法的索引上，會是 head + 1 或 tail - 1。</li>
<li>最後是指標位移再寫入， <a href="https://doc.rust-lang.org/1.49.0/core/ptr/fn.write.html"><code>ptr::write</code></a> 不會觸發讀取或是 drop 裸指標指向的值，但使用上仍然要確認存取該位址是否合法。</li>
</ol>
<p>以上就是 <code>Deque</code>   基本操作方法，至此，剩下最後一步「<a href="#drop">正確釋放記憶體</a>」，雙端佇列基本款就完成了。</p>
<h2 id="特徵"><a class="header" href="#特徵">特徵</a></h2>
<p>Rust 提供許多特徵（Trait），實作特徵可以讓資料結構更方便，更符合 Rust 社群的寫作慣例。</p>
<h3 id="drop"><a class="header" href="#drop"><code>Drop</code></a></h3>
<p>這是 <code>Deque</code> 最重要的特徵之一，也是完成 <code>Deque</code> 基本款的最後一個必要功能。<code>Drop</code> 會用來釋放儲存在 <code>Deque</code> 裡面元素的資源。實作是將所有元素 <code>pop_back</code> 出來，所有權轉移到 <code>drop</code> 函式內，函式本體執行結束後，就會自動呼叫該元素型別的 <code>drop</code> 並釋放資源。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Drop for Deque&lt;T&gt; {
    fn drop(&amp;mut self) {
        while let Some(_) = self.pop_back() {}
    }
}
<span class="boring">}</span></code></pre></pre>
<p>也許你會問「為什麼不在 <code>Deque.ring_buf</code> 的 <code>RawVec</code> 實作 <code>Drop</code> 來釋放其內容的資源？」主因是權責區分，<code>RawVec</code> 僅負責釋放它自行配置的堆疊記憶體，不清楚內容元素該如何釋放記憶體，例如內容可能是 <a href="https://en.wikipedia.org/wiki/Region-based_memory_management">Region-based memory management</a>，一起釋放效率更高，元素各別 <code>mem::drop</code> 反而拖累效率。</p>
<blockquote>
<p>事實上 <code>Deque::drop</code> 也能更高效，<a href="https://github.com/rust-lang/rust/blob/a118ee2/library/alloc/src/collections/vec_deque/mod.rs#L117-L139"><code>std::colletions::VecDeque::drop</code></a> 就是直接 drop 兩個指向切片（slice）的指標，而非每個元素各自處理，雖然最後可能殊途同歸，視編譯器最佳化程度而定。</p>
</blockquote>
<h3 id="iterator"><a class="header" href="#iterator"><code>Iterator</code></a></h3>
<p>身為容器型別，沒有疊代器簡直不能用，Rust 提供許多疊代器特徵供實作，其中 <a href="https://doc.rust-lang.org/1.49.0/core/iter/trait.Iterator.html"><code>Iterator</code></a> 特徵最為基礎且重要，實作 <code>Iterator</code> 特徵需求一個 <code>next</code> 方法，會不斷回傳下一個元素。任何實作 <code>Iterator</code> 特徵的型別，都可以放入 for 迴圈疊代。</p>
<p>而 Rust 常見的疊代器設計模式包含三個產生疊代器的方法：</p>
<ul>
<li><code>iter()</code>：慣例上回傳會產生不可變引用 <code>&amp;T</code> 的 <code>Iterator</code>。</li>
<li><code>iter_mut()</code>：慣例上回傳會產出可變引用 <code>&amp;mut T</code> 的 <code>Iterator</code>。</li>
<li><code>into_iter()</code>：慣例上回傳吃掉所有權 <code>T</code> 的 <code>Iterator</code> ，通常直接實作 <code>IntoIterator</code> 特徵即可，我們在<a href="#intoiterator">下一段</a>介紹它。</li>
</ul>
<p>實作 <code>Iterator</code> 需要新的結構體，以儲存疊代的內部狀態：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Iter&lt;'a, T&gt; {
    head: usize,
    tail: usize,
    ring_buf: &amp;'a [T],
}

pub struct IterMut&lt;'a, T&gt; {
    head: usize,
    tail: usize,
    ring_buf: &amp;'a mut [T],
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>Iter</code>：由於定位 <code>Deque</code> 中有元素的合法記憶體區域需要 <code>head</code> 和 <code>tail</code>，因此儲存該兩者，並且儲存底層的環形緩衝區的切片引用，方便存取元素。</li>
<li><code>IterMut</code>：同 <code>Iter</code>，但改為儲存可變的切片引用。</li>
</ul>
<p>來看看 <code>Iter</code> 如何實作疊代器：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.tail == self.head {
            return None; // 1
        }
        let tail = self.tail; // 2
        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring_buf.len()); // 3
        self.ring_buf.get(tail) // 4
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>當 tail 等於 head 時，代表環形緩衝區為空，直接回傳 <code>None</code>。</li>
<li>tail 是 <code>Deque</code> 最前端，這裡先將當前的 tail 儲存起來。</li>
<li>再將 Iter 上的 tail 增加 1（不影響原始 Deque），下一次呼叫 <code>next</code> 就會取得下一個元素。</li>
<li>利用第二步儲存的當前 tail，配合 <code>slice::get</code> 直接回傳一個元素。</li>
</ol>
<p>再來處理 <code>IterMut::next</code>，直觀上將 <code>Iter::next</code> 的 <code>self.ring_buf.get(tail)</code> 改成 <code>get_mut</code> 即可。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.tail == self.head {
            return None;
        }
        let tail = self.tail;
        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring_buf.len());
        self.ring_buf.get_mut(tail) // Change to `get_mut`
    }
}
<span class="boring">}</span></code></pre></pre>
<p>欸！居然編譯失敗了，到底為什麼呢？</p>
<pre><code class="language-console">error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements
   --&gt; src/collections/deque/mod.rs:353:23
    |
353 |         self.ring_buf.get_mut(tail)
    |                       ^^^^^^^
    |
note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 347:5...
   --&gt; src/collections/deque/mod.rs:347:5
    |
347 |     fn next(&amp;mut self) -&gt; Option&lt;&amp;'a mut T&gt; {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: ...so that reference does not outlive borrowed content
   --&gt; src/collections/deque/mod.rs:353:9
    |
353 |         self.ring_buf.get_mut(tail)
    |         ^^^^^^^^^^^^^
note: but, the lifetime must be valid for the lifetime `'a` as defined on the impl at 344:6...
   --&gt; src/collections/deque/mod.rs:344:6
    |
344 | impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    |      ^^
note: ...so that the expression is assignable
   --&gt; src/collections/deque/mod.rs:353:9
    |
353 |         self.ring_buf.get_mut(tail)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: expected `Option&lt;&amp;'a mut T&gt;`
               found `Option&lt;&amp;mut T&gt;`
</code></pre>
<p>這個編譯錯誤是因為匿名的 <code>&amp;mut self</code> 和 <code>Self::Item</code> 兩者生命週期不匹配。以下把函式簽名的生命週期展開來看：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn next&lt;'anonymous&gt;(&amp;'anonymous mut self) -&gt; Option&lt;&amp;'a mut T&gt; {
        // ...
        self.ring_buf // &amp;'anonymous [T]
            .get_mut(tail) // Some(&amp;'anonymous mut T)
    }
<span class="boring">}</span></code></pre></pre>
<p>嗯，這不太對，我們知道 Rust 保證「就算 drop 了疊代器本身，產出的元素仍然合法」，產出的元素若為引用絕對<a href="https://users.rust-lang.org/t/iterator-lifetime-error-only-when-using-a-mutable-reference/50460/6">不會是迷途引用</a>，例如下面範例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = iter.next().unwrap();
let b = iter.next().unwrap();
drop(iter);
use_both(a, b);
<span class="boring">}</span></code></pre></pre>
<p>但編譯器只看型別是否正確，並無法檢查執行期間的 <code>&amp;mut self</code> 內部 <code>ring_buf</code> 和 <code>Self::Item</code> 是否活得一樣久，且由於 <code>Iterator::next</code> 函式簽名上沒有對 <code>&amp;mut self</code> 的生命週期做任何限制，因此無法寫出下列這種預期中的生命週期限制（可視為要求 <code>'b</code> 至少活得跟 <code>'a</code> 一樣長）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next&lt;'b: 'a&gt;(&amp;'b mut self) -&gt; Option&lt;Self::Item&gt; {
        // ...omit
    }
}

// error[E0195]: lifetime parameters or bounds on method `next` do not match the trait declaration
//    --&gt; src/collections/deque/mod.rs:347:12
//     |
// 347 |     fn next&lt;'b: 'a&gt;(&amp;'b mut self) -&gt; Option&lt;Self::Item&gt; {
//     |            ^^^^^^^^ lifetimes do not match method in trait
<span class="boring">}</span></code></pre></pre>
<p>當然，我們知道回傳 <code>ring_buf</code> 的 <code>&amp;'a mut T</code> 在生命週期上合法，但編譯器認不出來，所以 unsafe 又要來拯救世界。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.tail == self.head {
            return None;
        }
        let tail = self.tail;
        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring_buf.len());
        // This unsafe block is needed for solving the limitation of Iterator
        // trait: the `&amp;mut self` is bound to an anonymous lifetime which rustc
        // cannot figure out whether it would outlive returning element. Hence
        // the explicit pointer casting is required.
        unsafe {
            let ptr = self.ring_buf as *mut [T]; // 1
            let slice = &amp;mut *ptr; // 2
            slice.get_mut(tail) // 3
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>將 <code>ring_buf</code> 轉換成裸指標，因為裸指標無生命週期，所以 <code>&amp;mut self</code> 給的限制不見了。</li>
<li>再把 <code>ptr</code> 指向的 <code>*mut [T]</code> 裸指標轉換成有生命週期的可變引用 <code>&amp;mut [T]</code> 的切片。藉由 Rust 對回傳型別的自動推斷，此切片的實際型別會是 <code>&amp;'a mut [T]</code>。Got it！這就是我們所要的。</li>
<li>老老實實地呼叫 <code>slice::get_mut</code>，完全正確。</li>
</ol>
<blockquote>
<p>這類 <em>An iterator yields borrowing contents from it<code>self</code></em> 的問題，有個俗名叫做 <em>streaming iterator</em>，可以透過<strong>泛型關聯型別</strong>（generic associated type a.k.a GAT）解決，但目前 GAT 尚未穩定。詳情可參考這篇介紹 <a href="https://lukaskalbertodt.github.io/2018/08/03/solving-the-generalized-streaming-iterator-problem-without-gats.html">GAT 與 streaming iterator workaroud</a> 的文章。</p>
</blockquote>
<blockquote>
<p>欸，或許你有疑惑，<code>Iter::next</code> 不也同樣有生命週期問題嗎，為什麼沒有報錯呢？這是因為<a href="https://doc.rust-lang.org/1.49.0/core/marker/trait.Copy.html#impl-Copy-130">所有 <code>&amp;T</code> 引用都預設實作 Copy 特徵</a>，呼叫 <code>slice::get()</code> 時會<strong>自動複製</strong> <code>ring_buf</code> 的引用，因此沒有生命週期的問題，但 <code>&amp;mut T</code> 並沒有實作 Copy 特徵，才會遇上生命週期不符的編譯錯誤。</p>
</blockquote>
<h3 id="intoiterator"><a class="header" href="#intoiterator"><code>IntoIterator</code></a></h3>
<p>相較於 <code>Interator</code>，<a href="https://doc.rust-lang.org/1.49.0/core/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> 是一個讓容器型別錦上添花的特徵，主要功能是：將一個型別自動轉換為有實作 <code>Iterator</code> 的型別，實作後該型別就可以直接放入 for 迴圈中。</p>
<p>例如下列用法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut d = Deque::new();
d.push_back(1);
d.push_back(2);
d.push_front(3);
d.push_front(4);

for elem in &amp;d {
    println!("{:?}". elem);
}

for elem in &amp;mut d {
    *elem *= *elem;
}
<span class="boring">}</span></code></pre></pre>
<p>實作上分三個：</p>
<ul>
<li><code>impl&lt;T&gt; IntoIterator for Deque&lt;T&gt;</code>：將容器轉換成疊代器，並轉移容器和元素的所有權。</li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a Deque&lt;T&gt;</code>：將容器不可變引用轉換成不可變元素的疊代器。</li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut Deque&lt;T&gt;</code>：將容器可變引用轉換成可變元素的疊代器。</li>
</ul>
<p>先說明後面兩者。以下實作非常簡單，只要根據容器引用可變與否，對應呼叫前一段提及的 <code>Deque::iter</code> 或 <code>Deque::iter_mut</code> 即可，這算是 Rust 容器型別的一貫作法。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T&gt; IntoIterator for &amp;'a Deque&lt;T&gt; {
    type Item = &amp;'a T;
    type IntoIter = Iter&lt;'a, T&gt;;

    fn into_iter(self) -&gt; Self::IntoIter {
        self.iter()
    }
}

impl&lt;'a, T&gt; IntoIterator for &amp;'a mut Deque&lt;T&gt; {
    type Item = &amp;'a mut T;
    type IntoIter = IterMut&lt;'a, T&gt;;

    fn into_iter(self) -&gt; Self::IntoIter {
        self.iter_mut()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>至於 <code>impl&lt;T&gt; IntoIterator for Deque&lt;T&gt;</code> 和 <code>iter</code> 與 <code>iter_mut</code> 不一樣，會吃所有權，所以需要宣告額外的結構體來儲存其內部狀態，並直接實作 <code>IntoIterator</code> 要求的 <code>into_iter</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IntoIter&lt;T&gt;(Deque&lt;T&gt;);

impl&lt;T&gt; IntoIterator for Deque&lt;T&gt; {
    type Item = T;
    type IntoIter = IntoIter&lt;T&gt;;

    fn into_iter(self) -&gt; Self::IntoIter {
        IntoIter(self)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>此疊代方法中，佇列內元素的所有權會轉移，所以不需要跟 <code>Iter</code> 一樣保存切片，可以直接存整個 <code>Deque</code> 作為內部狀態，拿走 <code>Deque</code> 的所有權。</p>
<p>既然掌控 <code>Deque</code> 所有權，實作疊代器就沒有困難了，直接將所有元素 pop 取出即可。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.pop_front()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="index-and-indexmut"><a class="header" href="#index-and-indexmut"><code>Index</code> and <code>IndexMut</code></a></h3>
<p>用索引下標 <code>array[index]</code> 取值的語法常見於各大主流語言，Rust 提供 <a href="https://doc.rust-lang.org/1.49.0/core/ops/trait.Index.html"><code>Index</code></a> 和 <a href="https://doc.rust-lang.org/1.49.0/core/ops/trait.IndexMut.html"><code>IndexMut</code></a> 兩個特徵來實作這個運算子，讓容器型別更符合人體工學。</p>
<p>實作方法是利用<a href="#%E9%82%8F%E8%BC%AF%E7%B4%A2%E5%BC%95%E6%98%A0%E5%B0%84">邏輯索引映射</a> 段落實作的 <code>wrap_index</code> 得出實際索引，再透過指標取值即可。唯一需要注意的是越界存取（out of bound access）可能產生未定義行為，不符合 Rust 對記憶體安全的要求，所以在裸指標存取之前，就要直接 <code>assert!</code> 索引是否在元素數量的安全範圍內，防止越界存取。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Index&lt;usize&gt; for Deque&lt;T&gt; {
    type Output = T;

    fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
        assert!(index &lt; self.len(), "Out of bound");
        let index = self.wrapping_add(self.tail, index);
        // This is safe because the offset is wrapped inside valid memory region.
        unsafe { &amp;*self.ptr().add(index) }
    }
}

impl&lt;T&gt; IndexMut&lt;usize&gt; for Deque&lt;T&gt; {
    fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut T {
        assert!(index &lt; self.len(), "Out of bound");
        let index = self.wrapping_add(self.tail, index);
        // This is safe because the offset is wrapped inside valid memory region.
        unsafe { &amp;mut *self.ptr().add(index) }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="debug"><a class="header" href="#debug"><code>Debug</code></a></h3>
<p>最後，介紹一下 <code>fmt::Formatter</code> 有許多方便的 debug 格式化輸出的方法，例如 <a href="https://doc.rust-lang.org/1.49.0/alloc/fmt/struct.Formatter.html#method.debug_list"><code>debug_list</code></a> 可以丟一個疊代器，會轉化成序列般的輸出格式。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: fmt::Debug&gt; fmt::Debug for Deque&lt;T&gt; {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        f.debug_list().entries(self.iter()).finish()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>當然，如果想要對 <code>RawVec</code> 實作 <code>Debug</code> 特徵，免手寫，可直接用 <code>derive</code> 屬性讓<a href="https://doc.rust-lang.org/stable/book/appendix-03-derivable-traits.html#debug-for-programmer-output">編譯器推導實作</a>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)] // Add this line to derive Debug trait automatically.
struct RawVec&lt;T&gt; {
    ptr: *mut T,
    cap: usize,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="效能"><a class="header" href="#效能">效能</a></h2>
<p>以環形緩衝區為底層儲存容器的雙端序列，各操作複雜度如下:</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Best case</th><th>Worst case</th></tr></thead><tbody>
<tr><td>push_front(v)</td><td>$O(1)$</td><td>$O(1)$~</td></tr>
<tr><td>push_back(v)</td><td>$O(1)$</td><td>$O(1)$~</td></tr>
<tr><td>pop_front(v)</td><td>$O(1)$</td><td>$O(1)$~</td></tr>
<tr><td>pop_back(v)</td><td>$O(1)$</td><td>$O(1)$~</td></tr>
<tr><td>front</td><td>$O(1)$</td><td>$O(1)$</td></tr>
<tr><td>back</td><td>$O(1)$</td><td>$O(1)$</td></tr>
<tr><td>len</td><td>$O(1)$</td><td>$O(1)$</td></tr>
</tbody></table>
</div>
<blockquote>
<p>$n$：資料筆數。<br />
$v$：資料值。<br />
<strong>~</strong>：平攤後的複雜度（amortized）。</p>
</blockquote>
<p>雙端佇列任何操作都是直接對 head 或 tail 的索引讀寫記憶體，複雜度皆為 $O(1)$，不過因為增減元素需要動態調整儲存空間大小，所以這些方法的時間複雜度需要平攤。</p>
<p>空間複雜度則是只用了一個環形緩衝區儲存元素，和幾個欄位儲存 tail、head 還有容量，因此額外空間複雜度只有 $O(1)$。</p>
<h2 id="參考資料"><a class="header" href="#參考資料">參考資料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/collections/vec_deque/struct.VecDeque.html">Rust Documentation: <code>VecDeque</code></a></li>
<li><a href="https://github.com/rust-lang/rust/blob/ff6ee2a/library/alloc/src/raw_vec.rs">Rust <code>RawVec</code> Implementation</a></li>
<li><a href="https://en.wikipedia.org/wiki/Circular_buffer">Wiki: Circular buffer</a></li>
<li>Circular Buffer Image by Cburnett <a href="https://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA-3.0</a> via Wikimedia Commons.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../collections/queue/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../collections/linked_list/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../collections/queue/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../collections/linked_list/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/custom.js"></script>


    </div>
    </body>
</html>
