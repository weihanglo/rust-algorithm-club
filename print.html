<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Algorithm Club</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Learn algorithms and data structures with Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Algorithm Club</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/weihanglo/rust-algorithm-club" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p align="center">
  <img src="logo.svg" alt="logo">
<p>
<h1 id="rust-algorithm-club"><a class="header" href="#rust-algorithm-club">Rust Algorithm Club</a></h1>
<p>歡迎來到 Rust 演算法俱樂部！本專案受 <a href="https://github.com/raywenderlich/swift-algorithm-club">Swift Algorithm Club</a> 啟發，專案中的演算法皆使用 <a href="https://www.rust-lang.org/">Rust 程式語言</a>撰寫說明與實作！您可以在 <a href="https://weihanglo.tw/rust-algorithm-club/">Rust Algorithm Club</a> 一站，依您的意願，挑選有興趣的演算法知識學習；若您夠大膽，推薦您閱讀<a href="https://weihanglo.tw/rust-algorithm-club/doc/rust_algorithm_club/">自動生成的 API 文件</a>，直接單挑程式原始碼。</p>
<p>本專案原始碼放在 <a href="https://github.com/weihanglo/rust-algorithm-club">GitHub</a> 上，非常期待您的貢獻。</p>
<p><a href="https://rust-lang.github.io/edition-guide/rust-2018"><img src="https://img.shields.io/badge/Rust_Edition-2018-green.svg" alt="Rust Edition" /></a>
<a href="https://github.com/weihanglo/rust-algorithm-club/actions?query=workflow%3ACI"><img src="https://github.com/weihanglo/rust-algorithm-club/workflows/CI/badge.svg" alt="Build Status" /></a>
<a href="https://weihanglo.tw/rust-algorithm-club/doc/rust_algorithm_club/"><img src="https://img.shields.io/badge/doc-available-blue.svg" alt="Documentation" /></a></p>
<h2 id="基礎概念"><a class="header" href="#基礎概念">基礎概念</a></h2>
<ul>
<li><a href="concepts/asymptotic-notation">漸進符號 Asymptotic Notation</a></li>
</ul>
<h2 id="演算法"><a class="header" href="#演算法">演算法</a></h2>
<h3 id="搜尋"><a class="header" href="#搜尋">搜尋</a></h3>
<ul>
<li><a href="searching/linear_search">線性搜尋 Linear search</a></li>
<li><a href="searching/binary_search">二元搜尋 Binary search</a></li>
<li><a href="searching/interpolation_search">內插搜尋 Interpolation search</a></li>
<li><a href="searching/exponential_search">指數搜尋 Exponential search</a></li>
</ul>
<h3 id="排序"><a class="header" href="#排序">排序</a></h3>
<p>簡單排序：</p>
<ul>
<li><a href="sorting/insertion_sort">插入排序 Insertion sort</a></li>
<li><a href="sorting/selection_sort">選擇排序 Selection sort</a></li>
<li><a href="sorting/bubble_sort">氣泡排序 Bubble sort</a></li>
<li><a href="sorting/shellsort">希爾排序 Shellsort</a></li>
</ul>
<p>高效排序：</p>
<ul>
<li><a href="sorting/heapsort">堆積排序 Heapsort</a></li>
<li><a href="sorting/quicksort">快速排序 Quicksort</a></li>
<li><a href="sorting/mergesort">合併排序 Mergesort</a></li>
</ul>
<p>混合排序（更高效）：</p>
<ul>
<li>🚧 <a href="sorting/introsort">內省排序 Introsort</a></li>
<li>🚧 <a href="sorting/timsort">自適應的合併排序 Timsort</a></li>
<li>🚧 <a href="sorting/pdqsort">模式消除快速排序 Pdqsort</a></li>
</ul>
<p>特殊排序：</p>
<ul>
<li><a href="sorting/counting_sort">計數排序 Counting sort</a></li>
<li><a href="sorting/bucket_sort">桶排序 Bucket sort</a></li>
<li><a href="sorting/radix_sort">基數排序 Radix sort</a></li>
</ul>
<h2 id="資料結構"><a class="header" href="#資料結構">資料結構</a></h2>
<h3 id="堆疊與佇列"><a class="header" href="#堆疊與佇列">堆疊與佇列</a></h3>
<ul>
<li><a href="collections/stack">堆疊 Stack</a></li>
<li><a href="collections/queue">佇列 Queue</a></li>
<li><a href="collections/deque">雙端佇列 Deque</a></li>
</ul>
<h3 id="鏈結串列"><a class="header" href="#鏈結串列">鏈結串列</a></h3>
<p><a href="collections/linked_list">鏈結串列概述</a></p>
<ul>
<li><a href="collections/singly_linked_list">單向鏈結串列 Singly linked list</a></li>
<li><a href="collections/doubly_linked_list">🚧 雙向鏈結串列 Doubly linked list</a></li>
<li><a href="collections/circular_linked_list">🚧 循環鏈結串列 Circular linked list</a></li>
</ul>
<h3 id="關聯容器"><a class="header" href="#關聯容器">關聯容器</a></h3>
<p><a href="collections/associative-container">關聯容器概述</a></p>
<ul>
<li><a href="collections/hash_map">雜湊表 Hash map</a></li>
<li><a href="collections/ordered_map">🚧 有序映射表 Ordered map</a></li>
<li><a href="collections/multimap">🚧 多重映射表 Multimap</a></li>
<li><a href="collections/set">集合 Set</a></li>
<li><a href="collections/bloom_filter/">布隆過濾器 Bloom filter</a></li>
</ul>
<h3 id="字串處理"><a class="header" href="#字串處理">字串處理</a></h3>
<ul>
<li><a href="hamming_distance">漢明距離 Hamming distance</a></li>
<li><a href="levenshtein_distance">萊文斯坦距離 Levenshtein distance</a></li>
<li><a href="longest_common_substring">🚧 最長共同子字串 Longest common substring</a></li>
</ul>
<h2 id="學習資源"><a class="header" href="#學習資源">學習資源</a></h2>
<p>有許多優秀的網站與學習資源，分享給大家學習演算法。</p>
<ul>
<li><a href="https://visualgo.net/">VisuAlgo</a> - 也許是最好的演算法視覺化專案。</li>
<li><a href="http://bigocheatsheet.com/">Big-O Cheat Sheet</a> - 最全面的 Big O cheat sheet。</li>
<li><a href="http://rosettacode.org">Rosetta Code</a> - 使用各種程式語言，解答上百種不同程式問題。</li>
<li><a href="https://cses.fi/book.html">Competitive Programmer’s Handbook</a> - 讓你更有競爭力。這書本身也很有競爭力。</li>
</ul>
<h2 id="如何貢獻"><a class="header" href="#如何貢獻">如何貢獻</a></h2>
<p>歡迎各式各樣的貢獻，修正錯字也行！開始動手之前，請先閱讀<a href="CONTRIBUTING.html">貢獻指南</a>。</p>
<h2 id="貢獻者"><a class="header" href="#貢獻者">貢獻者</a></h2>
<ul>
<li><a href="https://github.com/weihanglo">@weihanglo</a></li>
<li><a href="https://github.com/choznerol">@choznerol</a></li>
<li><a href="https://github.com/henry40408">@henry40408</a></li>
<li><a href="https://github.com/wiasliaw77210">@wiasliaw77210</a></li>
<li><a href="https://github.com/LebranceBW">@LebranceBW</a></li>
</ul>
<h2 id="授權條款"><a class="header" href="#授權條款">授權條款</a></h2>
<p>本專案分為兩部分授權：</p>
<ul>
<li>程式碼與函式庫依據 <a href="https://github.com/weihanglo/rust-algorithm-club/blob/master/LICENSE">The MIT License (MIT)</a> 授權條款發佈。</li>
<li>文章與相關著作依據 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons 4.0 (CC BY-NC-SA 4.0)</a> 授權條款發佈。</li>
</ul>
<p>Copyright © 2017 - 2021 Weihang Lo</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="漸進符號-asymptotic-notation"><a class="header" href="#漸進符號-asymptotic-notation">漸進符號 Asymptotic Notation</a></h1>
<p>日常生活中，你會如何描述處理事情的效率？</p>
<p>「原來她五分鐘內可以吃掉一頭牛！」</p>
<p>「房間這麼小你還能擺一堆雜物？還不快收拾！」</p>
<p>這些描述方法，著重在處理事情的花費時間，或單位空間內的儲存量。描述演算法的效率也如此，就是「測量演算法的執行成本」，例如這個排序法花了 10 秒鐘跑完兩萬筆資料，或是這個模擬演算法很吃資源需要 32 GB 的記憶體。</p>
<p>然而，在不同的機器規格、環境溫濕度、程式語言、實作方式，以及有沒有放乖乖的變異影響下，相同演算法的執行成本常常不一致。為了消弭這些外部因素，讓分析演算法能夠更科學化。科學家抽絲剝繭，發明一個方法：</p>
<p><strong>「統計演算法內所需操作步驟的數目。」</strong></p>
<p>這是最簡單，最粗淺比較不同演算法效率的作法。</p>
<h2 id="用數學表示演算法效率"><a class="header" href="#用數學表示演算法效率">用數學表示演算法效率</a></h2>
<p>「計算步驟數目」很像中小學的數學題目：某公司有三個能力相異的工程師，有的工程師一天解決一個 bug，有的工程師連續工作後效率大幅滑落。每個工程師的除蟲效率可以畫成「bug 數 - 解決 bug 所需時數」函數，橫軸為待處理的臭蟲數，縱軸為解決臭蟲所需時數，如圖一與表所示。</p>
<div class="table-wrapper"><table><thead><tr><th>時數</th><th>$\log N$</th><th>$N$</th><th>$N \log N$</th></tr></thead><tbody>
<tr><td>$N=5$</td><td>2.236</td><td>5</td><td>8.046</td></tr>
<tr><td>$N=30$</td><td>5.477</td><td>30</td><td>102.036</td></tr>
</tbody></table>
</div>
<p><img src="concepts/asymptotic-notation/fig1.png" alt="Fig. 1" /></p>
<p>不論從圖或表，我們都可以明確看出，當 bug 數目小時，每個工程師耗時差不多；當 bug 數目成長到一定程度時，效率好與效率差的工程師差距就很明顯了。</p>
<p>我們把場景拉回演算法的範疇，再闡明一次。上述的除蟲效率函數關係，可以簡單視為為「輸入資料量 - 運算成本」關係之函數。例如 $f(x)=x^2+3x+6$。當輸入資料量增大時，成本也隨之上升，這個用來描述演算法執行成本與輸入資料量之關係的函數，我們稱之為該演算法的「複雜度」。</p>
<h2 id="何謂漸進符號"><a class="header" href="#何謂漸進符號">何謂漸進符號</a></h2>
<p>了解每個演算法的時間複雜度之後，就能比較何者效率佳。但往往天不從人願，給了我們兩個演算法進行比較。</p>
<p>$$f(x)=\sqrt{\frac{182777}{286}}\pi x^4+5\log_{3}^{26}88x^3-e^{777^{log_2^9}}$$</p>
<p>$$g(x)=3x^6-2x^2$$</p>
<p>「天啊！這樣要怎麼分析執行效率呀！」</p>
<p>為了有統一的加薪標準，我們不能假定產品只會產生特定數量的臭蟲，也不能以單一天的工作表現判定員工能力，我們知道老舊系統有無限多個 bug，因此，優秀的老闆關心的是工程師長期處理「海量臭蟲」，在極限下的<strong>成長趨勢</strong>，這些成長趨勢才是衡量 KPI 的關鍵。再次強調，優秀老闆關心如何榨出是工程師的「極限成長趨勢」，而非一時半刻賣弄學識。</p>
<p>同樣地，有太多因素干擾影響一個演算法的複雜度，假使我們只觀察當輸入資料量 $n$ 接近無窮大時，演算法的成長趨勢為何，就很接近所謂漸進符號（asymptotic notation）的定義。漸進符號 只關心演算法在極限下的漸進行為，不同的演算法可能使用相同的漸進符號表示。</p>
<p>我們比較兩個簡單函數，$f(x) = 10x + 29$ 以及 $g(x) = x^2 + 1$。從圖二可以看出一開始 $g(x)$ 的執行時間比 $f(x)$ 多了不少，但隨著輸入資料量 $n$ 增多，$g(x)$ 的執行時間成長愈來愈快速，最後遠遠大於 $f(x)$。</p>
<p><img src="concepts/asymptotic-notation/fig2.png" alt="Fig. 2" /></p>
<p>若以 $an^2 + bn + c$  表示複雜度，就是當存在一個 $a &gt; 0$ 時，一定會有 $n$ 符合 $an^2 &gt; bn + c$，這個差距隨著 $n$ 越大越明顯，這是因為首項（leading term），也就是帶有最高指數的那一項，隨著 輸入大小改變，執行時間變化幅度較大。因此，可捨去複雜度函數中其他較不重要的次項與常數，留下最大次項，「<strong>透過簡單的函數來表述函數接近極限的行為</strong>」,讓複雜度函數更易理解，這就是「漸進符號」的概念。</p>
<p>這裡介紹常見的幾種漸進符號：</p>
<h3 id="obig-o"><a class="header" href="#obig-o">$O$：Big O</a></h3>
<p>當我們談論演算法複雜度時，通常關心的是演算法「最糟糕的情況下」，「最多」需要執行多久。Big O 就是描述演算法複雜度上界的漸進符號，當一個演算法「實際」的複雜度（或執行成本對輸入資料量函數）為 $f(n)$ 時，欲以 Big O 描述其複雜度上界時，必須滿足以下定義：</p>
<p>$$f(n) = O(g(n)) \colon {\exists k&gt;0\ \exists n_0\ \forall n&gt;n_0\ |f(n)| \leq k \cdot g(n)}$$</p>
<p>假設有一演算法實際複雜度為 $f(n) = 3n + 4$，有一組 $k = 4;\ g(n) = n;\ n_0 = 4$ 滿足</p>
<p>$$\forall n &gt; 4,\ 0 \leq f(n) = 3n + 4 \leq 4n$$</p>
<p>意思是「$f(n)$ 的複雜度上界成長趨勢最終不會超過 $g(n) = 4n$ 」，再代入 $O(g(n))$，可得演算法最差複雜度為 $f(n) = O(n)$，也就是「該演算法的成長趨勢不會比 $g(n)$ 來得快」（見圖三）。</p>
<p><img src="concepts/asymptotic-notation/fig3.png" alt="Fig. 3" /></p>
<p>再多看一個例子，若 $f(n) = 4n^2 + n$ 有一組 $k = 5;\ g(n) = n^2;\ n_0 = 5$ 滿足</p>
<p>$$\forall n &gt; 5,\ 0 \leq f(n) = 4n^2 + n \leq 5n^2$$</p>
<p>則此函數的複雜度為 $f(n) = O(n^2)$。</p>
<blockquote>
<p>注意：也寫作 $f(n) \in O(g(n))$，因為實際上 $O(g(n))$ 是所有可描述演算法成長趨勢，並滿足上述條件的函數之「集合」。</p>
</blockquote>
<h3 id="omegabig-omega"><a class="header" href="#omegabig-omega">$\Omega$：Big Omega</a></h3>
<p>相較於 Big O 描述演算法成長趨勢的上界，Big Omega 則是對應成長趨勢的「下界」，定義如下：</p>
<p>$$f(n) = \Omega(g(n)) \colon {\exists k&gt;0\ \exists n_0\ \forall n&gt;n_0\ |f(n)| \geq k \cdot g(n)}$$</p>
<p>以 $f(n) = 3n + 4$ 為例，有一組 $k = 2;\ g(n) = n;\ n_0 = 0$ 滿足上式，因此這個演算法在輸入資料夠大時，「至少」會達到 $\Omega(n)$ 的複雜度，也就是「該演算法的成長趨勢不會比 $g(n)$ 來得慢」。</p>
<h3 id="thetabig-theta"><a class="header" href="#thetabig-theta">$\Theta$：Big Theta</a></h3>
<p>Big Theta 則是 Big O 與 Big Omega 兩個漸進上下界所夾出的範圍，表示該演算法在輸入資料夠大時，最終的複雜度會成長到這個範圍中。其定義如下：</p>
<p>$$f(n) = \Theta(g(n)) \colon {\exists k_1&gt;0\ \exists k_2&gt;0\ \exists n_0\ \forall n&gt;n_0\ k_1 \cdot g(n) \leq |f(n)| \leq k_2 \cdot g(n)}$$</p>
<p>繼續以 $f(n) = 3n + 4$ 為例，同樣有一組 $k_1 = 1;\ k_2 = 5;\ g(n) = n;\ n_0 = 2$，滿足</p>
<p>$$\forall n \geq 2,\ n \leq f(n) = 3n + 4 \leq 5n$$</p>
<p>可得知，$f(n) = 3n + 4 \in \Theta(n)$，表示「該演算法的成長趨勢與 $g(n) = n$ 相同」（見圖四）。</p>
<p><img src="concepts/asymptotic-notation/fig4.png" alt="Fig. 4" /></p>
<h2 id="常見的複雜度"><a class="header" href="#常見的複雜度">常見的複雜度</a></h2>
<p>看完了讓人昏昏欲睡的數學定義，現在來認識一些常見的複雜度，從最快最有效率，到最慢最拖台錢的通通一起認識。</p>
<ul>
<li>$O(1)$：常數時間，演算法執行時間與資料量毫無瓜葛。例如讀取 array 首個元素。</li>
<li>$O(\log n)$：執行時間隨資料量呈對數比例成長。常見的例子是<a href="concepts/asymptotic-notation/../../searching/binary_search">二元搜索（Binary search）</a>。</li>
<li>$O(n)$：執行時間隨資料量呈線性成長，例如在無序的 array 中尋找特定值。</li>
<li>$O(n \log n)$：執行時間隨資料量呈線性對數成長，常見的<a href="concepts/asymptotic-notation/../../sorting/mergesort">合併排序（Mergesort）</a>的複雜度即如斯。</li>
<li>$O(n^2)$：執行時間隨資料量呈平方成長，例如一些效率不彰的排序法如<a href="concepts/asymptotic-notation/../../sorting/bubble_sort">氣泡排序（Bubble sort）</a>。</li>
<li>$O(n^3)$：執行時間隨資料量呈立方成長，常見例子為 naïve 實作的矩陣乘法。</li>
<li>$O(c^n)$：執行時間隨資料量呈指數成長。</li>
<li>$O(n!)$：執行時間隨資料量呈階乘成長，大部分情況下，這是非常差勁的複雜度。</li>
</ul>
<p>若想一窺各種常見演算法的複雜度，可以參考這個最全面的 <a href="http://bigocheatsheet.com/">Big-O Cheat Sheet</a>，圖表非常精美直觀！</p>
<blockquote>
<p>再次強調，漸進符號也可以代表其他執行成本如記憶體空間，並不一定代表執行時間。</p>
</blockquote>
<!-- -->
<blockquote>
<p>其他的漸進符號還有 little-o、little-omega 等等，有興趣的朋友可以參考文末的資料。</p>
</blockquote>
<h2 id="你可能不適合漸進符號"><a class="header" href="#你可能不適合漸進符號">你可能不適合漸進符號</a></h2>
<p>善用漸進符號，可以讓原本複雜艱澀的實際複雜度，簡化至人類容易理解的簡單數學符號，也讓分析演算法效率更為客觀。但實際上，漸進符號省略了常數項與低次項，僅保留最高次項，這種「漸進行為下」的效能表現，在真實世界中，若輸入資料量不夠大，實際複雜度的低次項係數又比高次項大上許多，很可能這個演算法實際上根本沒辦法使用。</p>
<p>另外，漸進符號僅考慮最差與最佳複雜度，沒有考慮到平均複雜度。舉例來說，<a href="concepts/asymptotic-notation/../../sorting/quicksort">Quicksort</a> 最差複雜度為 $O(n^2)$，乍看之下不是很理想，但這種情況非常稀少；其平均複雜度落在 $O(n \log n)$，且其係數相對較低，額外開銷少，自然成為最熱門的排序法之一。</p>
<p>還有，漸進符號也沒有考慮到不同語言、平台的基礎操作開銷，例如實作排序法時，有些語言「比較」兩個元素的開銷比「置換」來得大，實作上就需要盡量減少置換元素。同樣的，CPU 快取也非常容易忽略，一些快速的搜尋法很可能因為不是<a href="concepts/asymptotic-notation/../../searching/linear_search">線性搜尋</a>，沒辦法充分利用 CPU cache，效能不一定理想。</p>
<p>總之，漸進符號只能告訴你「當輸入資料量夠大時，演算法的複雜度表現如何」，並不總是適用每個情境，端看你怎麼使用他。</p>
<h2 id="參考資料"><a class="header" href="#參考資料">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Time_complexity">Wiki: Time complexity</a></li>
<li><a href="https://en.wikipedia.org/wiki/Big_O_notation">Wiki: Big O notation</a></li>
<li><a href="https://brilliant.org/wiki/big-o-notation/">Brilliant: Big O Notation</a></li>
<li><a href="http://program-lover.blogspot.com/2008/10/complexity-analysis.html">Infinite Loop: Complexity Analysis</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="線性搜尋-linear-search"><a class="header" href="#線性搜尋-linear-search">線性搜尋 Linear Search</a></h1>
<p>線性搜尋，又稱為循序搜尋（sequential search），是一個在序列中找尋目標的方法。正如字面上的意義，線性搜尋會按照順序疊代序列，挨家挨戶比對每個元素與目標值是否相等，若相等則停止疊代，並回傳搜尋所得結果。</p>
<p>線性搜尋乍看之下，是最簡單實作也最 naïve 的實作，效能應該不怎麼好。事實上，在資料量不多時（少於 100 個元素），線性搜尋的效能也不會太差，因為其他搜尋演算法可能需要建立特殊資料結構，就會導致時空間初始開銷暴增，複雜度的常數項成本變大。</p>
<h2 id="效能"><a class="header" href="#效能">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Complexity</th></tr></thead><tbody>
<tr><td>Worst</td><td>$O(n)$</td></tr>
<tr><td>Best</td><td>$O(1)$</td></tr>
<tr><td>Average</td><td>$O(n)$</td></tr>
<tr><td>Worst space</td><td>$O(1)$</td></tr>
</tbody></table>
</div>
<p>若序列中總共有 $n$ 個元素，則線性搜尋最差的狀況為元素不在序列中，就是全部元素都比較一次，共比較 $n - 1$ 次，最差複雜度為  $O(n)$。</p>
<h2 id="實作"><a class="header" href="#實作">實作</a></h2>
<p>線性搜尋就是用一個 for-loop 解決。要注意的是，<code>T</code> 泛型參數至少要實作 <code>PartialEq</code> 才能比較。程式碼中使用了疊代器的 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.enumerate">enumerate</a>，建立一個新疊代器，每次疊代產生疊代次數與對應的值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn linear_search&lt;T&gt;(arr: &amp;[T], target: &amp;T) -&gt; Option&lt;usize&gt;
    where T: PartialEq
{
    for (index, item) in arr.iter().enumerate() {
        if item == target {
            return Some(index);
        }
    }
    None
}
<span class="boring">}</span></code></pre></pre>
<p>事實上，若利用 Rust 內建的 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.position"><code>iterator.position</code></a>，程式碼也許會更簡潔。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn linear_search&lt;T&gt;(arr: &amp;[T], obj: &amp;T) -&gt; Option&lt;usize&gt;
    where T: PartialEq
{
    arr.iter().position(|x| x == obj)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="參考資料-1"><a class="header" href="#參考資料-1">參考資料</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Linear_search">Wiki: Linear search</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二元搜尋-binary-search"><a class="header" href="#二元搜尋-binary-search">二元搜尋 Binary Search</a></h1>
<p>Binary search，又稱對數搜尋（logarithmic search），是一個在已排序的序列中，快速找出特定元素的搜尋演算法。二元搜尋的步驟就像玩猜數字，先猜一個數字，告訴你你的猜測比正確答案大或小，再繼續往對的方向猜，捨棄猜錯的另一半。這樣持續進行好幾次猜測，每猜一次，搜尋範圍就縮小一半，因此稱為「二元」搜尋。</p>
<p>二元搜尋有以下幾個特點：</p>
<ul>
<li>概念簡單，搜尋高效，達到對數執行時間 $O(\log n)$。</li>
<li>不需額外實作資料結構或配置記憶體空間。</li>
<li>只能搜尋<strong>已排序</strong>的序列。</li>
</ul>
<h2 id="步驟"><a class="header" href="#步驟">步驟</a></h2>
<ol>
<li>從序列中間的元素開始，比較其與目標值</li>
<li>若該元素為搜尋目標，則結束搜尋。</li>
<li>若該元素較大或小，則將序列切一半，往較小或較大的一半搜尋。</li>
<li>繼續從一半的序列中間的元素開始，重複步驟一到三，直到欲搜尋的序列為空。</li>
</ol>
<h2 id="說明"><a class="header" href="#說明">說明</a></h2>
<p>這裡有一個排好序的序列，共有 15 個元素，現在要找尋 9 是否在序列中。</p>
<pre><code>                       *
[2, 3, 3, 6, 6, 7, 9, 13, 15, 19, 20, 22, 23, 24, 25]
</code></pre>
<p>首先，先找到中間的元素 15 / 2 ~= 8，第八個元素為 13，比 9 大，因此捨棄第八個元素之後的所有元素。</p>
<pre><code>          *
[2, 3, 3, 6, 6, 7, 9, _, _, _, _, _, _, _, _]
</code></pre>
<p>接下來繼續對半搜尋，8 / 2 = 4，找尋第四個元素來比對，6 比 9 小，，因此捨棄第四個元素前的所有元素。</p>
<pre><code>             *
[_, _, _, 6, 6, 7, 9, _, _, _, _, _, _, _, _]
</code></pre>
<p>對剩下的元素二元搜尋，4 / 2 = 2，並從第四個元素開始計算中點 4 + 2 = 6，取得第六個元素為 7，比 9 小，捨棄 7 之前的元素。</p>
<pre><code>                   *
[_, _, _, _, _, 7, 9, _, _, _, _, _, _, _, _]
</code></pre>
<p>繼續切一半來搜尋，繼續找中間的元素 2 / 2 = 1，並從第六個元素計算索引位置 6 + 1 = 7，查看第七個元素是 9，終於找到了！</p>
<h2 id="效能-1"><a class="header" href="#效能-1">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Complexity</th></tr></thead><tbody>
<tr><td>Worst</td><td>$O(\log n)$</td></tr>
<tr><td>Best</td><td>$O(1)$</td></tr>
<tr><td>Average</td><td>$O(\log n)$</td></tr>
<tr><td>Worst space</td><td>$O(1)$</td></tr>
</tbody></table>
</div>
<p>二元搜尋可以透過分治法（Divide and conquer）遞迴求解，而遞迴的終止條件是序列不能在切兩半。由此可知，二元搜尋的複雜度奠基在要切幾次，子序列長度才會等於 1。設 $n$ 為資料數目，$k$ 為要切幾次才會達成終止條件，可得：</p>
<p>$$ \frac{n}{2^k} = 1 $$</p>
<p>接下來同乘 $2^k$ 並取對數。
$$
\frac{n}{2^k} = 1 \\
\Rightarrow 2^k = n \\
$$</p>
<p>再將左式整理一下，得到 $k$。</p>
<p>$$
\log_2 2^k = log_2 n \\
\Rightarrow k \cdot \log_2 2 = log_2 n \\
\Rightarrow k = log_2 n
$$</p>
<p>於是，我們得到二元搜尋時間複雜度為 $O(k) = O(\log_2 n) = O(\log n)$。</p>
<p>寫這種式子也許不好理解，我們可以把搜尋過程和每個分支寫成樹狀圖，方便觀察。假設一個數列有七個元素 <code>[1, 2, 3, 4, 5, 6, 7]</code>，其二元搜尋所有可能路徑的樹狀圖如下：</p>
<pre><code>          +---+
          | 4 |
          +---+
        /       \
     +---+      +---+
     | 2 |      | 6 |
     +---+      +---+
    /    \      /   \
+---+  +---+  +---+  +---+
| 1 |  | 3 |  | 5 |  | 7 |
+---+  +---+  +---+  +---+
</code></pre>
<p>樹中每一條路徑都代表任意搜尋會經過的步驟，總共有 7 種不同的搜尋路徑，最短路徑僅需要 $\lfloor{\log_2 n} = 3 \rfloor$ 個操作，也就是需要執行「樹高」次的操作。</p>
<h2 id="實作-1"><a class="header" href="#實作-1">實作</a></h2>
<h3 id="函式宣告"><a class="header" href="#函式宣告">函式宣告</a></h3>
<p>二元搜尋概念看似簡單，實際上誤區一堆，不易寫出完全正確的演算法。我們參考 <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.binary_search">Rust slice binary_search</a> 的實作。先來看看函式宣告的簽名（function signature）。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn binary_search&lt;T&gt;(arr: &amp;[T], target: &amp;T) -&gt; Result&lt;usize, usize&gt;
    where T: PartialOrd
<span class="boring">}</span></code></pre></pre>
<p>二元搜尋函式宣告中，回傳值大概是最特別的部分。如果有找到目標元素，<code>Result</code> 會是 <code>Ok(目標索引位置)</code>，如果沒有找到則回傳 <code>Err(目標值若插入後，不會影響序列排序的位置)</code>。<code>Err</code> 回傳值提供了插入點，非常方便。</p>
<p>再來，<code>T</code> 泛型參數需是 <a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a>，這是由於二元搜尋使用排序過後的元素，比起線性搜尋，仍需元素之間相互比較。</p>
<h3 id="函式主體"><a class="header" href="#函式主體">函式主體</a></h3>
<p>市面上常見的實作通常以兩個變數 <code>l</code> 與 <code>r</code> 記錄搜尋範圍的上下界，而我們另闢蹊徑，記錄了</p>
<ul>
<li><code>base</code>：搜尋範圍的下界，</li>
<li><code>size</code>：搜尋範圍的長度。</li>
</ul>
<p>以下是完整實作：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn binary_search&lt;T&gt;(arr: &amp;[T], target: &amp;T) -&gt; Result&lt;usize, usize&gt;
    where T: PartialOrd
{
    let mut size = arr.len();       // 1
    if size == 0 {
        return Err(0);
    }
    let mut base = 0_usize;

    while size &gt; 1 {                // 2
        // mid: [base..size)
        let half = size / 2;        // 2.1
        let mid = base + half;
        if arr[mid] &lt;= *target {    // 2.2
            base = mid
        }
        size -= half;               // 2.3
    }

    if arr[base] == *target {       // 3
        Ok(base)
    } else {
        Err(base + (arr[base] &lt; *target) as usize)
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>第一部分先取得搜尋範圍 <code>size</code> 以及確定下界為 <code>0_usize</code>。這裡同時檢查若序列長度為零，直接回傳 <code>Err(0)</code>，告知呼叫端可直接在 index 0 新增元素。</li>
<li>第二部分就是精髓了，將終止條件設在 <code>size &lt;= 1</code>，以確保迴圈能夠正常結束。
<ol>
<li>先將搜尋範圍對半切，再與下界 <code>base</code> 相加，算出中點。</li>
<li>另中間元素與目標值比較，如果比較小，則移動下界至中點。</li>
<li>將 <code>size</code> 減半，縮小搜尋範圍。</li>
</ol>
</li>
<li>到了第三部分，<code>base</code> 已經是切到長度為一的序列了，若匹配目標值就直接回傳；若否，需要傳可供目標值插入的位置，將 bool 判斷是轉型成 <code>usize</code>，若 <code>arr[base]</code> 比目標值小，則目標值要加到其後 +1 位置，反之則加在其前 -1 位置。</li>
</ol>
<h2 id="常見誤區與解法"><a class="header" href="#常見誤區與解法">常見誤區與解法</a></h2>
<ol>
<li>
<p>只適用已排序序列： 這是使用二元搜尋的前提，千萬不能忽略這重要特性，否則後果絕對大錯特錯。</p>
</li>
<li>
<p>處理重複元素：一般的實作通常是回傳任意符合目標值的索引位置，就算有重複的元素，仍然不可預期。若要回傳特定位置（leftmost 或 rightmost），則需特別處理。</p>
</li>
<li>
<p>整數溢位：部分二元搜尋實作會 以兩個變數儲存搜尋範圍上下界的索引位置，而取中點時千萬不可直接將上下界相加再除二，否則很可能整數溢位（integer overflow）。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mid = (end + start) / 2           // Wrong: integer overflow
let mid = start + (end - start) / 2   // Correct
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>終止條件錯誤：無論如何實作，請將終止條件設為「搜尋範圍為空」，也就是下界大於上界，而不要只比較上下界是否相等。其實搜尋範圍低於一定長度，即可使用線性搜尋替代，避免處理邊界值的麻煩，實務上也幾乎沒有太多效能損失。</p>
</li>
</ol>
<h2 id="變形與衍生"><a class="header" href="#變形與衍生">變形與衍生</a></h2>
<h3 id="interpolation-search"><a class="header" href="#interpolation-search">Interpolation Search</a></h3>
<p><a href="searching/binary_search/../interpolation_search">Interpolation search</a> 改良自二元搜尋，差別在於，二元搜尋選擇中間的元素作為二分點，而 interpolation search 人如其名，以內插法找尋二分點。在資料平均分佈時，比二元搜尋更高效。欲知後續，待下回<a href="searching/binary_search/../interpolation_search">內插搜尋 Interpolation search</a> 分曉。</p>
<h3 id="exponential-search"><a class="header" href="#exponential-search">Exponential Search</a></h3>
<p><a href="searching/binary_search/../exponential_search">Exponential search</a> 是一種特殊的二元搜尋，主要用在搜尋無限、無邊界的已排序序列，由於邊界未知長度就未知，無法以傳統二元搜尋找尋中點。Exponential 顧名思義就是不斷比較在 $2^0$，$2^1$ 直到 $2^n$ 的位置上資料是否比目標值大，若較大，再從該位置執行二元搜尋回頭找。詳情請看<a href="searching/binary_search/../exponential_search">指數搜尋 Exponential search</a>。</p>
<h3 id="binary-insertion-sort"><a class="header" href="#binary-insertion-sort">Binary Insertion Sort</a></h3>
<p>Insertion sort 有一個步驟是在前面已經排完序的資料中，找到適合的地方插入待排序的元素，這部分可透過二元搜尋加快在已排序資料搜尋的速度。詳情請參考 <a href="searching/binary_search/../../sorting/insertion_sort/#binary-insertion-sort">Binary insertion sort</a>。</p>
<h2 id="參考資料-2"><a class="header" href="#參考資料-2">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">Wiki: Binary search algorithm</a></li>
<li><a href="https://www.zhihu.com/question/36132386">知乎：二分查找有几种写法？它们的区别是什么？</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="內插搜尋-interpolation-search"><a class="header" href="#內插搜尋-interpolation-search">內插搜尋 Interpolation Search</a></h1>
<p>內插搜尋 Interpolation search 為<a href="searching/interpolation_search/../binary_search">二元搜尋</a>的變種，差別在於二分點的選擇方法，二元搜尋選擇中間的元素作為二分點，而內插搜尋則名副其實，以內插法找尋二分點。內插法有許多種類，本次搜尋演算法選擇使用常見的<a href="https://en.wikipedia.org/wiki/Linear_interpolation">線性內插（linear interpolation）</a>實作。</p>
<p>內插搜尋的特色如下：</p>
<ul>
<li>資料需要是可計算<a href="https://en.wikipedia.org/wiki/Interpolation">內插（interpolation）</a>的數值資料。</li>
<li>對資料分佈敏感，資料均勻分佈時，效能勝過二元搜尋。</li>
<li>資料分佈不均勻時，最差複雜度高達 $O(n)$。</li>
</ul>
<h2 id="步驟-1"><a class="header" href="#步驟-1">步驟</a></h2>
<ol>
<li>確認資料已經排好序。</li>
<li>利用第一個元素 a 與最後的元素 b，以及搜尋上下界 hi 與 lo 位置，作為兩個端點。</li>
<li>利用上述兩點 (lo, a) 與 (hi, b)，對搜尋目標計算內插，得到可能的位置。
<ol>
<li>若該位置上元素較小，則令其為新搜尋下界 a’，重複步驟二到三，繼續求內插。</li>
<li>若該位置上元素較大，則令其為新搜尋上界 b’，重複步驟二到三，繼續求內插。</li>
<li>若相等，則完成搜尋。</li>
</ol>
</li>
<li>搜尋停止在 a’、b’ 兩元素搜尋位置重疊，以及目標值比下界 a’ 小或比上界 b’ 大。</li>
</ol>
<h2 id="說明-1"><a class="header" href="#說明-1">說明</a></h2>
<p>迅速說明線性內插法。線性內插法是中學必修的數學概念，給定兩點 $(x_0,y_0)$ 與 $(x_1,y_1)$，欲求在 $[x_0,x_1]$ 區間內直線上 $x’$ 點的 y 值，可以透過斜率公式求解：</p>
<p>$$
\frac{y - y_0}{x’ - x_0} = \frac{y_1 - y_0}{x_1 - x_0 }
$$</p>
<p>接下來就是小學解方程式的事兒了。</p>
<div style="text-align: center">
<img style="width: 400px" src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/aa/Linear_interpolation_visualisation.svg/512px-Linear_interpolation_visualisation.svg.png" />
<p><i>Cmglee - CC BY-SA 3.0</i></p>
</div>
<p>回到正題，以下用文字解釋內插搜尋。</p>
<p>這裡有一個已排序有 14 個元素的序列，我們需要從中找出 <strong>27</strong>。</p>
<pre><code>[1, 9, 10, 15, 17, 17, 18, 23, 27, 28, 29, 30, 31, 34]
</code></pre>
<p>我們將序列索引當作 x 軸，元素值作為 y 軸。可得已知兩點為 $(0, 1)$ 及 $(13, 34)$。</p>
<p>首先，透過斜率公式，計算出在 $y = 27$ 時，$x’$，也就是 27 在序列中可能的位置為</p>
<p>$$x’ = \lfloor 27 / (34 - 1) \cdot (13 - 0) \rfloor = 10$$</p>
<p>查看 <code>arr[10]</code> 為 29，比搜尋目標 27 來得大。將 29 當作我們新的上界，搜尋範變成第 [0, 9] 個元素（29 不需列入搜尋），繼續計算內插</p>
<p>$$x’ = \lfloor 27 / (28 - 1) \cdot (9 - 0) \rfloor = 9$$</p>
<p>查看 <code>arr[9]</code> 為 28，比搜尋目標 27 來得大。將 28 當作我們新的上界，搜尋範變成第 [0, 8] 個元素（28 不需列入搜尋），繼續計算內插</p>
<p>$$x’ = \lfloor 27 / (27 - 1) \cdot (8 - 0) \rfloor = 8$$</p>
<p>查看 <code>arr[8]</code> 為 27，恰恰是搜尋目標 27，搜尋到此結束。</p>
<h2 id="效能-2"><a class="header" href="#效能-2">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Complexity</th></tr></thead><tbody>
<tr><td>Worst</td><td>$O(n)$</td></tr>
<tr><td>Best</td><td>$O(1)$</td></tr>
<tr><td>Average</td><td>$O(n)$</td></tr>
<tr><td>Average</td><td>$O(\log \log n)$ on uniform distributed data</td></tr>
<tr><td>Worst space</td><td>$O(1)$</td></tr>
</tbody></table>
</div>
<blockquote>
<p>$n$：資料筆數</p>
</blockquote>
<p>線性內差搜尋的最差時間複雜度為 $O(n)$，也就是每次內差的結果都落在邊界旁，搜尋範圍只縮小一個元素。這種情況容易發生在資料依排序呈指數或對數等非線性函數。例如 $y = 2^x$。</p>
<p>線性內插搜尋對資料的期望是均勻機率分佈（uniform probability distribution）。想求平均時間複雜度 $O(\log \log n)$ ，須先透過機率密度函數，計算條件機率，一步步縮小範圍，求得平均誤差，最後求得期望值。這部分計算較為複雜，有興趣的朋友可以參考閱讀資料「<a href="http://www.cs.technion.ac.il/~itai/publications/Algorithms/p550-perl.pdf">Perl, Y., Itai, A., &amp; Avni, H. (1978). Interpolation search—a log log N search.</a>」。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/96/Uniform_Distribution_PDF_SVG.svg/320px-Uniform_Distribution_PDF_SVG.svg.png" alt="" /></p>
<p><em>PDF of uniform distribution by IkamusumeFan - CC BY-SA 3.0</em></p>
<h2 id="實作-2"><a class="header" href="#實作-2">實作</a></h2>
<p>內插搜尋的實作共分為幾部分：</p>
<ol>
<li>處理空序列狀況。</li>
<li>建立迴圈疊代共用的變數。</li>
<li>計算線性插值的主要迴圈。</li>
<li>將內插值映射到結果的 <code>Result</code>。</li>
</ol>
<p>首先是函式宣告。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn interpolation_search(
    arr: &amp;[i32],
    target: &amp;i32,
) -&gt; Result&lt;usize, usize&gt;
<span class="boring">}</span></code></pre></pre>
<p>映入眼簾的是 <code>i32</code>，而非泛型參數，為什麼呢？是因為內插搜尋為了計算線性內插，資料僅限定在「數值資料」，而 Rust 並沒有特別一類 <strong>Numeric</strong> 的型別，自己透過 trait 實作又異常繁瑣，因此先以 <code>i32</code> 代替。而回傳值的部分，與指數搜尋／二元搜尋一模一樣，回傳的 <code>Result</code></p>
<ul>
<li>若為 <code>Ok</code>，其值代表目標值在序列內的索引位置；</li>
<li>若為 <code>Err</code>，則是可以將目標值插入序列內又不會破壞排序的位置。</li>
</ul>
<blockquote>
<p>延續數值型別的話題，Rust 社群提供 <a href="https://github.com/rust-num/num">num</a> crate，定義了各種數值型別與 trait，大整數、複數、虛數、有理數都囊括其中，非常有趣。</p>
</blockquote>
<p>再來就是第一第二部分，處理空序列與建立共用變數，非常直觀。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    if arr.is_empty() {
        return Err(0)
    }

    let mut hi = arr.len() - 1;
    let mut lo = 0_usize;

    let mut interpolant = 0_usize;
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>hi</code>、<code>lo</code> 兩個變數劃定的搜尋範圍上下界。</li>
<li><code>interpolant</code> 儲存線性插值，代表每次疊代的搜尋位置。</li>
</ul>
<p>接下來就是主要的迴圈，負責疊代計算內插值。分為三個部分，直接看程式碼先。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    loop {
        let lo_val = arr[lo];
        let hi_val = arr[hi];

        // 1.
        if hi &lt;= lo || *target &lt; lo_val || *target &gt; hi_val {
            break
        }

        // 2. The linear interpolation part
        let offset = (*target - lo_val) * (hi - lo) as i32 / (hi_val - lo_val);
        interpolant = lo + offset as usize;

        let mid_val = arr[interpolant];

        // 3.
        if mid_val &gt; *target {
            hi = interpolant - 1;
        } else if mid_val &lt; *target {
            lo = interpolant + 1;
        } else {
            break
        }
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>迴圈的三個終止條件，分別為：
<ul>
<li><code>hi</code>、<code>lo</code> 兩個變數劃定的搜尋範圍重疊，長度為零。</li>
<li>搜尋目標值比上界還大。</li>
<li>搜尋目標值比下界還小。</li>
</ul>
</li>
<li>線性內插的計算方程式，要注意我們是寫 Rust 不是 JavaScript，<code>i32</code> 與 <code>usize</code> 不能混用，要手動轉型。</li>
<li>比較插值與目標值。相等則跳出迴圈；若目標大於小於插值，則縮小搜尋範圍。注意，範圍需手動加減一，排除上下界，以免無限迴圈產生。</li>
</ol>
<p>最後一部分則是決定線性插值所得的索引位置是否為目標值，並將該值映射到 <code>Result</code> 上。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    if *target &gt; arr[hi] {
        Err(hi + 1)
    } else if *target &lt; arr[lo] {
        Err(lo)
    } else {
        Ok(interpolant)
    }
<span class="boring">}</span></code></pre></pre>
<p>完整的程式碼如下。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn interpolation_search(
    arr: &amp;[i32],
    target: &amp;i32,
) -&gt; Result&lt;usize, usize&gt; {
    // 1. Handle empty sequence.
    if arr.is_empty() {
        return Err(0)
    }

    // 2. Setup variable storing iteration informaion.
    let mut hi = arr.len() - 1;
    let mut lo = 0_usize;

    let mut interpolant = 0_usize;

    // 3. Main loop to calculate the interpolant.
    loop {
        let lo_val = arr[lo];
        let hi_val = arr[hi];

        // 3.1. Three condition to exit the loop
        if hi &lt;= lo || *target &lt; lo_val || *target &gt; hi_val {
            break
        }

        // 3.2. The linear interpolation part
        let offset = (*target - lo_val) * (hi - lo) as i32 / (hi_val - lo_val);
        interpolant = lo + offset as usize;

        let mid_val = arr[interpolant];

        // 3.3. Comparison between the interpolant and targert value.
        if mid_val &gt; *target {
            hi = interpolant - 1;
        } else if mid_val &lt; *target {
            lo = interpolant + 1;
        } else {
            break
        }
    }

    // 4. Determine whether the returning interpolant are equal to target value.
    if *target &gt; arr[hi] {
        Err(hi + 1)
    } else if *target &lt; arr[lo] {
        Err(lo)
    } else {
        Ok(interpolant)
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>如同<a href="searching/interpolation_search/../binary_search">二元搜尋</a>與<a href="searching/interpolation_search/../exponential_search">指數搜尋
</a>，未特別處理重複元素的內插搜尋，並無法預期會選擇哪一個元素。</p>
</blockquote>
<h2 id="變形與衍生-1"><a class="header" href="#變形與衍生-1">變形與衍生</a></h2>
<h3 id="interpolation-search-tree"><a class="header" href="#interpolation-search-tree">Interpolation Search Tree</a></h3>
<p>Interpolation search tree（IST），姑且稱它「內插搜尋樹」，是一個將內插搜尋結合樹的資料結構。如上述提及，內插搜尋達到 $O(\log \log n)$ 的搜尋時間，但僅適用於均勻機率分佈的資料。而 IST 利用動態內插搜尋，讓 1）內插搜尋樹的搜尋可以使用在更多元的<strong>規律機率分佈</strong>的資料中，且 2）可以達到以下的執行效能：</p>
<ul>
<li>$O(n)$ 空間複雜度。</li>
<li>預期有 $O(\log \log n)$ 的平攤增減節點操作時間，最差有 $(O \log n)$。</li>
<li>在規律分佈的資料中，預期搜尋時間為 $O(\log \log n)$，最差時間複雜度則為 $O((\log n)^2)$</li>
<li>線性時間的循序存取，而取得前後節點或最小值都是常數時間。</li>
</ul>
<p>更多詳細證明可以閱讀參考資料「<a href="https://people.mpi-inf.mpg.de/~mehlhorn/ftp/DynamicInterpolationSearch.pdf">Andersson, A. (1996, October). Faster deterministic sorting and searching in linear space</a>」。</p>
<h2 id="參考資料-3"><a class="header" href="#參考資料-3">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Interpolation_search">Wiki: Interpolation search</a></li>
<li><a href="http://www.cs.technion.ac.il/~itai/publications/Algorithms/p550-perl.pdf">Perl, Y., Itai, A., &amp; Avni, H. (1978). Interpolation search—a log log N search. Communications of the ACM, 21(7), 550-553.</a></li>
<li><a href="https://people.mpi-inf.mpg.de/~mehlhorn/ftp/DynamicInterpolationSearch.pdf">Andersson, A. (1996, October). Faster deterministic sorting and searching in linear space. In Foundations of Computer Science, 1996. Proceedings., 37th Annual Symposium on (pp. 135-141). IEEE.</a></li>
<li>Linear interpolation visualisation SVG By Cmglee <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>, via Wikimedia Commons.</li>
<li>Probability density function of uniform distribution SVG By IkamusumeFan <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>, via Wikimedia Commons.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="指數搜尋-exponential-search"><a class="header" href="#指數搜尋-exponential-search">指數搜尋 Exponential Search</a></h1>
<p>指數搜尋，又稱為 galloping search，是一種特殊的<a href="searching/exponential_search/../binary_search">二元搜尋</a>，主要用在搜尋無限、無邊界的已排序序列。由於邊界未知長度就未知，無法以傳統二元搜尋來找中點。而 Exponential 顧名思義就是從底數為 2，指數為 0 的索引（$2^0$ ）開始，不斷比較在 $2^1$、$2^2$ 直到 $2^k$ 位置上的值，若比目標值大，則停止指數成長，直接從該位置執行二元搜尋，回頭尋找目標值。</p>
<p>指數搜尋的特點如下：</p>
<ul>
<li>可以搜尋邊界未知的已排序序列。</li>
<li>縮小搜尋範圍，可比 naïve 的二元搜尋效率高些。</li>
<li>若目標值實際位置很靠近序列前端，效率會非常棒。</li>
</ul>
<h2 id="步驟-2"><a class="header" href="#步驟-2">步驟</a></h2>
<p>指數搜尋的步驟只有非常簡單的兩步驟：</p>
<ol>
<li>依照目標值大小，劃出搜尋範圍。</li>
<li>在上述範圍內執行二元搜尋。</li>
</ol>
<p>而劃出搜尋範圍這部分也很直觀：</p>
<ol>
<li>選定一個底數 $k$，通常為 2。</li>
<li>比較 $k^i$ 索引下的值是否比目標值大，$i$ 從零開始。</li>
<li>若較小，指數加一 $k^{i + 1}$ 後繼續重複步驟二比較。</li>
<li>若較大，停止比較，得搜尋範圍為 $k^{i - 1}$ 到 $k^i$。</li>
</ol>
<h2 id="說明-2"><a class="header" href="#說明-2">說明</a></h2>
<p>這裡有個排好序的序列，我們要尋找其中是否有 22 這個數字。</p>
<pre><code>    *
[2, 3, 3, 6, 6, 7, 9, 13, 15, 19, 20, 22, 23, 24, 25]
</code></pre>
<p>首先，先尋找 $2^0 = 1$ 位置上的數字是否超過 22。<code>3 &lt; 22</code>，很明顯沒有。</p>
<pre><code>       *     *            *
[2, 3, 3, 6, 6, 7, 9, 13, 15, 19, 20, 22, 23, 24, 25]
</code></pre>
<p>再來，連續看看</p>
<ul>
<li>$2^1$：<code>3 &lt; 22</code></li>
<li>$2^2$：<code>6 &lt; 22</code></li>
<li>$2^3$：<code>15 &lt; 22</code></li>
</ul>
<p>也都沒有超越 22。</p>
<pre><code>                                                           *
[2, 3, 3, 6, 6, 7, 9, 13, 15, 19, 20, 22, 23, 24, 25]  _,  _
</code></pre>
<p>最後，一口氣將指數加到 4，看看$2^4$ 上的數字是否大於 22。哎呀，$2^4 = 16$，的位置已經超出序列長度，因此取至序列最後一個數字作為比較對象。<code>25 &gt; 22</code>，找到了！</p>
<p>得到搜尋的範圍是 $$2^{4-1} &lt; x &lt; \text{array.length} &lt; 2^{4}$$</p>
<h2 id="效能-3"><a class="header" href="#效能-3">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Complexity</th></tr></thead><tbody>
<tr><td>Worst</td><td>$O(\log i)$</td></tr>
<tr><td>Best</td><td>$O(1)$</td></tr>
<tr><td>Average</td><td>$O(\log i)$</td></tr>
<tr><td>Worst space</td><td>$O(1)$</td></tr>
</tbody></table>
</div>
<blockquote>
<p>$i$：目標值在序列中實際的索引位置。</p>
</blockquote>
<p>指數搜尋的複雜度分為兩部分分析：</p>
<h3 id="劃定搜尋範圍"><a class="header" href="#劃定搜尋範圍">劃定搜尋範圍</a></h3>
<p>設 $i$ 為目標值在序列中實際的索引位置，則搜尋上界，指數增加的操作需執行 $\lceil \log(i) \rceil$ 次，例如匹配目標值的搜尋結果位於序列第 9 個，則指數需增加 $\lceil \log(9) \rceil = 4$ 次，上界才會超過目標值。我們設這部分的複雜度為 $O(log i)$。</p>
<h3 id="執行二元搜尋"><a class="header" href="#執行二元搜尋">執行二元搜尋</a></h3>
<p>第二部分就是二元搜尋，複雜度為 $O(log n)$，$n$ 為搜尋範圍的長度。根據第一部分，可以得知範圍長度為 $2^{\log i} - 2^{\log{i - 1}} = 2^{log{i - 1}}$ 個元素，帶入二元搜尋的複雜度，計算出第二部分的複雜度為 $log (2^{\log{i - 1}}) = \log{(i)} - 1 = O(\log i)$。</p>
<p>最後，將兩部分的複雜度合起來，就是指數搜尋的時間複雜度了。</p>
<p>$$O(\log i) + O(\log i) = 2 O(\log i) = O(\log i)$$</p>
<h2 id="實作-3"><a class="header" href="#實作-3">實作</a></h2>
<p>本次實作有邊界的指數搜尋，主要分為三個部分：</p>
<ol>
<li>處理空序列的狀況。</li>
<li>利用指數，決定搜尋範圍。</li>
<li>執行二元搜尋，並將輸出結果映射回原始序列。</li>
</ol>
<p>話不多說，直接看程式碼。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::searching::binary_search;

pub fn exponential_search&lt;T&gt;(arr: &amp;[T], target: &amp;T) -&gt; Result&lt;usize, usize&gt;
    where T: PartialOrd
{
    // 1. Handle empty scenario.
    let size = arr.len();
    if size == 0 {
        return Err(0);
    }

    // 2. Determine searching boundaries.
    let mut hi = 1_usize; // Upper bound.
    while hi &lt; size &amp;&amp; arr[hi] &lt; *target {
        hi &lt;&lt;= 1;
    }
    let lo = hi &gt;&gt; 1; // Lower bound.

    // 3. Do binary search.
    binary_search(&amp;arr[lo..size.min(hi + 1)], target)
        .map(|index| lo + index)
        .map_err(|index| lo + index)
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>和二元搜尋同，遇到空序列就返回 <code>Err(0)</code> 告知呼叫端可新增資料在位置 0。</li>
<li>決定搜尋上下界，只要 上界不超過序列長度，且 <code>arr[hi]</code> 小於目標值，就讓上界指數成長。這裡用位元左移運算子（bitwise left shift）實作乘以 2。<br />
找到上界後，再將上界除以 2（位元右移），就是下界了。</li>
<li>確定範圍後，利用上下界切序列的 sub slice 作為引數，傳遞給二元搜尋。要注意的是，為了避免 sub slice 超出邊界，上界需在 <code>size</code> 與 <code>hi + 1</code> 之間找最小值。<br />
由於回傳結果的位置是以 sub slice 起始，需加上位移量（下界 <code>lo</code>）才會對應原始 slice 的位置。</li>
</ol>
<blockquote>
<p>由於內部使用<a href="searching/exponential_search/../binary_search">二元搜尋</a>，若該二元搜尋沒有處理重複元素的狀況，指數搜尋連帶無法預期這個行為。</p>
</blockquote>
<h2 id="參考資料-4"><a class="header" href="#參考資料-4">參考資料</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Exponential_search">Wiki: Exponential search</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="插入排序-insertion-sort"><a class="header" href="#插入排序-insertion-sort">插入排序 Insertion Sort</a></h1>
<p>Insertion sort 是最簡單的排序法之一，比起 quicksort 等高效的排序法，對大資料的處理效能較不理想。其演算法是將欲排序元素直接插入正確位置，因而得名。</p>
<p>Insertion sort 基本特性如下：</p>
<ul>
<li>實作簡單易理解。</li>
<li>資料量少時較高效，且比其他 $O(n^2) $ 的排序法高效（selection sort/bubble sort）。</li>
<li><strong>自適應排序</strong>：可根據當前資料排序情形加速排序，資料越接近排序完成，效率越高。</li>
<li><strong>穩定排序</strong>：相同鍵值的元素，排序後相對位置不改變。</li>
<li><strong>原地排序</strong>：不需額外花費儲存空間來排序。</li>
<li><strong>即時演算法</strong>：可處理逐步輸入的資料，不需等資料完全備妥。</li>
</ul>
<h2 id="步驟-3"><a class="header" href="#步驟-3">步驟</a></h2>
<p>將序列分為未排序與部分排序兩個區域。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/32/Insertionsort-before.png" alt="" /></p>
<ol>
<li><strong>取第一個元素</strong>，將該元素視為已排序。</li>
<li><strong>取出下一元素</strong>，該元素將插入序列的部分排序區域。</li>
<li><strong>尋找正確位置</strong>：若部分排序元素比新元素大，則互換位置。並重複步驟 2 - 3，直到部分排序元素小於等於新元素。</li>
<li><strong>插入元素</strong>：將新元素<strong>插入</strong>最後的位置。</li>
<li>重複步驟 2 - 4，直到排序完成。</li>
</ol>
<p>簡而言之，即是每次取一個元素，尋找並插入該元素在部分排序區域的排序位置，再逐步把序列單邊排序完成。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/d/d9/Insertionsort-after.png" alt="" /></p>
<p>Insertion sort 非常簡單，看動畫就能明瞭。
<img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="" /></p>
<h2 id="效能-4"><a class="header" href="#效能-4">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Complexity</th></tr></thead><tbody>
<tr><td>Worst</td><td>$O(n^2) $</td></tr>
<tr><td>Best</td><td>$O(n) $</td></tr>
<tr><td>Average</td><td>$O(n^2) $</td></tr>
<tr><td>Worst space</td><td>$O(1) $ auxiliary</td></tr>
</tbody></table>
</div>
<p>最佳時間複雜度發生在資料已完成排序的狀況下，insertion sort 只需執行最外層的迴圈 $n $ 次。</p>
<p>最差時間複雜度發生在資料完全相反時，insertion sort 每取得一個新元素是，都需將資料插入序列最前面，，因此所需的操作如下（ $c $ 為任意常數）：</p>
<p>$$ c \cdot 1 + c \cdot 2 + c \cdot 3 \cdots + c \cdot (n - 1) = \frac{c(n - 1 + 1)(n - 1)}{2}$$</p>
<p>最後等於</p>
<p>$$\frac{cn^2}{2} - \frac{cn}{2}$$</p>
<p>捨去低次項，得到時間複雜度為 $O(n^2) $。</p>
<h2 id="實作-4"><a class="header" href="#實作-4">實作</a></h2>
<p>簡單實作的程式碼如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn insertion_sort(arr: &amp;mut [i32]) {
    for i in 1..arr.len() {                   // 1
        let mut j = i;
        while j &gt; 0 &amp;&amp; arr[j - 1] &gt; arr[j] {  // 2
            arr.swap(j - 1, j);
            j -= 1;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>外層迴圈疊代整個序列。並取出 index <code>i</code>，<code>arr[i]</code> 是待排序的元素，index 比 <code>i</code> 小的元素則組成已排序的部分序列。</li>
<li>內層迴圈負責元素比較，決定待排序元素該從何處插入，若前一個元素比待排元素大，則置換兩元素，並繼續往下尋找正確的插入點。直到 <code>j == 0</code> 或待排元素比任何已排序元素都大為止。</li>
</ol>
<h2 id="變形"><a class="header" href="#變形">變形</a></h2>
<h3 id="binary-insertion-sort-1"><a class="header" href="#binary-insertion-sort-1">Binary Insertion Sort</a></h3>
<p>在一般演算法討論中，通常以簡單的型別如 <code>i32</code> 來探討並實作。在真實世界中，做哪種操作，用哪種語言，都會影響到實際效能。例如 Python 的比較操作相對於置換元素，成本高出不少，是因為每個物件在 Python 的比較需動態檢查是否實作 <code>__lt__</code> <code>__gt__</code> 等方法才能進行比較。所以 Python 排序法實作就要特別注意減少比較操作的次數。</p>
<p>Binary insertion sort 的目的就是減少內層迴圈的比較次數。在內層迴圈開始之前，使用 <a href="https://en.wikipedia.org/wiki/Binary_search">binary search</a> 搜尋新元素應要插入哪個位置，最多僅需 $\log_2n $ 次比較。但 binary insertion sort 的複雜度依舊是 $O(n^2) $，因為除了比較之外，仍需置換（swap）、賦值（assign）等基礎操作。</p>
<p>Binary insertion sort 的程式碼和一般的 insertion sort 差不了多少，我們這裡使用 <code>slice</code> 內建的 <code>binary_search</code> 來找尋插入點。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn binary_insertion_sort(arr: &amp;mut [i32]) {
    for i in 1..arr.len() {
        let val = arr[i];
        let mut j = i;
        let pos = match arr[..i].binary_search(&amp;val) { // 1
            Ok(pos) =&gt; pos,                            // 2
            Err(pos) =&gt; pos,
        };
        while j &gt; pos {                                // 3
            arr.swap(j - 1, j);
            j -= 1;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>先限制 <code>binary_search</code> 範圍，取出 sorted pile <code>arr[..i]</code>。再對 slice 執行 <code>binary_search</code>。</li>
<li><code>binary_search</code> 回傳一個 <code>Result&lt;usize, usize&gt;</code> 型別，找到時回傳 <code>Ok(index 值)</code>，找無時回傳 <code>Err(不影響排序穩定度的插入點)</code>，這個 <code>Err</code> 的設計巧妙解決新值插入的問題。</li>
<li>和普通 insertion sort 雷同，從插入點至 sorted pile 疊代到末端以進行排序，省下不少比較操作。</li>
</ol>
<h2 id="參考資料-5"><a class="header" href="#參考資料-5">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Insertion_sort">Wiki: Insertion sort</a></li>
<li><a href="https://github.com/python/cpython/blob/15f44ab043b37c064d6891c7864205fed9fb0dd1/Objects/listsort.txt#L686-L703">CPython: listsort note</a></li>
<li>Sorting GIF by Swfung8 (Own work) <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a> via Wikimedia Commons.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="選擇排序-selection-sort"><a class="header" href="#選擇排序-selection-sort">選擇排序 Selection sort</a></h1>
<p>Selection sort 是最易實作的入門排序法之一，會將資料分為 sorted pile 與 unsorted pile，每次從 unsorted pile 尋找最大／最小值，加入 sorted pile 中。</p>
<p>Selection sort 的特性如下：</p>
<ul>
<li>最簡單的排序法之一。</li>
<li>對小資料序列排序效率較高。</li>
<li><strong>不穩定排序</strong>：排序後，相同鍵值的元素相對位置可能改變。</li>
<li><strong>原地排序</strong>：不需額外花費儲存空間來排序。</li>
</ul>
<h2 id="步驟-4"><a class="header" href="#步驟-4">步驟</a></h2>
<ol>
<li>將資料分為 sorted pile 與 unsorted pile。</li>
<li>從 unsorted pile 尋找最小值。</li>
<li>置換該最小值元素與 unsorted pile 第一個元素。</li>
<li>重複步驟 2 - 3，直到排序完成。</li>
</ol>
<blockquote>
<p>注意，這個 naïve 的 selection sort 實作為<strong>不穩定排序</strong>。</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif" alt="" /></p>
<p><em>Joestape89 - CC BY-SA 3.0</em></p>
<h2 id="說明-3"><a class="header" href="#說明-3">說明</a></h2>
<p>為什麼 naïve 的 selection sort 會是不穩定排序？</p>
<p>假定有一個序列要遞增排序，其中有重複的 <code>2</code> 元素，我們將其標上 <code>2a</code>、<code>2b</code> 以利辨識。</p>
<pre><code>[2a, 3, 4, 2b, 1]
</code></pre>
<p>開始疊代找出最小值並指環。</p>
<pre><code class="language-bash"> *             *
[1, 3, 4, 2b, 2a] # 1. 置換 2a, 1

     *     *
[1, 2b, 4, 3, 2a] # 2. 置換 3, 2b

        *       *
[1, 2b, 2a, 3, 4] # 3. 置換 4, 2a
</code></pre>
<p>有沒有發現，<code>2a</code> 與 <code>2b</code> 的相對順序顛倒了呢？</p>
<p>首先，回想一下穩定排序的定義：<strong>相同鍵值的元素，排序後相對位置不改變。</strong></p>
<p>問題出在 naïve selection sort 是以置換的方式排序每次疊代的最小值。若我們將置換（swap）改為插入（insert），那麼 selection sort 就會是穩定排序，但相對地，需要位移剩餘未排序的元素，除非使用 linked list 或其他提供 $O(1) $ insertion 的資料結構，不然就會多出額外 $O(n^2) $ 的寫入成本。</p>
<h2 id="效能-5"><a class="header" href="#效能-5">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Complexity</th></tr></thead><tbody>
<tr><td>Worst</td><td>$O(n^2) $</td></tr>
<tr><td>Best</td><td>$O(n^2) $</td></tr>
<tr><td>Average</td><td>$O(n^2) $</td></tr>
<tr><td>Worst space</td><td>$O(1) $ auxiliary</td></tr>
</tbody></table>
</div>
<p>對於接近排序完成的序列，selector sort 並無法有自適應的方式加快排序疊代。第一個元素要做 $n - 1 $ 次比較，第二個 $n - 2 $ 次，總比較次數如下：</p>
<p>$$ (n -1) + (n-2) + \cdots + 1 = \sum_{i=1}^{n-1} i = \frac{n(n - 1)}{2}$$</p>
<p>因此無論序列是否排序完成，selection sort 仍需執行 $n^2 $ 次比較，時間複雜度為 $O(n^2) $。</p>
<h2 id="實作-5"><a class="header" href="#實作-5">實作</a></h2>
<p>簡單實作如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn selection_sort(arr: &amp;mut [i32]) {
    let len = arr.len();
    for i in 0..len {                     // 1
        let mut temp = i;
        for j in (i + 1)..len {           // 2
            if arr[temp] &gt; arr[j] {
                temp = j;
            }
        }
        arr.swap(i, temp);                // 3
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>外層迴圈負責儲存當前要排序的 index <code>i</code> 的位置。</li>
<li>內層迴圈負責在 unsorted pile 範圍 [<code>i</code>, <code>len</code>) 找最小值。</li>
<li>外層迴圈在找到最小值之後，置換兩元素。</li>
</ol>
<p>眼尖的人會發現，內外兩層迴圈的 upper bound 都是 <code>len</code>，這樣是否內側迴圈會 out of bound？Rust 的 range operator（<code>core::ops::Range</code>）實作 <a href="https://doc.rust-lang.org/core/ops/struct.Range.html#impl-Iterator"><code>Iterator</code></a> trait 時，有檢查 <code>range.start &lt; range.end</code>，因此這個寫法並不會有出界問題，但會多跑一次無意義的疊代。</p>
<h2 id="變形-1"><a class="header" href="#變形-1">變形</a></h2>
<h3 id="heapsort"><a class="header" href="#heapsort">Heapsort</a></h3>
<p><a href="sorting/selection_sort/../heapsort/">Heapsort</a> 是一個高效的排序法，使用 selection sort 融合 <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">heap</a> 這種半排序的資料結構，讓時間複雜度進化至 $O(n \log n) $。更多詳情可以參考<a href="sorting/selection_sort/../heapsort/">這篇介紹</a>。</p>
<h2 id="參考資料-6"><a class="header" href="#參考資料-6">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Selection_sort">Wiki: Selection sort</a></li>
<li><a href="https://stackoverflow.com/questions/20761396/">Why Selection sort can be stable or unstable</a></li>
<li>Sorting GIF by Joestape89 <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA-3.0</a> via Wikimedia Commons.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="氣泡排序-bubble-sort"><a class="header" href="#氣泡排序-bubble-sort">氣泡排序 Bubble sort</a></h1>
<p>Bubble sort 是最簡單的排序法之一，由於排序時每個元素會如同泡泡般，一個一個浮出序列頂部，因而得名。由於其簡單好理解，名稱又有趣，常作為第一個學習的入門排序法。不過其效率不彰，甚至不如同為 quardratic time 的 insertion sort。Bubble sort 的原理很平凡，就是相鄰兩兩元素互相比較，如果大小順序錯了，就置換位置。再往下一個 pair 比較。</p>
<p>Bubble sort 的特性如下：</p>
<ul>
<li>又稱為 <strong>sinking sort</strong>。</li>
<li><strong>穩定排序</strong>：相同鍵值的元素，排序後相對位置不改變。</li>
<li><strong>原地排序</strong>：不需額外花費儲存空間來排序。</li>
</ul>
<h2 id="步驟-5"><a class="header" href="#步驟-5">步驟</a></h2>
<ol>
<li>比較兩個相鄰元素，若首個元素比次個元素大，置換兩者的位置。</li>
<li>依序對相鄰元素執行步驟一，直到抵達序列頂端，此時頂端元素排序完成。</li>
<li>重複步驟 1 - 2 的整個序列疊代，直到任何一次疊代沒有執行元素置換。</li>
</ol>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif" alt="" />
<em>Swfung8 - CC BY-SA 3.0</em></p>
<h2 id="說明-4"><a class="header" href="#說明-4">說明</a></h2>
<p>給定一組序列 <code>[5, 3, 8, 7, 2]</code>，以 bubble sort 遞增排序。以 ASCII diagram 表示：</p>
<p><strong>第一次疊代</strong></p>
<pre><code class="language-bash"> *  *               *  *
[5, 3, 8, 7, 4] -&gt; [3, 5, 8, 7, 4] # 置換 3 與 5

    *  *               *  *
[3, 5, 8, 7, 4] -&gt; [3, 5, 8, 7, 4] # 不需置換

       *  *               *  *
[3, 5, 8, 7, 4] -&gt; [3, 5, 7, 8, 4] # 置換 7 與 8

          *  *               *  *
[3, 5, 7, 8, 4] -&gt; [3, 5, 7, 4, 8] # 置換 4 與 8，8 已排好序
</code></pre>
<p><strong>第二次疊代</strong></p>
<pre><code class="language-bash"> *  *               *  *
[3, 5, 7, 4, 8] -&gt; [3, 5, 7, 4, 8] # 不需置換

    *  *               *  *
[3, 5, 7, 4, 8] -&gt; [3, 5, 7, 4, 8] # 不需置換

       *  *               *  *
[3, 5, 7, 4, 8] -&gt; [3, 5, 4, 7, 8] # 置換 4 與 7

          *  *               *  *
[3, 5, 4, 7, 8] -&gt; [3, 5, 4, 7, 8] # 不需置換
</code></pre>
<blockquote>
<p>naïve bubble sort 會跑完整個序列，即是已排序完成。</p>
</blockquote>
<p><strong>第三次疊代</strong></p>
<pre><code class="language-bash"> *  *               *  *
[3, 5, 4, 7, 8] -&gt; [3, 5, 4, 7, 8] # 不需置換

    *  *               *  *
[3, 5, 4, 7, 8] -&gt; [3, 4, 5, 7, 8] # 置換 4 與 5

       *  *               *  *
[3, 5, 4, 7, 8] -&gt; [3, 4, 5, 7, 8] # 不需置換

          *  *               *  *
[3, 5, 4, 7, 8] -&gt; [3, 4, 5, 7, 8] # 不需置換
</code></pre>
<p><strong>第四次疊代</strong></p>
<pre><code class="language-bash"> *  *               *  *
[3, 4, 5, 7, 8] -&gt; [3, 4, 5, 7, 8] # 不需置換

    *  *               *  *
[3, 4, 5, 7, 8] -&gt; [3, 4, 5, 7, 8] # 不需置換

       *  *               *  *
[3, 4, 5, 7, 8] -&gt; [3, 4, 5, 7, 8] # 不需置換

          *  *               *  *
[3, 4, 5, 7, 8] -&gt; [3, 4, 5, 7, 8] # 不需置換
</code></pre>
<p>很簡單的排序法！</p>
<h2 id="效能-6"><a class="header" href="#效能-6">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Complexity</th></tr></thead><tbody>
<tr><td>Worst</td><td>$O(n^2) $</td></tr>
<tr><td>Best</td><td>$O(n) $</td></tr>
<tr><td>Average</td><td>$O(n^2) $</td></tr>
<tr><td>Worst space</td><td>$O(1) $ auxiliary</td></tr>
</tbody></table>
</div>
<h3 id="time-complexity"><a class="header" href="#time-complexity">Time complexity</a></h3>
<p>Bubble sort 總共需要 $n - 1 $ 次疊代，每次疊代至少需要執行 $n - 1 - i $ 置換（ $i $ 為第幾次疊代），總共需要疊代</p>
<p>$$\sum_{i=0}^{n-1} (n - i - 1) = n^2 - \sum_{i=0}^{n-1}i - n = n^2 - \frac{n(n - 1)}{2} - n = \frac{n^2}{2} - \frac{n}{2}$$</p>
<p>次，因此，時間複雜度為 $O(n^2) $。</p>
<p>Bubble sort 在已排序完成的序列上，只需要疊代序列一次，發現完全沒有置換任何元素，即停止排序，可達到最佳時間複雜度。</p>
<h2 id="實作-6"><a class="header" href="#實作-6">實作</a></h2>
<p>Bubble sort 簡單實作如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn bubble_sort(arr: &amp;mut [i32]) {
    let mut swapped = true;                 // 1
    while swapped {
        swapped = false;
        for i in 1..arr.len() {             // 2
            if arr[i - 1] &gt; arr[i] {
                arr.swap(i - 1, i);
                swapped = true              // 3
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>建立一個旗標，標誌該次疊代是否有元素置換。</li>
<li>內層迴圈依序比較兩兩相鄰元素。</li>
<li>若有任何置換動作，將旗標標誌為「已置換（<code>true</code>）」。</li>
</ol>
<p>倘若記錄已排好序的元素位置，雖然複雜度仍是 $O(n^2) $，但如此以來，每次疊代都可少一次元素比較，對比較操作成本高的語言或實作來說，仍不失為最佳化的方法。程式碼如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn bubble_sort_optimized(arr: &amp;mut [i32]) {
    let mut new_len: usize;
    let mut len = arr.len();            // 1
    loop {
        new_len = 0;
        for i in 1..len {
            if arr[i - 1] &gt; arr[i] {
                arr.swap(i - 1, i);
                new_len = i;            // 2
            }
        }
        if new_len == 0 {               // 3
            break;
        }
        len = new_len;                  // 4
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>將當前的序列長度記錄到 <code>len</code>。</li>
<li>內層迴圈負責比較、置換，以及記錄未排序部分的序列長度到 <code>new_len</code>。</li>
<li>若未排序部分 <code>new_len</code> 為零，代表排序完成。</li>
<li>外層迴圈將新長度值 <code>new_len</code> 賦予 <code>len</code>，下一次疊代就可少做一次比較。</li>
</ol>
<h2 id="參考資料-7"><a class="header" href="#參考資料-7">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Bubble_sort">Wiki: Bubble sort</a></li>
<li>Sorting GIF was created by Swfung8 (Own work) <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a> via Wikimedia Commons.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="希爾排序-shellsort"><a class="header" href="#希爾排序-shellsort">希爾排序 Shellsort</a></h1>
<p>眾所周知，<a href="sorting/shellsort/../insertion_sort">Insertion sort</a> 用在幾乎完成排序的序列上非常高效，換句話說，當元素置換不需移動太遠時，效率很高。反之，如果有元素錯位非常遙遠，效能就會大打折扣。Shellsort 以一個 gap sequence 將資料依指定的間隔（gap）分組進行 insertion sort，使得較遠的元素能夠快速歸位，下一次的排序就會因前次排序結果愈來愈接近完成而加速。</p>
<p>Shellsort 最後一個 gap 必定是 1，也就是排序會退化成 insertion sort，此時大部分元素皆排序完成，insertion sort 會非常高效。</p>
<p>Shellsort 特性如下：</p>
<ul>
<li><strong>自適應排序</strong>：可根據當前資料排序情形加速排序，資料越接近排序完成，效率越高。</li>
<li><strong>不穩定排序</strong>：排序後，相同鍵值的元素相對位置可能改變。</li>
<li><strong>原地排序</strong>：不需額外花費儲存空間來排序。</li>
<li>可視為一般化（Generalizaion）的 <a href="sorting/shellsort/../insertion_sort">insertion sort</a>。</li>
</ul>
<h2 id="步驟-6"><a class="header" href="#步驟-6">步驟</a></h2>
<p>Shellsort 分為兩個步驟：</p>
<ol>
<li>決定一組 gap sequence。</li>
<li>疊代 gap sequence 進行分組排序，每次執行有間隔的 insertion sort。也就是每個元素與其相鄰 gap 的元素比較與置換。</li>
</ol>
<blockquote>
<p>最後一次排序（gap = 1）會退化為 insertion sort，完成整個排序。</p>
</blockquote>
<h3 id="gap-sequneces"><a class="header" href="#gap-sequneces">Gap Sequneces</a></h3>
<p>Shellsort 的效率取決於 gap sequence 的選擇，這邊舉幾個常見的 gap sequence：</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Sequence</th></tr></thead><tbody>
<tr><td>Marcin Ciura</td><td>1, 4, 10, 23, 57, 132, 301, 701</td></tr>
<tr><td>$2^{k} - 1 $</td><td>1, 3, 7, 15, 31, 63,…</td></tr>
<tr><td>$\lfloor {\frac {N}{2^k}} \rfloor $</td><td>$\lfloor {\frac {N}{2}} \rfloor $, $\lfloor {\frac {N}{4}} \rfloor $, …, 1</td></tr>
</tbody></table>
</div>
<p>感受一下 gap sequence 為 23, 10, 4, 1 的 shellsort 吧。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif" alt="" /></p>
<h2 id="說明-5"><a class="header" href="#說明-5">說明</a></h2>
<p>Shellsort 其實就是進行好幾次不同 gap 的 insertion sort，以下用 ASCII diagram 解釋。</p>
<p>假定這裡有一個序列需要遞增排序。</p>
<pre><code>[5, 3, 8, 7, 4, 9, 6, 2]
</code></pre>
<p>我們選擇最簡單的 $\lfloor {\frac {N}{2^k}} \rfloor $ gap sequence 來排序。我們以<strong>星號</strong>標示出每次 insertion sort 對應排序</p>
<p>首先算出第一個 gap 為 $8 / 2^1 = 4 $。開始 insertion sort。</p>
<pre><code> *           *
[5, 3, 8, 7, 4, 9, 6, 2]

-&gt; (sort subsequence [5, 4])

    *           *
[4, 3, 8, 7, 5, 9, 6, 2]

-&gt; (skip)
       *           *
[4, 3, 8, 7, 5, 9, 6, 2]

-&gt; (sort subsequence [8, 6])
          *           *
[4, 3, 6, 7, 5, 9, 8, 2]

-&gt; (sort subsequence [7, 2])

[4, 3, 8, 2, 5, 9, 6, 7]
</code></pre>
<p>再來算出第二個 gap 為 $8 / 2^2 = 2 $。開始 insertion sort。</p>
<pre><code> *     *
[4, 3, 8, 2, 5, 9, 6, 7]

-&gt; (skip)
    *     *
[4, 3, 8, 2, 5, 9, 6, 7]

-&gt; (sort subsequence [3, 2])
 *     *     *
[4, 2, 8, 3, 5, 9, 6, 7]

-&gt; (sort subsequence [4, 8, 5])
    *     *     *
[4, 2, 5, 3, 8, 9, 6, 7]

-&gt; (skip)
 *     *     *     *
[4, 2, 5, 3, 8, 9, 6, 7]

-&gt; (sort subsequence [4, 5, 8, 6])
    *     *     *     *
[4, 2, 5, 3, 6, 9, 8, 7]

-&gt; (sort subsequence [2, 3, 9, 7])
[4, 2, 5, 3, 6, 7, 8, 9]
</code></pre>
<p>再來進行第三次排序。gap 為 $8 / 2^3 = 1 $，shellsort 退化至 insertion sort，但前一次結果已經很接近排序完成，insertion sort 可以幾乎在 one pass 完成排序。</p>
<blockquote>
<p>Insertion sort 的 ASCII diagram 我們就不展示了，請參考 <a href="sorting/shellsort/../insertion_sort">Insertion sort</a>。</p>
</blockquote>
<h2 id="效能-7"><a class="header" href="#效能-7">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Complexity</th></tr></thead><tbody>
<tr><td>Worst</td><td>$O(n^2) $ ~  $O(n \log^2 n) $ (Depends on gap sequence)</td></tr>
<tr><td>Best</td><td>$O(n \log n) $</td></tr>
<tr><td>Average</td><td>Depends on gap sequence</td></tr>
<tr><td>Worst space</td><td>$O(1) $ auxiliary</td></tr>
</tbody></table>
</div>
<p>Shellsort 的複雜度不容易計算，取決於 gap sequence 怎麼安排，太少 gap 會讓速度太接近 insertion sort，太多 gap 則會有過多額外開銷。目前已知的 gap sequence 中，最差時間複雜度可以達到 $O(n \log^2 n) $，有著不錯的表現。有興趣可以參考<a href="http://www.dtic.mil/get-tr-doc/pdf?AD=AD0740110">這篇文章</a>。</p>
<h2 id="實作-7"><a class="header" href="#實作-7">實作</a></h2>
<p>我們這裡以 <a href="http://sun.aei.polsl.pl/~mciura/publikacje/shellsort.pdf">Marcin 的 Paper</a> 中提到的經驗式為例，首先，先建立一個 gap sequence 的常數。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Marcin Ciura's gap sequence.
pub const MARCIN_GAPS: [usize; 8] = [701, 301, 132, 57, 23, 10, 4, 1];
<span class="boring">}</span></code></pre></pre>
<p>再來就是主程式的部分，總共會有三個迴圈，</p>
<ul>
<li>最外層是疊代 gap sequence，</li>
<li>中間層是疊代整個資料序列，</li>
<li>內層就是每個元素的插入排序動作。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Shellsort
pub fn shellsort(arr: &amp;mut [i32]) {
    let len = arr.len();
    for gap in MARCIN_GAPS.iter() {                     // 1
        let mut i = *gap;                               // 4
        while i &lt; len {                                 // 2
            let mut j = i;
            while j &gt;= *gap &amp;&amp; arr[j - gap] &gt; arr[j] {  // 3
                arr.swap(j - *gap, j);
                j -= *gap;
            }
            i += 1;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>最外層的迴圈，利用 <code>iter()</code> trait 產生疊代器，疊代 gap sequence。</li>
<li>中間層迴圈，控制 <code>i</code> 是否超出資料序列，以疊代整合資料序列。</li>
<li>最內層迴圈，執行插入動作，將每個元素置換到正確位置。</li>
<li>由於 <code>gap</code> 的型別是 <code>&amp;usize</code>，需透過 <code>*gap</code> dereference 得到 <code>usize</code> 型別。</li>
</ol>
<h2 id="參考資料-8"><a class="header" href="#參考資料-8">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Shellsort">Wiki: Shellsort</a></li>
<li><a href="http://sun.aei.polsl.pl/~mciura/publikacje/shellsort.pdf">Best Increments for the Average Case of Shellsort, M. Ciura, 2001</a></li>
<li><a href="http://www.dtic.mil/get-tr-doc/pdf?AD=AD0740110">Shellsort and Sorting Networks (Outstanding Dissertations in the Computer Sciences)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="堆積排序-heapsort"><a class="header" href="#堆積排序-heapsort">堆積排序 Heapsort</a></h1>
<p>Heapsort（堆積排序）可以看作是 <a href="sorting/heapsort/../selection_sort">selection sort</a> 的變形，同樣會將資料分為 sorted pile 與 unsorted pile，並在 unsorted pile 中尋找最大值（或最小值），加入 sorted pile 中。</p>
<p>和 selection sort 不同之處是，heapsort 利用<a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">堆積（heap）</a>這種半排序（partially sorted）的資料結構輔助並加速排序。</p>
<p>Heapsort 的特性如下：</p>
<ul>
<li>使用 <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">heap</a> 資料結構輔助，通常使用 <a href="https://en.wikipedia.org/wiki/Binary_heap">binary heap</a>。</li>
<li><strong>不穩定排序</strong>：排序後，相同鍵值的元素相對位置可能改變。</li>
<li><strong>原地排序</strong>：不需額外花費儲存空間來排序。</li>
<li><strong>較差的 CPU 快取</strong>：heap 不連續存取位址的特性，不利於 <a href="https://en.wikipedia.org/wiki/CPU_cache">CPU 快取</a>。</li>
</ul>
<h2 id="步驟-7"><a class="header" href="#步驟-7">步驟</a></h2>
<p>Heapsort 的演算法分為兩大步驟：</p>
<ol>
<li>將資料轉換為 heap 資料結構（遞增排序用 max-heap, 遞減排序選擇 min-heap）。</li>
<li>逐步取出最大／最小值，並與最後一個元素置換。具體步驟如下：
<ol>
<li>交換 heap 的 root 與最後一個 node，縮小 heap 的範圍（排序一筆資料，故 heap 長度 -1）。</li>
<li>更新剩下的資料，使其滿足 heap 的特性，稱為 heap ordering property。</li>
<li>重複前兩個步驟，直到 heap 中剩最後一個未排序的資料。</li>
</ol>
</li>
</ol>
<p>透過 GIF 動畫感受一下 heapsort 的威力吧！</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif" alt="" /></p>
<h2 id="說明-6"><a class="header" href="#說明-6">說明</a></h2>
<p>在開始之前，定義幾個 heap 常用名詞：</p>
<ul>
<li><strong>Heap ordering property</strong>：一個 heap 必須要滿足的條件。以 heap 種類不同有幾種變形。
<ul>
<li><strong>min-heap property</strong>：每個結點皆大於等於其父節點的值，且最小值在 heap root。</li>
<li><strong>max-heap property</strong>：每個結點皆小於等於其父節點的值，且最大值在 heap root。</li>
</ul>
</li>
</ul>
<p>而 heapsort 主要分為兩個部分：</p>
<ol>
<li><strong>Heapify</strong>：將陣列轉換為 heap 資料結構（heapify）。</li>
<li><strong>Sorting</strong>：不斷置換 heap root 與最後一個元素來排序，並修正剩餘未排序資料使其符合 heap order。</li>
</ol>
<p>這裡有一個未排序的序列，將以遞增方向排序之。</p>
<pre><code>[17, 20, 2, 1, 3, 21]
</code></pre>
<p>首先，將資料轉換為 heap 資料結構，這個步驟即時 <strong>heapify</strong>。由於是遞增排序，我們採用 max-heap（最大元素在 root）。</p>
<pre><code>[21, 20, 17, 1, 3, 2]
</code></pre>
<p>對應的二元樹（binary tree）的圖形如下：</p>
<img src="sorting/heapsort/tree.png" height="300px" />
<p>再來就是<strong>排序的部分</strong>，Max-heap 會將最大的元素擺在 root 的位置，我們先將最後一個 node 與 root 進行交換，完成第一個排序步驟。</p>
<blockquote>
<p>若不熟悉 heap，可以閱讀 <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">Wiki 的介紹</a>，其實 heap 就是用陣列實作的二元樹。</p>
</blockquote>
<pre><code>[21, 20, 17, 1, 3, 2]
 *                 *
(swap) --&gt;

        unsorted | sorted
[2, 20, 17, 1, 3 | 21]
</code></pre>
<p>接下來，將未排序的資料區塊重整為符合 max-heap 的結構。</p>
<pre><code>[2, 20, 17, 1, 3 | 21]

(sift down) --&gt;

[20, 3, 17, 1, 2 | 21]
</code></pre>
<p>有沒有看出一些端倪？</p>
<p>只要不斷將 root 和最後一個 node 交換，並將剩餘資料修正至滿足 heap ordering，就完成排序了。</p>
<pre><code>[20, 3, 17, 1, 2 | 21]
 *             *
(swap) --&gt;

[2, 3, 17, 1 | 20, 21]

(sift down)--&gt;

[17, 3, 2, 1 | 20, 21]
 *         *
(swap) --&gt;

[1, 3, 2 | 17, 20, 21]

(sift down)--&gt;

[3, 1, 2 | 17, 20, 21]
 *     *
(swap) --&gt;

[1, 2 | 3, 17, 20, 21]

(Done!)
</code></pre>
<p>以上便是 heapsort 演算法的簡單流程，是不是和 selection sort 非常相似呢！</p>
<h2 id="效能-8"><a class="header" href="#效能-8">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Complexity</th></tr></thead><tbody>
<tr><td>Worst</td><td>$O(n \log n) $</td></tr>
<tr><td>Best</td><td>$O(n \log n) $</td></tr>
<tr><td>Average</td><td>$O(n \log n) $</td></tr>
<tr><td>Worst space</td><td>$O(1) $ auxiliary</td></tr>
</tbody></table>
</div>
<p>Heapsort 最佳、最差、平均的時間複雜度皆為 $O(n \log n) $，同樣分為兩部分簡單解釋。</p>
<h3 id="build-heap-heapify"><a class="header" href="#build-heap-heapify">Build heap (heapify)</a></h3>
<p>建立一個 binary heap 有兩種方法，一種是一個個元素慢慢加入 heap 來建立；另一種則是給定隨意的序列，再透過 heapify 演算法修正序列為有效的 heap。一般來說 heapsort 常用實作後者。</p>
<p><strong>Heapify</strong> 是指將序列修正至符合 heap ordering 的序列。給定一個元素，假定其為非法的 heap order，而該元素之後的 subtree 視為符合 heap ordering property。欲修正這個在錯誤位置的元素，必須透過與其 children node 置換往下篩，這個往下篩的過程就稱為 <strong>sift down</strong>，在<a href="sorting/heapsort/index.html#%E5%AF%A6%E4%BD%9C">實作</a>一節會詳細解釋，這邊只要知道 sift down 會不斷將該元素與其 child node 比較，若不符合 heap order 則與 child node 置換，並繼續疊代每一個 level。所以 sift down 的時間複雜度為 $O(\lceil {\log_2(n)} \rceil) = O(\log n) $， $n $ 為陣列元素個數。</p>
<p>Heapify 從最末個元素開始反向疊代，每個元素都呼叫 <code>sift_down</code> 調整 heap 符合 heap ordering。總共要做 $n $ 次 <code>sift_down</code> 操作，但由於最後一層所以 leaf 已符合 heap order（因為沒有 child node），我們的迴圈可以跳過所有 leaf node 直接從非 leaf node 開始，因此複雜度為</p>
<p>$$\lfloor n / 2 \rfloor \cdot O(\log n) = O(n \log n)$$</p>
<blockquote>
<p>實際上，build heap 步驟的複雜度可達到 $O(n) $，可以看看 UMD 演算法課程 <a href="http://www.cs.umd.edu/~meesh/351/mount/lectures/lect14-heapsort-analysis-part.pdf">Lecture note 的分析</a>。</p>
</blockquote>
<h3 id="sorting-sift-down"><a class="header" href="#sorting-sift-down">Sorting (sift down)</a></h3>
<p>講完了 heapify，就換到排序部分，所謂的排序其實就是利用 max-heap（或 min-heap）的最大值（最小值）會在首個元素的特性，與最後一個元素置換，完成排序，並將剩餘的部分透過 <strong>sift down</strong> 修正符合 heap order。所以總共需要做 $n $ 次 sift down，複雜度為 $O(n \log n) $。</p>
<h3 id="sum-up"><a class="header" href="#sum-up">Sum up</a></h3>
<p>綜合這兩部分，可以看出 Sorting part 對複雜度有決定性影響，最佳複雜度為 $O(n \log n) $。</p>
<h2 id="實作-8"><a class="header" href="#實作-8">實作</a></h2>
<p>Heapsort 的實作相對簡單，只需要不斷呼叫 heap 內部的 <code>sift_down</code> 方法就可以完成排序。整個演算法架構如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn heapsort(arr: &amp;mut [i32]) {
    // -- Heapify part --
    // This procedure would build a valid max-heap.
    // (or min-heap for sorting descendantly)
    let end = arr.len();
    for start in (0..end / 2).rev() {                   // 1
        sift_down(arr, start, end - 1);
    }

    // -- Sorting part --
    // Iteratively sift down unsorted part (the heap).
    for end in (1..arr.len()).rev() {                   // 2
        arr.swap(end, 0);                               // 3
        sift_down(arr, 0, end - 1);                     // 4
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>這部分是 heapify，從最小 non-leaf node 開始（<code>end</code> / 2），修正序列至滿足 heap order，再反向疊代做 heapify。</li>
<li>這部分負責排序，每次疊代都將排序 heap 的 root 元素，步驟如 3 - 4：</li>
<li>不斷將 max-heap 中最大值（在 root 上）與 heap 最後一個元素 <code>end</code> 置換，</li>
<li>並利用 <code>sift_down</code> 將序列修正至 max-heap 資料結構，依照定義，此時 unsorted pile 首個元素成為 max-heap root，是最大值。</li>
</ol>
<p>Heapsort 全靠 <code>sift_down</code> 神救援，那 <code>sift_down</code> 到底有什麼神奇魔力，一探究竟吧！</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sift_down(arr: &amp;mut [i32], start: usize, end: usize) {
    let mut root = start;
    loop {
        let mut child = root * 2 + 1; // Get the left child   // 1
        if child &gt; end {
            break;
        }
        if child + 1 &lt;= end &amp;&amp; arr[child] &lt; arr[child + 1] {  // 2
            // Right child exists and is greater.
            child += 1;
        }

        if arr[root] &lt; arr[child] {                           // 3
            // If child is greater than root, swap'em!
            arr.swap(root, child);
            root = child;
        } else {
            break;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>sift_down</code> 的功能是將 node 往下移。通常用在 heap 刪除或取代 node 時，將序列修正為有效的 heap。 這裡實作的版本有三個參數：</p>
<ul>
<li><code>arr</code>：欲修正為符合 heap 定義的序列。</li>
<li><code>start</code>：欲往下移動的 node index，可視為需要被修正的元素。</li>
<li><code>end</code>：此 node 以內（包含）的序列都會被修正為有效的 heap。</li>
</ul>
<p><code>sift_down</code> 有些假設條件：從 <code>start</code> index 出發的子樹，除了 <code>start</code> 本身以外，其他皆符合 heap ordering。</p>
<p>再來看看 <code>sift_down</code> 實作內容，<code>loop</code> 中幹的活就是不斷將 <code>start</code> index 上的元素與其子樹比較，若不符合 heap ordering，則兩者置換。</p>
<ol>
<li><strong>是否有子結點</strong>：依照 binary heap 的定義找出 root 的左子樹（left substree），若左子樹的 index <code>child</code> 比 <code>end</code> 還大，表示沒有 heap 沒有子結點，停止疊代。</li>
<li><strong>檢查右子樹值較大</strong>：若 root 下有右子樹且較大，我們會標記右子樹，並在下一步對右子樹進行處理。</li>
<li><strong>置換</strong>：若 <code>root</code> 元素比 <code>child</code> 的元素小，則置換兩者，並將 <code>child</code> 設置為下個疊代的 <code>root</code>，繼續檢查最初的 <code>start</code> 元素是否滿足 heap ordering。</li>
</ol>
<p>以上就是簡單的 <code>sift_down</code> 實作，也是整個 heapsort 的精髓。</p>
<h2 id="參考資料-9"><a class="header" href="#參考資料-9">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">Wiki: Heap</a></li>
<li><a href="https://en.wikipedia.org/wiki/Heapsort">Wiki: Heapsort</a></li>
<li><a href="sorting/heapsort/www.cs.umd.edu/~meesh/">CMSC 351 Algorithms, Fall, 2011, University of Maryland.</a></li>
<li>Sorting GIF by RolandH <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA-3.0</a> via Wikimedia Commons.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速排序-quicksort"><a class="header" href="#快速排序-quicksort">快速排序 Quicksort</a></h1>
<p>Quicksort 是一個非常熱門且應用廣泛的排序法，相對簡單的實作就可達到 $O(n \log n) $ 的平均時間複雜度。雖然最差時間複雜度與 <a href="sorting/quicksort/../bubble_sort">bubble sort</a> 同為 $O(n^2) $，但這種情形非常少見。簡單的最佳化實作下，Quicksort 僅需 $O(\log n) $ 的額外儲存空間，比它的競爭對手 <a href="sorting/quicksort/../mergesort">mergesort</a> 來得節省。非常適合運用在真實世界中的排序法。</p>
<p>Quicksort 基本特性如下：</p>
<ul>
<li>實作簡單，速度快。</li>
<li><strong>不穩定排序</strong>：排序後，相同鍵值的元素相對位置可能改變。</li>
<li><strong>非原地排序</strong>：除了資料本身，仍需額外花費儲存空間來排序。</li>
<li><strong>分治演算法</strong>：將主問題化作數個子問題，各個擊破。</li>
</ul>
<h2 id="步驟-8"><a class="header" href="#步驟-8">步驟</a></h2>
<p>Quicksort 是一個分治演算法（divide-and-conquer），不斷遞迴下列三個步驟：</p>
<ol>
<li><strong>選擇 Pivot</strong>：在序列中任意選擇一個元素，稱為 <strong>Pivot</strong>。</li>
<li><strong>分割序列</strong>：將序列重新排序，分為兩部分，比 pivot 小 的元素置換到 pivot 之前，比 pivot 大的元素置換到 pivot 之後，而 pivot 本身會座落在它最終的正確位置。</li>
<li><strong>遞迴</strong>：分別將「比 pivot 小」及「比 pivot 大」兩部分重複上述步驟，直到新序列的長度小於等於 1，無法繼續分割為止，此時排序完成。</li>
</ol>
<h3 id="lomuto-partition-scheme"><a class="header" href="#lomuto-partition-scheme">Lomuto partition scheme</a></h3>
<p>為了達成上述條件，Quicksort 有許多不同的分割序列實作方案（partition scheme），其中以 Lomuto partition 最易理解，常被做為教材。</p>
<ol>
<li>以序列最後一個元素當做 pivot。</li>
<li>利用兩個指標 <code>i</code> <code>j</code>，其中 <code>j</code> 從頭疊代整個序列
<ul>
<li>若有序列第 j 個元素小於 pivot，則與第 i 個元素置換。</li>
<li>第 i 個元素已落在小於 pivot 的範圍，將 i 指標往後移一個，處理下個元素。</li>
</ul>
</li>
<li>疊代完成後，小於 pivot 的元素全都置換至序列前端，此時將 pivot 與第 i 個元素置換，pivot 會剛好在最終正確位置上（符合不等式）。</li>
</ol>
<p>ASCII 畫出來的分割圖如下：</p>
<pre><code>[ values &lt;= pivot | values &gt; pivot | not checked yet | pivot ]
  low           i   i+1        j-1   j        high-1   high
</code></pre>
<ul>
<li><code>arr[low...i]</code> 包含所有小於等於 pivot 的元素。</li>
<li><code>arr[i+1...j-1]</code> 包含所有大於 pivot 的元素。</li>
<li><code>arr[j...high-1]</code> 包含所有尚未疊代的元素。</li>
<li><code>arr[high]</code> pivot 本身。</li>
</ul>
<h2 id="說明-7"><a class="header" href="#說明-7">說明</a></h2>
<p>以 Lomuto partition scheme 為例，使用 ASCII diagram 解釋。</p>
<p>給定一個序列，並選擇最後一個元素作為 pivot，<code>i</code> <code>j</code> 指標則在第一個元素位置。</p>
<pre><code>                      * -&gt; pivot
[17, 20, 2, 1, 3, 21, 8]
 i
 j
</code></pre>
<p>第 <code>j</code> 個元素 17 大於 pivot 8，不置換。</p>
<pre><code>17 &gt; 8, no swap
                      * -&gt; pivot
[17| 20, 2, 1, 3, 21, 8]
 i
 j
</code></pre>
<p>第 <code>j</code> 個元素 20 大於 pivot 8，不置換。</p>
<pre><code>20 &gt; 8, no swap
                      * -&gt; pivot
[17, 20| 2, 1, 3, 21, 8]
 i
     j
</code></pre>
<p>第 <code>j</code> 個元素 2 小於 pivot 8，置換 <code>i</code> <code>j</code>。<code>i</code> 往後一個位置。</p>
<pre><code>2 &lt;= 8,
swap i, j
                      * -&gt; pivot
[2, 20, 17| 1, 3, 21, 8]
 i-&gt;i
        j
</code></pre>
<p>第 <code>j</code> 個元素 1 小於 pivot 8，置換 <code>i</code> <code>j</code>。<code>i</code> 往後一個位置。</p>
<pre><code>1 &lt;= 8
swap i, j
                      * -&gt; pivot
[2, 1, 17, 20| 3, 21, 8]
    i-&gt;i
            j
</code></pre>
<p>第 <code>j</code> 個元素 3 小於 pivot 8，置換 <code>i</code> <code>j</code>。<code>i</code> 往後一個位置。</p>
<pre><code>3 &lt;= 8
swap i, j
                      * -&gt; pivot
[2, 1, 3, 20, 17| 21, 8]
       i-&gt;i
               j
</code></pre>
<p>第 <code>j</code> 個元素 21 大於 pivot 8，不置換。</p>
<pre><code>21 &gt; 8, no swap
                      * -&gt; pivot
[2, 1, 3, 20, 17, 21| 8]
           i
                   j
</code></pre>
<p>最後，將 pivot 與第 <code>i</code> 個元素置換，此時 pivot 已在最終位置上，前面的元素皆小於等於 8，其後的元素皆大於 8。</p>
<pre><code>swap pivot, i
          i    &lt;-&gt;   * -&gt; pivot
[2, 1, 3, 8, 17, 21, 20]
</code></pre>
<p>這樣就完成一次的 partition 了！</p>
<p>之後再遞迴分割 subarray 即可完成 Quicksort。</p>
<pre><code>[2, 1, 3, 8, 17, 21, 20]
 #     #     *       *
 |     |     |       |
 -------     ---------
 quicksort    quicksort
</code></pre>
<h2 id="效能-9"><a class="header" href="#效能-9">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Complexity</th></tr></thead><tbody>
<tr><td>Worst</td><td>$O(n^2) $</td></tr>
<tr><td>Best</td><td>$O(n \log n) $</td></tr>
<tr><td>Average</td><td>$O(n \log n) $</td></tr>
<tr><td>Worst space</td><td>$O(\log n) $ or $O(n) $ auxiliary</td></tr>
</tbody></table>
</div>
<h3 id="time-complexity-1"><a class="header" href="#time-complexity-1">Time complexity</a></h3>
<p>Quicksort 僅有「<strong>選擇 Pivot</strong>」與「<strong>分割序列</strong>」兩步驟，不同的實作的效能各異，也影響 Quicksort 的時間複雜度。</p>
<h4 id="最差情況"><a class="header" href="#最差情況">最差情況</a></h4>
<p>最差的分割序列狀況發生在挑選的 pivot 總是最大或最小值（或在 Lomuto partition 下，所有元素值都一樣）。由於 Lomuto 總是選擇最後一個元素作為 pivot，這種情形好發於已排序或接近排序完成的資料上。</p>
<p>而當每次的 partition 都是最不平衡的分割序列，就會產生最差時間複雜度的狀況。遞迴在序列長度等於 1 時停止，因此整個排序法的 call stack 需要 $n - 1 $ 的嵌套遞迴呼叫（nested call）；而第 $i $ 次分割會執行 $n - i $ 次基本操作（ $O(n) $），所以總共需執行</p>
<p>$$\sum_{i = 0}^n (n - i) = n^2 - \frac{n(n + 1)}{2}$$</p>
<p>次基本操作，最差時間複雜度為 $O(n^2) $。</p>
<h4 id="最佳情況"><a class="header" href="#最佳情況">最佳情況</a></h4>
<p>既然最差情況發生在 pivot 總選到最大或最小值，反之，最佳情況則發生在每次 pivot 都可以順利選到序列的中位數（median），如此一來，每次遞迴分割的序列長度都會減半（ $n / 2 $），call stack 的嵌套遞迴總共需要 $2 \log_2{n} $ 次，序列的長度就會減至 1，而每次分割同樣有 $O(n) $ 的複雜度，因此最佳情況為：</p>
<p>$$O(n \cdot 2 \log_2{n}) = O(n \log n)$$</p>
<h3 id="space-complexity"><a class="header" href="#space-complexity">Space complexity</a></h3>
<p>Quicksort 的空間複雜度取決於實作細節，由於<strong>分割序列</strong>步驟需 $O(1) $ 的空間複雜度，因此僅需分析遞迴式會在 call stack 產生多少 stack frame 即可。</p>
<p><a href="sorting/quicksort/index.html#%E6%9C%80%E5%B7%AE%E6%83%85%E6%B3%81">前面提及</a>，最 naïve 的 Lomuto partition 最糟糕的情形下，會產生 $n - 1 $ 個嵌套遞迴，也就是需額外使用 $O(n) $ 的空間儲存 call stack frame，但只要 compiler 有支援<a href="https://en.wikipedia.org/wiki/Tail_call">尾端呼叫</a>最佳化（tail-call optimization，TCO），Quicksort 很容易最佳化至 $O(\log n) $。</p>
<h2 id="實作-9"><a class="header" href="#實作-9">實作</a></h2>
<p>Quicksort 實作主要分為兩部分：遞迴，以及分割序列（partition）。</p>
<h3 id="recursion"><a class="header" href="#recursion">Recursion</a></h3>
<p>遞迴函式本身實作非常簡單，分別將小於 pivot 與大於 pivot 兩部分遞迴呼叫自身即可。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Recursion helper
fn quicksort_helper(arr: &amp;mut [i32], lo: isize, hi: isize) {
    if lo &lt;= hi {                               // 1
        let pivot = partition(arr, lo, hi);     // 2
        quicksort_helper(arr, lo, pivot - 1);   // 3
        quicksort_helper(arr, pivot + 1, hi);   // 4
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>利用 <code>lo</code> 與 <code>hi</code> 兩個指標決定每次的遞迴範圍，並在 <code>lo</code> 大於 <code>hi</code> 時停止遞迴，避免重複分割序列。</li>
<li>分割序列步驟，回傳該序列範圍內 pivot 的 index。</li>
<li>遞迴小於 pivot 的部分。</li>
<li>遞迴大於 pivot 的部分。</li>
</ol>
<blockquote>
<p>這邊比較特別的是，<code>lo</code> 和 <code>hi</code> 兩個指標的型別為 <code>isize</code>，因為當 pivot 可能為 0，在第三步驟 - 1 時會產生型別錯誤，故為之。有任何更好的寫法歡迎提供！</p>
</blockquote>
<p>由於外部不需知道排序法實作細節，我們將函式命名為 <code>quicksort_helper</code> ，對外再多封裝一層主函式 <code>quicksort_lomuto</code>，實作如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn quicksort_lomuto(arr: &amp;mut [i32]) {
    let hi = arr.len() as isize - 1;
    quicksort_helper(arr, 0, hi);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="partitioning"><a class="header" href="#partitioning">Partitioning</a></h3>
<p>一般來說，分割序列的實作有下列兩個步驟：</p>
<ul>
<li>選擇 pivot</li>
<li>遍歷序列置換元素</li>
</ul>
<p>我們以 Lomuto scheme 實作 partition。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn partition(arr: &amp;mut [i32], lo: isize, hi: isize) -&gt; isize {
    // -- Determine the pivot --
    // In Lomuto parition scheme,
    // the latest element is always chosen as the pivot.
    let pivot = arr[hi as usize];               // 1
    let mut i = lo;

    // -- Swap elements --
    for j in lo..hi {                           // 2
        if arr[j as usize] &lt; pivot {
            arr.swap(i as usize, j as usize);
            i += 1;                             // 3
        }
    }
    // Swap pivot to the middle of two piles.
    arr.swap(i as usize, hi as usize);          // 4
    i // Return the final index of the pivot
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>Lomuto scheme 選擇 pivot 的方式很直接，就是選擇最後一個元素。</li>
<li>利用 <code>i</code>、<code>j</code> 兩個指標疊代指定的序列範圍，若第 j 個值小於 pivot 時，則於第 i 個元素置換。</li>
<li><code>i</code> 指標加一，繼續處理下個元素。</li>
<li>最後置換第 i 個元素於 pivot，此時 pivot 已落在最終正確的位置。</li>
</ol>
<h2 id="最佳化與變形"><a class="header" href="#最佳化與變形">最佳化與變形</a></h2>
<p>Quicksort 有數個方向可以探討最佳化：</p>
<ul>
<li><a href="sorting/quicksort/index.html#%E9%99%8D%E4%BD%8E%E9%A1%8D%E5%A4%96%E7%A9%BA%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6">降低額外空間複雜度</a></li>
<li><a href="sorting/quicksort/index.html#%E9%81%B8%E6%93%87-pivot-%E7%9A%84%E6%96%B9%E6%B3%95">選擇 Pivot 的方法</a></li>
<li><a href="sorting/quicksort/index.html#%E5%B0%8D%E4%BB%98%E9%87%8D%E8%A4%87%E7%9A%84%E5%85%83%E7%B4%A0">對付重複的元素</a></li>
<li><a href="sorting/quicksort/%E9%81%B8%E6%93%87%E4%B8%8D%E5%90%8C%E7%9A%84%E5%88%86%E5%89%B2%E6%96%B9%E6%A1%88">選擇不同的分割方案</a></li>
</ul>
<h3 id="降低額外空間複雜度"><a class="header" href="#降低額外空間複雜度">降低額外空間複雜度</a></h3>
<p>前述提到最佳情形下（每次 pivot 都選到中位數），僅需 $\log n $ 個嵌套遞迴，額外空間複雜度僅需 $O(\log n) $。
倘若編譯器有實作 <strong>尾端呼叫最佳化</strong>，Quicksort 可以達到 $O(\log n) $ 對數級別的額外空間使用。</p>
<p>實作尾端呼叫最佳化的思路很簡單，「<strong>先遞迴較少元素的部分，再利用 tall-call 遞迴另一部分</strong>」，如此以來，較多元素的遞迴則會直接被編譯器展開，消去遞迴時需要的 call stack 空間。剩下較少元素的部分，則與最佳情形相同，最多僅需 $\log n $ 次嵌套遞迴。</p>
<p>簡單實作如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn quicksort_helper_optimized(arr: &amp;mut [i32], lo: isize, hi: isize) {
    if lo &lt;= hi {
        let pivot = partition(arr, lo, hi);
        if pivot - lo &lt; hi - pivot {                      // 1
          quicksort_helper_optimized(arr, lo, pivot - 1);
          quicksort_helper_optimized(arr, pivot + 1, hi); // 2
        } else {
          quicksort_helper_optimized(arr, pivot + 1, hi);
          quicksort_helper_optimized(arr, lo, pivot - 1); // 3
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>說穿了就只有這個判斷式，決定哪部分該先遞迴而已。</li>
<li>這是一個尾端呼叫，會展開。</li>
<li>這也是一個尾端呼叫。</li>
</ol>
<p>實際上，截至 2018.2，<a href="https://github.com/rust-lang/rfcs/pull/1888">Rust Core Team 決定暫緩 TCO 的實作</a>，目前 Rust 並沒有支援 TCO。但我們還是可以手動實作 TCO，減少 call stack。</p>
<p>我們先把原始的 lomuto partition 實作改成手動 TCO 版本。利用 <code>while</code> loop，將 <code>lo</code> 替換成下一個遞迴的引數，減少部分的 call stack。</p>
<pre><code class="language-diff">- fn quicksort_helper(arr: &amp;mut [i32], lo: isize, hi: isize) {
+ fn quicksort_helper_manual_tco(arr: &amp;mut [i32], mut lo: isize, mut hi: isize) {
-     if lo &lt;= hi {
+     while lo &lt; hi {
          let pivot = partition(arr, lo, hi);
-         quicksort_helper(arr, lo, pivot - 1);
-         quicksort_helper(arr, pivot + 1, hi);
+         quicksort_helper_manual_tco(arr, lo, pivot - 1);
+         lo = pivot + 1;
      }
  }
</code></pre>
<p>再來，選擇性遞迴較小的部分。Iterative 版本的尾端呼叫消除（tail-call eliminate）就做完了！</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn quicksort_helper_manual_tco(arr: &amp;mut [i32], mut lo: isize, mut hi: isize) {
    while lo &lt; hi {
        let pivot = partition(arr, lo, hi);
        if pivot - lo &lt; hi - pivot {
            quicksort_helper_manual_tco(arr, lo, pivot - 1);
            lo = pivot + 1;
        } else {
            quicksort_helper_manual_tco(arr, pivot + 1, hi);
            hi = pivot - 1;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="選擇-pivot-的方法"><a class="header" href="#選擇-pivot-的方法">選擇 Pivot 的方法</a></h3>
<p>選擇 pivot 的方法大致上有以下幾種：</p>
<ul>
<li>總是選擇最後一個元素。</li>
<li>總是選擇第一個元素。</li>
<li>選擇特定位置（如中位數）的元素。</li>
<li>隨機選擇任意元素。</li>
</ul>
<p>選擇第一個或最後一個元素會印序列已經接近排序完成或相反排序，造成 $O(n^2) $ 最壞的時間複雜度。隨機或選擇特定位置的方法較能避免這種情況，但實作上較困難。</p>
<p>除了選擇 pivot 的方法，近幾年來多 pivot（multi-pivot）Quicksort 也愈趨流行，可以減少 20% 的元素置換。相關的討論與證明可以參考<a href="https://cs.stanford.edu/~rishig/courses/ref/l11a.pdf">這篇文章</a>。</p>
<h3 id="對付重複的元素"><a class="header" href="#對付重複的元素">對付重複的元素</a></h3>
<p>若輸入序列有許多重複的元素，使用原本 Lomuto scheme 實作的 Quicksort 仍然會比較置換等於 pivot 的所有元素。3-way partition scheme 就是將序列多分出「等於 pivot」部分，減少重複置換相等元素的排序法。</p>
<pre><code>[ values &lt; pivot | values == pivot | value &gt; pivot ]
</code></pre>
<p>通常是使用著名的 <a href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem">Dutch national flag algorithm</a> 來解決這個問題。實作上和 Lomuto 非常類似。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn partition(arr: &amp;mut [i32], lo: isize, hi: isize) -&gt; (isize, isize) {
    let pivot = arr[hi as usize];
    let mut i = lo;         // smaller
    let mut j = lo;         // equal
    let mut k = hi;         // large

    while j &lt;= k {
        if arr[j as usize] &lt; pivot {
            arr.swap(i as usize, j as usize);
            i += 1;
            j += 1;
        } else if arr[j as usize] &gt; pivot {
            arr.swap(k as usize, j as usize);
            k -= 1;
        } else {
            // No swap when identicial.
            j += 1;
        }
    }

    // Return smaller and larger pointer to avoid iterate duplicate elements.
    (i, k)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="選擇不同的分割方案"><a class="header" href="#選擇不同的分割方案">選擇不同的分割方案</a></h3>
<p>不同的分割方案有著不同的應用場景，如上述的 3-way scheme 就適合重複元素多的序列。這裡再多介紹另一個常見的分割實作方案 Hoare partition，是 Quicksort 發明這 Hoare 自己提出的分割法，Rust 實作演算法如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn partition(arr: &amp;mut [i32], lo: usize, hi: usize) -&gt; usize {
    let pivot = arr[lo];
    let mut i = lo;
    let mut j = hi;

    loop {
        // Find element &gt;= pivot from leftmost element.
        while arr[i] &lt; pivot {                            // 1
            i += 1;
        }
        // Find element &lt;= pivot from rightmost element.
        while arr[j] &gt; pivot {                            // 2
            j -= 1;
        }
        if i &gt;= j {
            return j;
        }
        // Two elements are misplaced, swap them.
        arr.swap(i, j);                                   // 3
        i += 1;
        j -= 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>從最左邊開始找比 pivot 大或相等的元素。</li>
<li>從最右邊開始找比 pivot 小或相等的元素。</li>
<li>若找到這兩個元素，置換之，以符合小於 pivot 在前，大於 pivot 在後的分割準則。</li>
</ol>
<h2 id="參考資料-10"><a class="header" href="#參考資料-10">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Quicksort">Wiki: Quicksort</a></li>
<li><a href="https://algs4.cs.princeton.edu/23quicksort/">Algorithms, 4th Edition by R. Sedgewick and K. Wayne</a></li>
<li><a href="https://www.geeksforgeeks.org/quick-sort/">GeeksForGeeks: QuickSort</a></li>
<li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Quicksort">Swift Algorithm Club: Quicksort</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="合併排序-mergesort"><a class="header" href="#合併排序-mergesort">合併排序 Mergesort</a></h1>
<p>Mergesort 是一個泛用且高效穩定的排序法，最佳與最差時間複雜都是 $O(n \log n) $。Mergesort 可謂著名「Divide and Conquer」手法的經典案例，先將序列分成更小的子序列（Divide），一個個排序後（Conquer），再合併已排序的子序列（Combine）。</p>
<ul>
<li><strong>高效穩定</strong>：最佳、平均，與最差時間複雜度皆為 $O(n \log n) $。</li>
<li><strong>穩定排序</strong>：相同鍵值的元素，排序後相對位置不改變。</li>
<li><strong>非原地排序</strong>：除了資料本身，仍需額外花費儲存空間來排序。</li>
<li><strong>分治演算法</strong>：將主問題化作數個子問題，各個擊破。</li>
</ul>
<h2 id="步驟-9"><a class="header" href="#步驟-9">步驟</a></h2>
<p>Mergesort 演算法分為以下步驟：</p>
<ol>
<li><strong>Divide</strong>：將含有 n 個元素的序列分割成含有 n / 2 個子序列。</li>
<li><strong>Conquer</strong>：排序分割後的兩個子序列。</li>
<li><strong>Combine</strong>：合併排序完成的兩子序列，成為一個排好序的序列。</li>
</ol>
<p>其中，Conquer 步驟中的「排序」可以不斷遞迴 Mergesort 自身，因此需要停止遞迴的條件（base case），我們將條件設定為「子序列的長度小於 2」，因為長度為 1 的序列可視為已完成排序。</p>
<p>將 Mergesort 視覺化排序如下：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c5/Merge_sort_animation2.gif" alt="mergsort" /></p>
<h2 id="說明-8"><a class="header" href="#說明-8">說明</a></h2>
<p>以 ASCII diagram 圖解 Mergesort。</p>
<p>先將原始序列分割成數個長度為一的子序列。</p>
<pre><code>Split array into length 1 subarray.

    [8, 7, 1, 2, 4, 6, 5, 3]
                |
   [8, 7, 1, 2] | [4, 6, 5, 3]
                |
  [8, 7] [1, 2] | [4, 6] [5, 3]
                |
[8] [7] [1] [2] | [4] [6] [5] [3]
                V
              split
</code></pre>
<p>再將子序列依序合併成一個排好序的大序列。</p>
<pre><code>Recursively merge subarray respecting the order.

              Merge
                |
[8] [7] [1] [2] | [4] [6] [5] [3]
                |
  [7, 8] [1, 2] | [4, 6] [3, 5]
                |
   [1, 2, 7, 8] | [3, 4, 5, 6]
                V
    [1, 2, 3, 4, 5, 6, 7, 8]
</code></pre>
<h2 id="效能-10"><a class="header" href="#效能-10">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Complexity</th></tr></thead><tbody>
<tr><td>Worst</td><td>$O(n \log n) $</td></tr>
<tr><td>Best</td><td>$O(n \log n) $</td></tr>
<tr><td>Average</td><td>$O(n \log n) $</td></tr>
<tr><td>Worst space</td><td>$O(n) $ auxiliary</td></tr>
</tbody></table>
</div>
<h3 id="time-complexity-2"><a class="header" href="#time-complexity-2">Time Complexity</a></h3>
<p>透過遞迴關係式，很容易計算 Mergesort 的時間複雜度。假設排序長度為 $n $ 的序列最多需要 $T(n) $ 時間。可以觀察到，如果序列只有一個元素，Mergesort 僅需要常數時間就可以完成排序，寫成 $T(n) = 1 $。</p>
<p>如果 $n &gt; 2 $，Mergesort 會將序列分為 $\lceil \frac{n}{2} \rceil $ 部分，以及 $\lfloor \frac{n}{2} \rfloor $ 部分。我們可以將排序前者寫成 $T(\lceil \frac{n}{2} \rceil) $，而後者花費時間為 $ T(\lfloor \frac{n}{2} \rfloor) $。</p>
<p>最後，合併兩個子序列僅需 $n $ 個操作。可得下列遞迴關係式。<br />
（為了方便計算，把 floor 和 ceil 捨去）</p>
<p>$$
T(n) =
\begin{cases}
1                   &amp; \text{if } n = 1, \\
2T(\frac{n}{2}) + n &amp; \text{otherwise.}
\end{cases}
$$</p>
<p>根據 <a href="sorting/mergesort/master-theorem">Master Theorem</a>，可得複雜度為 $O(n \log n) $。</p>
<h3 id="space-complexity-1"><a class="header" href="#space-complexity-1">Space Complexity</a></h3>
<p>Mergesort 的缺點之一就是在合併子序列時，需要額外的空間依序插入排序資料；若是遞迴版本的 Mergesort 還需額外加上遞迴花費的 call stack 空間，因此額外空間複雜度為 $O(n) + O(\log n) = O(n) $（以陣列實作）。</p>
<h2 id="實作-10"><a class="header" href="#實作-10">實作</a></h2>
<p>一般來說，Divide and Conquer 有兩種設計、解決問題的技巧：Top-down（自上而下）與 Buttom-up（自下而上）。前者是先對問題有整體的輪廓概念，再逐步針對細節一一處理；後者則是先準備每個問題需要的基礎步驟與元件，再將這些步驟結合，解決整體的問題。</p>
<p>Mergesort 的實作分為兩部分：</p>
<ul>
<li><code>mergesort</code> 主程式：對外的介面，負責分割序列。對應 Divide 功能。</li>
<li><code>merge</code>：合併子序列，對應到 Conquer 與 Combine 功能。</li>
</ul>
<p>先來看看如何分割序列。</p>
<h3 id="top-down-split"><a class="header" href="#top-down-split">Top-down split</a></h3>
<p>自上而下的解法會不斷以類似 binary search 的方式找中點，進而分割序列。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn mergesort(arr: &amp;mut [i32]) {
    let mid = arr.len() / 2;
    if mid == 0 {                 // 1
        return;
    }

    mergesort(&amp;mut arr[..mid]);   // 2
    mergesort(&amp;mut arr[mid..]);

    // Create an array to store intermediate result.
    let mut ret = arr.to_vec();   // 3

    // Merge the two piles.
    merge(&amp;arr[..mid], &amp;arr[mid..], &amp;mut ret[..]);  // 4

    // Copy back the result back to original array.
    arr.copy_from_slice(&amp;ret);    // 5
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>設定遞迴的終止條件（base case），middle index 為 0 表示長度不大於 1。</li>
<li>利用 Rust 的 <a href="https://doc.rust-lang.org/std/ops/struct.Range.html">Range Operator</a>，可快速分割兩個 <code>slice</code>。</li>
<li>建立一個 <code>Vec</code> 儲存排序結果。</li>
<li>將兩個 <code>slice</code> 合併排序至 <code>ret</code> vector 中。</li>
<li>將 <code>ret</code> 的結果複製到原始 <code>arr</code> 中，使回傳值保有相同起始位址。</li>
</ol>
<h3 id="buttom-up-split"><a class="header" href="#buttom-up-split">Buttom-up split</a></h3>
<p>自下而上的解法則是預定好最小的子序列長度，直接使用 for 迴圈從頭開始逐一擊破。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn mergesort_bottom_up(arr: &amp;mut [i32]) {
    let mut width = 1;                                // 1
    // Create an array to store intermediate result.
    let mut ret = arr.to_vec();                       // 2
    let len = arr.len();

    while width &lt; len {
        let mut i = 0;
        while i &lt; len {
            // Check to avoid upper bound and middle index out of bound.
            let upper = ::std::cmp::min(i + 2 * width, len);  // 3
            let mid = ::std::cmp::min(i + width, len);

            merge(&amp;arr[i..mid], &amp;arr[mid..upper], &amp;mut ret[i..upper]);

            // Copy the merged result back to original array.
            arr[i..upper].copy_from_slice(&amp;ret[i..upper]);    // 4

            // Increase start index to merge next two subsequences.
            i += 2 * width;                           // 5
        }
        width *= 2;                                   // 6
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>設定最小的子序列長度，這個長度以下的子序列皆視為已排序。</li>
<li>建立一個 <code>Vec</code> 儲存排序結果。</li>
<li>取最小值，避免下標超出邊界，並且維持除了最後一組，其他子序列長度恆為 <code>width</code>。</li>
<li>複製這部分排序結果 <code>ret</code> 到原始的 <code>arr</code> 中。</li>
<li>繼續下兩個子序列的合併步驟。</li>
<li>將下個疊代的子序列長度加倍，繼續合併。</li>
</ol>
<h3 id="the-merge-part"><a class="header" href="#the-merge-part">The merge part</a></h3>
<p>無論是 Top-down 還是 Buttom-up 版本的解法，皆免不了 <code>merge</code> 這個共同步驟，將子序列合併為較大的序列。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn merge(arr1: &amp;[i32], arr2: &amp;[i32], ret: &amp;mut [i32]) {
    let mut left = 0; // Head of left pile.             // 1
    let mut right = 0; // Head of right pile.
    let mut index = 0;

    // Compare element and insert back to result array.
    while left &lt; arr1.len() &amp;&amp; right &lt; arr2.len() {     // 2
        if arr1[left] &lt;= arr2[right] {                  // 3
            ret[index] = arr1[left];
            index += 1;
            left += 1;
        } else {
            ret[index] = arr2[right];
            index += 1;
            right += 1;
        }
    }

    // Copy the reset elements to returned array.
    // `memcpy` may be more performant than for-loop assignment.
    if left &lt; arr1.len() {                              // 4
        ret[index..].copy_from_slice(&amp;arr1[left..]);
    }
    if right &lt; arr2.len() {
        ret[index..].copy_from_slice(&amp;arr2[right..]);
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>建立三個指標，分別給 <code>arr1</code>、<code>arr2</code> 與回傳陣列 <code>ret</code> 使用。</li>
<li>這部分依序比較兩個子序列，排序較小者先進入回傳 <code>ret</code>。直到其中一序列所有元素都進入 <code>ret</code> 就停止。</li>
<li>這邊判斷使用 <code>&lt;=</code> 小於等於確保排序穩定（相同鍵值順序不換）。</li>
<li>將剩餘未進入 <code>ret</code> 的元素，依序複製到 <code>ret</code> 中。</li>
</ol>
<blockquote>
<p><code>slice.copy_from_slice</code> 底層使用 C 的 <code>memcpy</code>，比起 for-loop 一個個賦值，直接複製整塊記憶體比較快了。</p>
</blockquote>
<h2 id="變形-2"><a class="header" href="#變形-2">變形</a></h2>
<h3 id="timsort"><a class="header" href="#timsort">Timsort</a></h3>
<p>在真實世界資料中，早有許多部分排序的分區（natural run），倘若跳過排序這些分區的步驟，就可減少許多不必要的操作，<a href="sorting/mergesort/../timsort">Timsort</a> 就是為了完全利用榨乾這些分區的混合排序法。</p>
<h2 id="參考資料-11"><a class="header" href="#參考資料-11">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Merge_sort">Wiki: Merge sort</a></li>
<li><a href="sorting/mergesort/www.cs.umd.edu/~meesh/">CMSC 351 Algorithms, Fall, 2011, University of Maryland.</a></li>
<li>Sorting GIF was created By CobaltBlue <a href="https://creativecommons.org/licenses/by-sa/2.5">CC BY-SA 2.5</a> via Wikimedia Commons.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="計數排序-counting-sort"><a class="header" href="#計數排序-counting-sort">計數排序 Counting sort</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Counting_sort">Counting sort</a> 是一個特殊的整數排序法，被視為 <a href="sorting/counting_sort/../bucket_sort">Bucket sort</a> 的特例。原理是在已知整數範圍內，計算每個鍵值出現次數，並用額外的陣列保存（Count array）。最後將 Count array 的元素值作為排序資料的新 index。</p>
<p>Counting sort 基本特性如下：</p>
<ul>
<li><strong>非原地排序</strong>：額外花費較大量、非固定的空間來排序。</li>
<li><strong>穩定排序</strong>：相同鍵值的元素，排序後相對位置不改變。</li>
<li><strong>整數排序</strong>：以整數作為排序的鍵值。</li>
<li><strong>分配式排序</strong>：不透過兩兩比較，而是分析鍵值分佈來排序。特定情況下可達線性執行時間。</li>
<li><strong>線型執行時間</strong>：當輸入資料量 <strong>n</strong> 與已知範圍上下界之差值相近，執行時間接近線型（<strong>O(n)</strong>）</li>
<li><strong>預期分佈</strong>：預期輸入資料是落在已知範圍內的整數（例如 0 到 k）。</li>
<li><strong>適用範圍</strong>：僅適用於小範圍整數（額外空間需求大）。</li>
</ul>
<h2 id="步驟-10"><a class="header" href="#步驟-10">步驟</a></h2>
<ol>
<li><strong>Count occurrence</strong>：計算每個 key 的出現次數。</li>
<li><strong>Prefix sum as start index</strong>：計算前綴和（Prefix sum），並作為該元素的 start index。</li>
<li><strong>Copy output</strong>：利用步驟二的前綴和，遍歷輸入資料，取得元素排序後的索引。</li>
</ol>
<h2 id="說明-9"><a class="header" href="#說明-9">說明</a></h2>
<p>這裡有資料需要透過正整數的 key 來排序。key 的範圍在 0 - 9 之間，格式為 <code>(key, value)</code>。</p>
<pre><code>Input: (1, A) (5, B) (8, C) (2, D) (2, E) (9, F)
</code></pre>
<p><strong>1. Count occurrence</strong>：首先，先計算每個 key 的出現頻率，儲存在額外的 count array 中。</p>
<pre><code>Key  : 0 1 2 3 4 5 6 7 8 9
Count: 0 1 2 0 0 1 0 0 1 1
</code></pre>
<p><strong>2. Prefix sum as start index</strong>：再計算 prefix sum，也就是將當前 index 前累計的 key 數量加總。例如 <strong>key 5</strong> 的 prefix sum <strong>1 + 2 = 3</strong>。</p>
<p>這裡的 prefix sum 等同於每筆資料排序後的位置（index）。例如排序後，<strong>8</strong> 位於陣列第四位。</p>
<pre><code>Key       : 0 1 2 3 4 5 6 7 8 9
Prefix Sum: 0 0 1 3 3 3 4 4 4 5
</code></pre>
<p><strong>3. Copy output</strong>：透過 key 與 prefix sum 的映射關係，找到原始資料對應的位置。</p>
<p>實作上，每筆資料找到對應的 start index（prefix sum） 後，要將<strong>該 index 之值 +1</strong>，使得重複的元素可取得正確的 index offset（對唯一的 key 沒有影響）。</p>
<pre><code>(1, A)
--&gt; prefix sum 為 0，寫入 array[0]，並將 prefix sum + 1

+--------+--------+--------+--------+--------+--------+
| (1, A) |        |        |        |        |        |
+--------+--------+--------+--------+--------+--------+

(5, B)
--&gt; prefix sum 為 3，寫入 array[3]，並將 prefix sum + 1

+--------+--------+--------+--------+--------+--------+
| (1, A) |        |        | (5, B) |        |        |
+--------+--------+--------+--------+--------+--------+

(8, C)
--&gt; prefix sum 為 4，寫入 array[4]，並將 prefix sum + 1

+--------+--------+--------+--------+--------+--------+
| (1, A) |        |        | (5, B) | (8, C) |        |
+--------+--------+--------+--------+--------+--------+

(2, D)
--&gt; prefix sum 為 1，寫入 array[1]，並將 prefix sum + 1

+--------+--------+--------+--------+--------+--------+
| (1, A) | (2, D) |        | (5, B) | (8, C) |        |
+--------+--------+--------+--------+--------+--------+

(2, E)
--&gt; prefix sum 為 2（前一步驟 + 1），寫入 array[2]，並將 prefix sum + 1

+--------+--------+--------+--------+--------+--------+
| (1, A) | (2, D) | (2, E) | (5, B) | (8, C) |        |
+--------+--------+--------+--------+--------+--------+

(9, F)
--&gt; prefix sum 為 5，寫入 array[5]，並將 prefix sum + 1

+--------+--------+--------+--------+--------+--------+
| (1, A) | (2, D) | (2, E) | (5, B) | (8, C) | (9, F) |
+--------+--------+--------+--------+--------+--------+
</code></pre>
<p>這樣就完成排序了。此外，觀察 <strong>(2, D)</strong> 與 <strong>(2, E)</strong> 排序前後的位置，會發現 counting sort 是個實實在在的穩定排序，很棒。</p>
<h2 id="效能-11"><a class="header" href="#效能-11">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Complexity</th></tr></thead><tbody>
<tr><td>Worst</td><td>$O(n + k) $</td></tr>
<tr><td>Best</td><td>$O(n + k) $</td></tr>
<tr><td>Average</td><td>$O(n + k) $</td></tr>
<tr><td>Worst space</td><td>$O(n + k) $ auxiliary</td></tr>
</tbody></table>
</div>
<blockquote>
<p>k 為資料已知範圍上下界之差。</p>
</blockquote>
<h3 id="time-complexity-3"><a class="header" href="#time-complexity-3">Time Complexity</a></h3>
<p>Counting sort 沒有用到任何遞迴，可以直觀地分析複雜度。在步驟一，建立 count array 與步驟三輸出排序結果，都需要遍歷 $n $ 個輸入的資料，因此複雜度為 $O(n) $；步驟二計算 prefix sum，以及 count array 自身的初始化則需執行 $k + 1 $ 次（給定的資料範圍），這部分的複雜度為 $O(k) $。由於 $n $ 與 $k $ 的權重會因輸入資料及實作的不同而有所改變，我們無法捨棄任何一個因子，可得知 counting sort 的複雜度為 $O(n + k) $。</p>
<h3 id="space-complexity-2"><a class="header" href="#space-complexity-2">Space complexity</a></h3>
<p>Counting sort 並非 in-place sort，排序後的結果會另外輸出為新的記憶體空間，因此 $O(n) $ 的額外（auxiliary）空間複雜度絕對免不了。再加上需要長度為 $k $ 的 count array 保存每個 key 的出現次數，因此需再加上 $O(k) $。除了原始的輸入 array，總共需花費 $O(n + k) $ 的額外空間複雜度。</p>
<blockquote>
<p>如果欲排序資料就是整數鍵值自身，可以將「計算前綴和」與「複製輸出」兩步驟最佳化，直接覆寫原始陣列，額外空間複雜度會下降至 $O(k) $，但也因此成為不穩定排序法。</p>
</blockquote>
<h2 id="實作-11"><a class="header" href="#實作-11">實作</a></h2>
<p>由於 Counting sort 屬於分布式排序（Distribution sort），這裡使用泛型，以彰顯分布式排序的特色。</p>
<h3 id="function-signature"><a class="header" href="#function-signature">Function Signature</a></h3>
<p>首先，我們先看函式如何宣告（function signature）。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn counting_sort&lt;F, T&gt;(arr: &amp;mut [T], min: usize, max: usize, key: F) 
    where F: Fn(&amp;T) -&gt; usize, 
          T: Clone,
<span class="boring">}</span></code></pre></pre>
<p>這裡使用了四個參數：</p>
<ul>
<li><code>arr</code>：待排序陣列。</li>
<li><code>min</code>、<code>max</code>：整數排序的上下界。</li>
<li><code>key</code>：由於資料不一定是整數，需要一個 function 從資料擷取鍵值做排序。</li>
</ul>
<p>另外，也使用兩個泛型型別：</p>
<ul>
<li><code>F</code>：<code>key</code> extactor 的型別，回傳的 <code>usize</code> 必須落在 <code>[min, max)</code> 之間。</li>
<li><code>T</code>：陣列元素的型別，實作 <code>Clone</code> 是由於 Counting sort 需要將 output 再複製回原本的參數 <code>arr</code> 上，達成「偽」原地排序。</li>
</ul>
<h3 id="prefix-sums-array"><a class="header" href="#prefix-sums-array">Prefix Sums Array</a></h3>
<p>再來，了解如何建立一個元素出現次數的陣列。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn counting_sort() {
    // ...

    let mut prefix_sums = {
        // 1. Initialize the count array with default value 0.
        let len = max - min;
        let mut count_arr = Vec::with_capacity(len);
        count_arr.resize(len, 0);

        // 2. Scan elements to collect counts.
        for value in arr.iter() {
            count_arr[key(value)] += 1;
        }

        // 3. Calculate prefix sum.
        count_arr.into_iter().scan(0, |state, x| {
                *state += x;
                Some(*state - x)
            }).collect::&lt;Vec&lt;usize&gt;&gt;()
    };
    // ...
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>建立一個長度為上下界之差的 count array。注意，這裡使用了 <code>Vec.resize</code>，因為 Rust initialize 空的 <code>Vec</code> 時並不會插入 0 或其他預設值。</li>
<li>遍歷整個輸入資料，利用 <code>key</code> function 取出每筆資料的鍵值，出現一次就 +1。</li>
<li>利用 Iterator 上的 <code>scan</code> method 計算每個鍵值的 prefix sum。需要注意的是，每個元素對應的 prefix sum 不包含自身，例如 key 3 的計算結果就是 key 1 與 key 2 的出現總次數，如此一來，prefix sum 才會直接對應到排序後的位置。</li>
</ol>
<h3 id="prefix-sums-as-start-index"><a class="header" href="#prefix-sums-as-start-index">Prefix Sums as Start Index</a></h3>
<p>最後一步就是將 prefix sum 當作每個 element 的正確位置，把資料重頭排序。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn counting_sort() {
    // ...

    for value in arr.to_vec().iter() {            // 1
        let index = key(value);
        arr[prefix_sums[index]] = value.clone();  // 2
        prefix_sums[index] += 1;                  // 3
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>將輸入資料透過 <code>to_vec</code> 複製起來疊代，需要複製 <code>arr</code> 是因為之後要直接在 <code>arr</code> 插入新值，需要另一份原始輸入的拷貝。</li>
<li>利用 <code>key</code> 擷取鍵值後，把資料複製給 <code>arra</code> 上對應 <code>prefix_sums[index]</code> 的位置。</li>
<li>將該 <code>prefix_sums[index]</code> 的值加一，以便元素重複時，可以正常複製到下一個位置。</li>
</ol>
<p>完成了！這裡再貼一次完整的程式碼。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn counting_sort&lt;F, T&gt;(arr: &amp;mut [T], min: usize, max: usize, key: F) 
    where F: Fn(&amp;T) -&gt; usize,
          T: Clone,
{
    let mut prefix_sums = {
        // 1. Initialize the count array with default value 0.
        let len = max - min;
        let mut count_arr = Vec::with_capacity(len);
        count_arr.resize(len, 0);

        // 2. Scan elements to collect counts.
        for value in arr.iter() {
            count_arr[key(value)] += 1;
        }

        // 3. Calculate prefix sum.
        count_arr.into_iter().scan(0, |state, x| {
                *state += x;
                Some(*state - x)
            }).collect::&lt;Vec&lt;usize&gt;&gt;()
    };

    // 4. Use prefix sum as index position of output element.
    for value in arr.to_vec().iter() {
        let index = key(value);
        arr[prefix_sums[index]] = value.clone();
        prefix_sums[index] += 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="參考資料-12"><a class="header" href="#參考資料-12">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Counting_sort">Wiki: Counting sort</a></li>
<li><a href="http://www.growingwiththeweb.com/2014/05/counting-sort.html">Growing with the web: Counting sort</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="桶排序-bucket-sort"><a class="header" href="#桶排序-bucket-sort">桶排序 Bucket sort</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Bucket_sort">Bucket sort</a>，是一個非比較排序。原理是建立一些桶子，每個桶子對應一資料區間，在將待排序資料分配到不同的桶中，桶子內部各自排序。由於並非<a href="https://en.wikipedia.org/wiki/Comparison_sort">比較排序</a>，使用 Bucket sort 需要事先知道資料的範圍與分佈，才能決定桶子對應的區間。</p>
<p>Bucket sort 基本特性如下：</p>
<ul>
<li>又稱 <strong>bin sort</strong>。</li>
<li><strong>穩定排序</strong>：相同鍵值的元素，排序後相對位置不改變。</li>
<li><strong>分配式排序</strong>：不透過兩兩比較，而是分析鍵值分佈來排序。特定情況下可達線性執行時間。</li>
<li><strong>預期分佈</strong>：資料為<strong>均勻分佈</strong>。</li>
</ul>
<h2 id="步驟-11"><a class="header" href="#步驟-11">步驟</a></h2>
<p>假設要排序 $n $ 個元素的陣列，這些元素的值平均散落在某個<strong>已知的預期範圍內</strong>，例如 1 到 100。</p>
<ol>
<li><strong>Create buckets</strong>：建立 $k $ 個桶子（bucket）的陣列。每個桶子<strong>對應預期範圍的某區間</strong>，如第一個桶子放 1 到 10，第二個放 11 到 20。</li>
<li><strong>Scatter</strong>：將每個元素依照該值放入對應的桶子中。</li>
<li><strong>Inner sort</strong>：排序所有非空的桶子。</li>
<li><strong>Gather</strong>：依序走訪所有桶子，將桶內的元素放回原本的陣列中。</li>
</ol>
<h2 id="說明-10"><a class="header" href="#說明-10">說明</a></h2>
<p>以下用 ASCII diagram 視覺化解釋：</p>
<p>這裡有一些整數，落在 1 至 100 之間。我們有 $n = 10 $ 的陣列要排序。</p>
<pre><code>Original array

+-------------------------------------------------+
|  6 | 28 | 96 | 14 | 74 | 37 |  9 | 71 | 91 | 36 |
+-------------------------------------------------+
</code></pre>
<p><strong>1. Create buckets</strong>：建立一定數量的桶子，這裡我們建立與原始陣列相同數量的桶子（10）。每個桶子對應 $n - 1 * 10 $ 到 $n * 10 $ 的區間。</p>
<pre><code>Bucket array

+-------------------------------------------------+
|    |    |    |    |    |    |    |    |    |    |
+-------------------------------------------------+
  ^    ^
  |    |
  |    |
  |    holds values in range 11 to 20
  holds values in range 1 to 10
</code></pre>
<p><strong>2. Scatter</strong>：將原始陣列中的元素，放入對應的桶中。</p>
<pre><code>Bucket array

  6,9  14   28   37,36               74,71     96,91
  |    |    |    |                   |         |
+-v----v----v----v-------------------v---------v--+
|    |    |    |    |    |    |    |    |    |    |
+-------------------------------------------------+
</code></pre>
<p><strong>3. Inner sort</strong>：排序所有非空桶子中的元素，桶內排序可用任意排序法，通常選用「insertion sort」，可確保排序穩定性，並降低額外開銷。</p>
<pre><code>Bucket array

  sort sort sort sort                sort      sort
  ---  --   --   -----               -----     -----
  6,9  14   28   36,37               71,74     91,96
  |    |    |    |                   |         |
+-v----v----v----v-------------------v---------v--+
|    |    |    |    |    |    |    |    |    |    |
+-------------------------------------------------+
</code></pre>
<p><strong>4. Gather</strong>：排序完後，再將所有桶中元素依序放回原始的陣列。</p>
<pre><code>Original array
+-------------------------------------------------+
|  6 |  9 | 14 | 28 | 36 | 37 | 71 | 74 | 91 | 96 |
+-------------------------------------------------+
</code></pre>
<h2 id="效能-12"><a class="header" href="#效能-12">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Complexity</th></tr></thead><tbody>
<tr><td>Worst</td><td>$O(n^2) $</td></tr>
<tr><td>Best</td><td>$O(n + k) $</td></tr>
<tr><td>Average</td><td>$O(n + k) $</td></tr>
<tr><td>Worst space</td><td>$O(n + k) $ auxiliary</td></tr>
</tbody></table>
</div>
<blockquote>
<p>$k $ = 桶子的數量（number of buckets）
$n $ = 資料筆數</p>
</blockquote>
<h3 id="worst-case"><a class="header" href="#worst-case">Worst case</a></h3>
<p>Bucket sort 是一個分配式排序法，對資料分佈有既定的預期：「<strong>所有元素平均分佈在每個 bucket 的區間內</strong>」。可想而知，最差的狀況是所有元素都聚集（clustering）在同一個 bucket 中，整個 bucket sort 的會退化成單一一個 inner sort 的複雜度。而桶內排序通常選用 insertion sort（最差 $O(n^2) $），所以最差的時間複雜度為「 $O(n^2) $」。</p>
<h3 id="best-case"><a class="header" href="#best-case">Best case</a></h3>
<p>最佳的狀況則是完全符合預期的平均分佈，一個蘿蔔一個坑，每個桶內排序的最佳時間複雜度為 $O(n / k) $，再乘上桶子總數 $k $，僅需 $O(k \cdot (n / k)) = O(n) $。計算結果看起來非常合理，但實際上最佳時間複雜度為 $O(n + k) $，為什麼呢？</p>
<p>無庸置疑，桶內排序最佳時間複雜度為 $O(n / k) $，但別忘了這是省略常數項過後式子，進行符號運算時，較精確的表達是 $c_0 O(n / k) + c_1 $，對於實作層面的常數 $c_0 $ 和 $c_1 $ 則予以保留。</p>
<p>當我們乘上 $k $，試著算出總運算量時，</p>
<p>$$k \cdot (c_0(n / k) + c_1) $$</p>
<p>會得到：</p>
<p>$$ c_0n + c_1k $$</p>
<p>可以得知，整個計算與 $k $ 有關，所以需要耗時 $O(n + k) $。</p>
<p>撇開數學，我們從 pseudo code 來看。最佳情況下，將所有元素蒐集回陣列的步驟（Gather）如下：</p>
<pre><code>for (each bucket b in all k buckets)
  for (each element x in b)
    append x to the array
</code></pre>
<p>最外層的迴圈依桶子數 $k $ 而定，至少需要執行 $k $ 次，複雜度為 $O(k) $。內層的迴圈則是每個桶內的元素都會執行，而我們的資料時均勻分布，因此執行時間與元素總數 $n $ 相關，為 $O(n) $。兩者加起來就是我們所說的 $O(n + k) $ 的最佳複雜度。</p>
<p><strong>那 $k $ 究竟會是多少，影響會比 $n $ 大嗎？</strong></p>
<p>端看桶子總數而定，若桶子總數很大，比元素個數 $n $ 大得多，則桶子總數對執行時間的影響恐較劇烈，就算大多數為空桶子，仍須挨家挨戶查看是否需要執行桶內排序。</p>
<h3 id="space-complexity-3"><a class="header" href="#space-complexity-3">Space Complexity</a></h3>
<p>Bucket sort 須額外建立 $k $ 個桶子，每個桶子需要配置長度為 $n $ 的 array，因此空間複雜度為 $O(n \cdot k) $。如果以 dynamic array 實作 bucket，並考慮平攤分析（Amortized analysis），則空間複雜度降至 $O(n + k) $，這也是大多數人接受的分析結果，畢竟不會有人無聊到預先配置 $n \cdot k $ 個 empty bucket。</p>
<h2 id="實作-12"><a class="header" href="#實作-12">實作</a></h2>
<h3 id="bucket"><a class="header" href="#bucket">Bucket</a></h3>
<p>Bucket sort 有許多種各異的實作法，差異最大之處就是桶子 bucket 這部分。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Bucket to store elements.
struct Bucket&lt;H, T&gt; {
    hash: H,
    values: Vec&lt;T&gt;,
}

impl&lt;H, T&gt; Bucket&lt;H, T&gt; {
    /// Create a new bucket and insert its first value.
    ///
    /// * `hash` - Hash value generated by hasher param of `bucket_sort`.
    /// * `value` - Value to be put in the bucket.
    pub fn new(hash: H, value: T) -&gt; Bucket&lt;H, T&gt; {
        Bucket {
            hash: hash,
            values: vec![value],
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>這裡的桶子實作兩個 struct fields：</p>
<ul>
<li><code>values</code>：使用 <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec</code></a> 儲存對應範圍內的元素</li>
<li><code>hash</code>：Bucket Sort 主函式有一個 <code>hasher</code> 函式，會計算出對應各個桶子的雜湊值，因此要確保桶子的雜湊值有唯一性。</li>
</ul>
<h3 id="sorting"><a class="header" href="#sorting">Sorting</a></h3>
<p>接下來就是排序主函式。依照慣例，先看看函式的宣告（function signature）。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn bucket_sort&lt;H, F, T&gt;(arr: &amp;mut [T], hasher: F)
    where H: Ord,
          F: Fn(&amp;T) -&gt; H,
          T: Ord + Clone,
<span class="boring">}</span></code></pre></pre>
<p>這個 <code>bucket_sort</code> 函式使用了不少泛型：</p>
<ul>
<li><code>H</code>：<code>hasher</code> 函式的回傳型別，用來辨識不同的桶子。</li>
<li><code>F</code>：<code>hasher</code> 函式自身，只需要一個參數 <code>&amp;T</code>，回傳一個 <code>H</code>。</li>
<li><code>T</code>：欲排序資料的型別。</li>
</ul>
<p>函式自身稍微複雜一點，但仍不脫離<a href="sorting/bucket_sort/index.html#%E6%AD%A5%E9%A9%9F">四步驟</a>：Create buckets、Scatter、Inner sort，還有 Gather。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn bucket_sort() {
    // ...

    // 1. Create buckets.
    let mut buckets: Vec&lt;Bucket&lt;H, T&gt;&gt; = Vec::new();

    // 2. Scatter
    for value in arr.iter() {
        let hash = hasher(&amp;value); // 2.1.

        let value = value.clone();
        // 2.2.
        match buckets.binary_search_by(|bucket| bucket.hash.cmp(&amp;hash)) {
            // If exists, push the value to the bucket.
            Ok(index) =&gt; buckets[index].values.push(value),
            // If none, create and new bucket and insert value in.
            Err(index) =&gt; buckets.insert(index, Bucket::new(hash, value)),
        }
    }

    // 3. Inner sort and gather
    let ret = buckets.into_iter().flat_map(|mut bucket| {
        bucket.values.sort(); // 3.1.
        bucket.values
    }).collect::&lt;Vec&lt;T&gt;&gt;();   // 3.2.

    arr.clone_from_slice(&amp;ret); // 4 Copy to original array
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>一般來說，第一步會配置完所有桶子，但這裡實作僅建立儲存桶子們的容器 <code>buckets</code>，這是由於實作了 <code>hasher</code> 函式，元素對應桶子的邏輯交由外部決定，因此桶子不需事先配置，而是交給第二步驟時 <strong>on-the-fly</strong> 建立。</li>
<li>疊代輸入的 <code>arr</code>，將元素散佈到桶子中。
<ol>
<li>使用元素值 <code>value</code> 取得雜湊值。</li>
<li>從一堆桶子內 <code>buckets</code> 尋找對應雜湊值的桶子，如有對應桶子，則將待排序元素插入桶中；若無對應桶子，則馬上建立桶子，並插入待排序元素。</li>
</ol>
</li>
<li>由於桶子們 <code>buckets</code> 是一個二維陣列集合，我們使用 <code>flat_map</code> 將之壓平。
<ol>
<li>使用 Rust 內建 sort（Timsort 的變形）作為我們 inner sort 的實作，將桶內所有元素排好序</li>
<li>別忘了 Rust 的 Iterator 很 lazy，記得要使用 <code>collect</code> 蒐集 iterator 實作後的結果。</li>
</ol>
</li>
<li>由於要模擬 in-place 原地排序法的特性，將排序好的資料再次拷貝到 <code>arr</code> 上。這也是為什麼函式元素泛型 <code>T</code> 需要 <code>Clone</code> trait 的原因了。</li>
</ol>
<p>有關於步驟 2.2.，這部分可以用 <code>HashMap</code> 的變形 <a href="https://github.com/bluss/indexmap">IndexMap</a>（一個保存插入順序的有序 HashMap）保存雜湊值對應桶子的資訊，使得外界更容易依雜湊值找到桶子。但為了保持範例程式的簡潔，決定不引入第三方的 crate（Rust 語言第三方模組的代稱），且 <code>binary_search_by</code> 的複雜度為 $O(\log n) $，對 Bucket sort 最差複雜度並無影響。</p>
<h2 id="參考資料-13"><a class="header" href="#參考資料-13">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Bucket_sort">Wiki: Bucket sort</a></li>
<li><a href="https://en.wikipedia.org/wiki/Amortized_analysis">Wiki: Amortized analysis</a></li>
<li><a href="https://stackoverflow.com/questions/7311415">How is the complexity of bucket sort is O(n+k) if we implement buckets using linked lists?</a></li>
<li><a href="https://codereview.stackexchange.com/questions/145113/bucket-sort-in-rust">Bucket sort in Rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基數排序-radix-sort"><a class="header" href="#基數排序-radix-sort">基數排序 Radix sort</a></h1>
<p>如果你對 <a href="sorting/radix_sort/../counting_sort">Counting sort</a> 與 <a href="sorting/radix_sort/../bucket_sort">Bucket sort</a> 有認識，應該知道這兩個排序都能突破比較排序法複雜度 $O(n \log n) $ 限制的特殊排序法。<a href="https://en.wikipedia.org/wiki/Radix_sort">Radix sort</a> 同樣是個特殊的<a href="https://en.wikipedia.org/wiki/Integer_sorting">整數排序法</a>，效能同樣可達突破限制。差別在於，前兩者僅依據一個鍵值排序，而 Radix sort 則是依據多個鍵值排序。</p>
<p>舉例來說，欲排序一群範圍在 0 - 999 的整數，若以 Counting sort 排序，則需建立一個「1000 元素的陣列」來計算每個整數的出現次數；若使用以 10 為基數的 Radix sort，則僅需以個位數、十位數、百位數作為鍵值分別排序三次。通常 Radix sort 的排序副程式（Sorting subroutine）會選用 Counting sort 或 Bucket sort，而以 10 為基數的鍵值範圍僅 0 - 9，這種小範圍整數非常適合 Counting sort 作為排序副程式，節省了配置 <code>int arr[1000]</code> 的 count array 的時空間。</p>
<p>Radix sort 基本特性如下：</p>
<ul>
<li><strong>整數排序法</strong>：以整數作為排序的鍵值。</li>
<li><strong>分配式排序法</strong>：不透過兩兩比較，而是分析鍵值分佈來排序。特定情況下可達線性執行時間。</li>
<li><strong>穩定性</strong>：採用 LSD 的 Radix sort 屬穩定排序法（Stable sort）；透過優化，採用 MSD 也可以是穩定排序法。</li>
</ul>
<h2 id="步驟-12"><a class="header" href="#步驟-12">步驟</a></h2>
<p>常見的 Radix sort 依據整數的每個位數來排序，依照位數排序的先後順序，可分為兩種：</p>
<ul>
<li><strong>Least significant digit (LSD)</strong>：從最低有效鍵值開始排序（最小位數排到大）。</li>
<li><strong>Most significant digit (MSD)</strong>：從最高有效鍵值開始排序（最大位數排到小）。</li>
</ul>
<p>簡單的 LSD Radix sort 步驟如下：</p>
<ol>
<li><strong>LSD of each key</strong>：取得每個資料鍵值的最小位數（LSD）。</li>
<li><strong>Sorting subroutine</strong>：依據該位數大小排序資料。</li>
<li><strong>Repeating</strong>：取得下一個有效位數，並重複步驟二，至最大位數（MSD）為止。</li>
</ol>
<p>而 MSD Radix sort 的步驟相似，但取得資料鍵值的方向相反。</p>
<ol>
<li><strong>MSD of each key</strong>：取得每個資料鍵值的最大位數（MSD）。</li>
<li><strong>Sorting subroutine</strong>：依據該位數大小排序資料。</li>
<li><strong>Repeating</strong>：取得下一個有效位數，並重複步驟二，至最小位數（LSD）為止。</li>
</ol>
<blockquote>
<p>由於 MSD Radix sort 先排序最大位數，會出現 <strong>8 &gt; 126</strong> 的結果，這種順序通常稱為 <a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical order</a>，有如字典一般，越前面的字母排序權重越重，也因此，基本版的 MSD Radix sort 並非穩定排序法。</p>
</blockquote>
<h2 id="說明-11"><a class="header" href="#說明-11">說明</a></h2>
<p>我們選用 LSD Radix sort 示範，並且為了增加可讀性，將基數設為 10。需注意在現實場景中，有時使用 bytes 作為基數可能更適合。</p>
<p>待排序的數列如下。</p>
<pre><code>[170, 45, 75, 90, 802, 2, 24, 66]
</code></pre>
<blockquote>
<p>Radix sort 的排序副程式，通常選用 counting sort 或 bucket sort，因此，開始排序前，需建立供其使用的 buckets（或 count array）。這屬於其他排序法的範疇，有興趣可看 <a href="sorting/radix_sort/../counting_sort">Counting sort</a> 或 <a href="sorting/radix_sort/../bucket_sort">Bucket sort</a>。</p>
</blockquote>
<p>首先，從最小位數開始排序。
注意，同樣鍵值的資料，相對位置不會改變（穩定排序）。</p>
<pre><code>   0   5   5   0    2  2   4   6
   _   _   _   _    _  _   _   _
[170, 45, 75, 90, 802, 2, 24, 66]

sort by rightmost digit --&gt;

   0   0    2  2   4   5   5   6
   _   _    _  _   _   _   _   _
[170, 90, 802, 2, 24, 45, 75, 66]
</code></pre>
<p>再來，對下一個位數排序資料。位數不足的資料，予以補 0。</p>
<pre><code>  7   9    0   0  2   4   7   6
  _   _    _      _   _   _   _
[170, 90, 802, 2, 24, 45, 75, 66]

sort by next digit --&gt;

  0   0  2   4   6    7   7   9
  _      _   _   _    _   _   _
[802, 2, 24, 45, 66, 170, 75, 90]
</code></pre>
<p>最終，對最後一個位數進行排序。大功告成！</p>
<pre><code> 8    0  0   0   0   1    0   0
 _                   _
[802, 2, 24, 45, 66, 170, 75, 90]

sort by leftmost digit --&gt;

 0  0   0   0   0   0   1    8
                        _    _
[2, 24, 45, 66, 75, 90, 170, 802]
</code></pre>
<h2 id="效能-13"><a class="header" href="#效能-13">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Complexity</th></tr></thead><tbody>
<tr><td>Worst</td><td>$O(dn) $</td></tr>
<tr><td>Best</td><td>$O(dn) $</td></tr>
<tr><td>Average</td><td>$O(dn) $</td></tr>
<tr><td>Worst space</td><td>$O(d + n) $ auxiliary</td></tr>
</tbody></table>
</div>
<blockquote>
<p>$n $：資料筆數。<br />
$d $：number of digit，資料中最多有幾個位數（或鍵值）。<br />
$k $：基數，就是一個位數最多有幾種可能的值。</p>
</blockquote>
<h3 id="time-complexity-4"><a class="header" href="#time-complexity-4">Time complexity</a></h3>
<p>欲分析 Radix sort 的時間複雜度，我們可以逐一擊破，先從排序副程式開始分析。</p>
<p>Radix sort 的 subroutine 通常採用 Counting sort 或 Bucket sort，因此每個 subroutine 的複雜度為 $O(n + k) $， $k $ 為 key 的範圍，以 10 為基數，就是 0 - 9 之間 $k = 10 $。</p>
<p>再來，我們分析整個主程式，Radix sort 每個位數各需排序一次，若最多位數的資料有 $d $ 位數，時間複雜度需乘上 $d $，為 $O(d (n + k)) $，那這個 $k $ 是否可以捨去呢？</p>
<p>分析 Counting sort 或 Bucket sort 時，範圍 $k $ 會隨輸入資料而變化，若 $k $ 過大，對複雜度的影響甚至會超過 $n $，因此分析複雜度時無法將 $k $ 捨去。而在 Radix sort， $k $ 通常為一個已知的常數，例如以 bytes 為基數 $k = 8 $， $k $ 可以捨去。最後可得 Radix sort 的時間複雜度為 $O(d \cdot n) $。</p>
<h3 id="space-complexity-4"><a class="header" href="#space-complexity-4">Space complexity</a></h3>
<p>Radix sort 的空間複雜度同樣取決於排序副程式，Counting sort 與 Bucket sort 的空間複雜度皆為 $O(n \cdot k) $。Radix sort 的 $k $ 是常數，予以捨去。再乘上 $d $ 個位數，最差的空間複雜度為 $O(d \cdot n) $。</p>
<h2 id="實作-13"><a class="header" href="#實作-13">實作</a></h2>
<p>這裡示範實作以 10 為基數，用來排序非負整數的 Radix sort。</p>
<p>首先，我們的排序副程式使用 Counting sort。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 0. Include counting sort.
use ::sorting::counting_sort;
<span class="boring">}</span></code></pre></pre>
<p>再來，就是 Radix sort 本體了。為了凸顯 Radix sort 的概念，簡化了函式參數數量，除去泛型宣告，並將基數選擇寫死在函式裡。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn radix_sort(arr: &amp;mut [i32]) {
    let radix = 10;             // 1
    let mut digit = 1;          // 2
    let max_value = arr         // 3
      .iter()
      .max()
      .unwrap_or(&amp;0)
      .clone();
    while digit &lt;= max_value {  // 4
        counting_sort(arr, 0, 9, |t| (t / digit % radix) as usize); // 5
        digit *= radix;         // 6
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>設定基數為 10。</li>
<li>設定一個旗標，記錄當前在排序哪一位數，1 表示從最小位數（個位數）開始。</li>
<li>先找到輸入資料的最大值，作為之後副程式迴圈結束的條件。尋找最大值的複雜度為 $O(n)$，因此不影響 Radix Sort 的複雜度。如果 <code>arr</code> 為空序列，則最大值設為 0，在第四步驟就會自動結束排序。</li>
<li>判斷當前排序的位數是否大於最大值，例如當前排序百分位，<code>digit</code> 為 <code>100</code>，而最大值 <code>x</code> 為 26，則不需再排序百分位。</li>
<li>使用 Counting sort 作為排序副程式，只需要有 0 - 9 十個桶子。而 <code>key</code> 參數則取出當前欲比較的位數。</li>
<li>位數乘上基數，移至下一個位數繼續比較。</li>
</ol>
<blockquote>
<p>小提醒：這是簡單又容易理解的實作，相對有許多額外的運算開銷（例如尋找最大值）。實務上，會在對資料有些了解才採用 Radix sort，因此實作並不會這麼 naive。</p>
</blockquote>
<h2 id="參考資料-14"><a class="header" href="#參考資料-14">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Radix_sort">Wiki: Radix sort</a></li>
<li><a href="https://www.cs.princeton.edu/~rs/AlgsDS07/18RadixSort.pdf">Princeton University DSA Course: Radix sort</a></li>
<li><a href="https://www.byvoid.com/zht/blog/sort-radix">ByVoid: 三種線性排序算法 計數排序、桶排序與基數排序</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="堆疊-stack"><a class="header" href="#堆疊-stack">堆疊 Stack</a></h1>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b4/Lifo_stack.png" alt="Stack - Wikipedia" /></p>
<p>堆疊是一個具有<em>後進先出</em> LIFO 特性的資料結構。以從 Wikipedia 借來的上圖為例，在第五張圖的狀況下，如果要取得 2，就必須先把 3、4、5 都退出堆疊。</p>
<p>堆疊的底部與頂部都是抽象的概念，頂部是資料被加入、移除、較為繁忙的那一端，底部即另一端。</p>
<p>堆疊的空間可能是有限的，亦即也有可能實現空間無限的堆疊。有鑑於有限空間的堆疊較為常見，我們選擇實作空間有限的堆疊。</p>
<p>堆疊 stack 有兩種實作方式：陣列 array 與鏈結串列 linked list，在此選擇以類似陣列的 Vector 實現。</p>
<blockquote>
<p>本次實作的程式碼置於 <a href="collections/stack//doc/rust_algorithm_club/collections/struct.Stack.html"><code>rust_algorithm_club::collections::Stack</code></a> API 文件中。</p>
</blockquote>
<h2 id="架構設計"><a class="header" href="#架構設計">架構設計</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Stack&lt;T&gt; {
    maxsize: usize,
    items: Vec&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><code>maxsize</code> 用於模擬堆疊空間有限的特性；<code>items</code> 負責保存加入堆疊的資料。</p>
<p>在此刻意將 <code>maxsize</code>、<code>items</code> 定義為 private member，避免外部直接存取。</p>
<h2 id="基本操作"><a class="header" href="#基本操作">基本操作</a></h2>
<ul>
<li><code>with_capacity</code>：定義一個空間有限的堆疊。</li>
<li><code>push</code>：將新資料加入資料結構。</li>
<li><code>pop</code>：將最新加入的資料移出資料結構。</li>
<li><code>size</code>：（選用）取得堆疊的大小。</li>
<li><code>peek</code>：（選用）在不將資料退出堆疊的情況下偷看最後加入堆疊的資料。</li>
</ul>
<h3 id="定義一個空間有限的堆疊"><a class="header" href="#定義一個空間有限的堆疊">定義一個空間有限的堆疊</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn with_capacity(maxsize: usize) -&gt; Self {
        Self {
            maxsize,
            items: Vec::with_capacity(maxsize),
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>初始化一個帶有預先分配空間 Vector 的堆疊。</p>
<p>⚠ 注意，即使預先分配了有限的空間，Rust 的 vector 在空間已滿的情況下會重新分配。假設一開始為 vector 分配了 10 單位的空間，在將第 11 筆資料插入 vector 前，vector 在記憶體的空間將被重新分配，以容納這第 11 筆資料。為了模擬堆疊空間有限的特性，我們會在 <code>push</code> 的操作動點手腳。</p>
<h3 id="將新資料加入資料結構"><a class="header" href="#將新資料加入資料結構">將新資料加入資料結構</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn push(&amp;mut self, item: T) -&gt; bool {
        if self.items.len() == self.maxsize {
            return false;
        }
        self.items.push(item);
        return true;
    }
<span class="boring">}</span></code></pre></pre>
<p>由於 <code>push</code> 操作會改變 <code>items</code>，因此需要堆疊的 mutable reference。由於 Rust 的 vector 有重新分配的特性，在將資料正式加入堆疊之前，必須先檢查堆疊初始化時設定的空間是否已經被塞滿了。如果結果為是，則拒絕將資料加入堆疊。</p>
<h3 id="將最新加入的資料移出資料結構"><a class="header" href="#將最新加入的資料移出資料結構">將最新加入的資料移出資料結構</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.items.pop()
    }
<span class="boring">}</span></code></pre></pre>
<p>堆疊有可能是空的，在此以 <code>Option</code> 表現這個情況。如果針對一個空堆疊進行 <code>pop</code> 操作，將會得到 <code>None</code>。</p>
<h3 id="取得堆疊的大小"><a class="header" href="#取得堆疊的大小">取得堆疊的大小</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn size(&amp;self) -&gt; usize {
        self.items.len()
    }
<span class="boring">}</span></code></pre></pre>
<p>一個空堆疊的大小是 0，加入一筆資料後是 1⋯⋯以此類推。注意容量 capcity 與大小 size 是兩個不同的概念。容量是這個堆疊最多可以塞下多少資料，大小則是這個堆疊已經被塞入了多少資料。由於 <code>push</code> 的檢查機制，堆疊的大小永遠不會超過 <code>maxsize</code>。</p>
<h3 id="在不將資料退出堆疊的情況下偷看最後加入堆疊的資料"><a class="header" href="#在不將資料退出堆疊的情況下偷看最後加入堆疊的資料">在不將資料退出堆疊的情況下偷看最後加入堆疊的資料</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.items.last()
    }
<span class="boring">}</span></code></pre></pre>
<p>與 <code>pop</code> 操作類似，但不會對堆疊造成任何影響。如果偷看的是一個空堆疊，會得到 <code>None</code>。</p>
<h2 id="效能-14"><a class="header" href="#效能-14">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Best Complexity</th><th>Worst Complexity</th></tr></thead><tbody>
<tr><td>push (insert)</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>pop (delete)</td><td>O(1)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p>無論堆疊大小如何變化，<code>push</code> 與 <code>pop</code> 的效能都不會被影響。</p>
<h2 id="參考資料-15"><a class="header" href="#參考資料-15">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">Stack (abstract data type)
</a></li>
<li><a href="http://bigocheatsheet.com/">Big-O Algorithm Complexity Cheat Sheet</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="佇列-queue"><a class="header" href="#佇列-queue">佇列 Queue</a></h1>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/52/Data_Queue.svg/450px-Data_Queue.svg.png" alt="Queue - Wiki" /></p>
<p>佇列是一個具有<em>先進先出</em> FIFO 特性的資料結構。從 Wikipedia 上的圖為例，一個資料從左邊進入佇列並從右邊離開，最先進入佇列的資料會最先被取出。</p>
<p>佇列常見實作方式有：陣列 array、鏈結串列 linked list。為了使概念容易理解，我們選擇以類似陣列的 Vector 實作。</p>
<blockquote>
<p>本次實作的程式碼置於 <a href="collections/queue//doc/rust_algorithm_club/collections/struct.Queue.html"><code>rust_algorithm_club::collections::Queue</code></a> API 文件中。</p>
</blockquote>
<h2 id="架構設計-1"><a class="header" href="#架構設計-1">架構設計</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Queue&lt;T&gt; {
    items: Vec&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>以 <code>items</code> 保存加入佇列的資料。大部分用陣列實作的佇列可能會有 <code>front</code> 和 <code>rear</code> 兩個欄位負責保存指向佇列開頭和尾端的索引，作為佇列新增刪除資料的依據，但是透過 Rust 的 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>std::vec::Vec</code></a>（線形動態成長的陣列容器），我們可以直接取得佇列第一以及最後一筆資料，所以這邊實作忽略這兩個欄位。</p>
<h2 id="基本操作-1"><a class="header" href="#基本操作-1">基本操作</a></h2>
<ul>
<li><code>enqueue</code>：將新資料加入佇列</li>
<li><code>dequeue</code>：將最先放入的資料移出佇列</li>
<li><code>peek</code>：在不將資料移出佇列的情況下取得最先放入的資料</li>
<li><code>size</code>：取得佇列大小</li>
</ul>
<h3 id="定義佇列"><a class="header" href="#定義佇列">定義佇列</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn new() -&gt; Self {
        Self { items: Vec::new() }
    }
<span class="boring">}</span></code></pre></pre>
<p>初始化具有 <code>Vec</code> 的佇列。</p>
<h3 id="將新資料加入佇列"><a class="header" href="#將新資料加入佇列">將新資料加入佇列</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn enqueue(&amp;mut self, item: T) {
        self.items.push(item);
    }
<span class="boring">}</span></code></pre></pre>
<p>由於 <code>enqueue</code> 會改變 <code>items</code>，因此需要佇列的 mutable reference。再來，我們沒有限制佇列大小，全由 Rust 的 <code>Vec</code> 自行分配空間，將新資料放到 <code>items</code> 的最後端。</p>
<h3 id="將最先放入的資料移出佇列"><a class="header" href="#將最先放入的資料移出佇列">將最先放入的資料移出佇列</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn dequeue(&amp;mut self) -&gt; Option&lt;T&gt; {
        match self.items.is_empty() {
            false =&gt; Some(self.items.remove(0)),
            true =&gt; None,
        }
    }
<span class="boring">}</span></code></pre></pre>
<p><code>items</code> 有可能是空的，在移出資料之前需要檢查，然後移出 index 為零的資料，也就是最先放入的資料。</p>
<h3 id="取得佇列大小"><a class="header" href="#取得佇列大小">取得佇列大小</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn size(&amp;self) -&gt; usize {
        self.items.len()
    }
<span class="boring">}</span></code></pre></pre>
<p>取得 <code>items</code> 的大小。</p>
<h3 id="不改變佇列的情況下取得最先放入的資料"><a class="header" href="#不改變佇列的情況下取得最先放入的資料">不改變佇列的情況下，取得最先放入的資料</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.items.first()
    }
<span class="boring">}</span></code></pre></pre>
<p>這裡的作法很單純，就是呼叫 <code>Vec</code> 底層 <a href="http://doc.rust-lang.org/std/primitive.slice.html#method.first"><code>slice::first</code></a>，回傳一個 <code>Option&lt;T&gt;</code>，不會影響到底層的
<code>Vec</code> 的內容。</p>
<h2 id="效能-15"><a class="header" href="#效能-15">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Best Complexity</th><th>Worst Complexity</th></tr></thead><tbody>
<tr><td>enqueue (insert)</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>dequeue (delete)</td><td>O(n)*</td><td>O(n)*</td></tr>
</tbody></table>
</div>
<p>*：注意，一般來說 <code>dequeue</code> 會選用 <code>O(1)</code> 的實作方式，這裡直接呼叫 <a href="http://doc.rust-lang.org/std/vec/struct.Vec.html#method.remove"><code>Vec::remove</code></a> 會導致整個 <code>Vec&lt;T&gt;</code> 的元素向前位移一個，是較耗費計算資源的 <code>O(n)</code> 操作。</p>
<p>我們可以選用其他方式實作，例如用額外指標紀錄當前 head 所在位置的<a href="collections/queue/../deque/">雙端佇列 Deque</a>，或是使用<a href="collections/queue/../singly_linked_list/">單向鏈結串列 Singly linked list</a> 實作，都能達到 <code>O(1)</code> 的時間複雜度。</p>
<h2 id="參考資料-16"><a class="header" href="#參考資料-16">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">Queue (abstract data type)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="雙端佇列-deque"><a class="header" href="#雙端佇列-deque">雙端佇列 Deque</a></h1>
<p>雙端佇列（double-ended queue，通常縮寫為 deque）是一般化（generalize）的<a href="collections/deque/../queue">佇列</a>或<a href="collections/deque/../stack">堆疊</a>。比起佇列只能「先進先出 FIFO」，以及堆疊只有「後進先出 LIFO」，雙端佇列可以從最前端或最末端任意方向，在常數時間複雜度內增刪元素，更為方便。</p>
<p>雙端佇列常見用動態陣列或是鏈結串列實作，動態陣列的實作會因空間不夠，需要重新配置記憶體，但通常會支援隨機存取（random access）；鏈結串列的實作版本雖無法隨機存取，相對地增刪元素不需記憶體重配置。</p>
<p>雙端佇列顯著的缺點是：無論以動態陣列或連結串列實作，基本款實作通常無法在 $O(k)$ 時間複雜度的情況下，選定範圍內 k 個元素並取得單一切片（slice）。這肇因於動態陣列的實作通常內部儲存空間經過多次增刪，空間利用會不連續；而用鏈結串列實作者，則因不支援隨機存取而無法達到相應的複雜度。</p>
<blockquote>
<p>本次實作的程式碼置於在 <a href="collections/deque//doc/rust_algorithm_club/collections/struct.Deque.html"><code>rust_algorithm_club::collections::Deque</code></a> API 文件中。</p>
</blockquote>
<h2 id="架構設計-2"><a class="header" href="#架構設計-2">架構設計</a></h2>
<p>雙端佇列有個實作重點：可在<strong>常數時間</strong>從頭尾兩端增刪元素。在資料結構設計上，會儲存分別指向頭尾的兩個指標，長相可能如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Deque {
    head: usize,
    tail: usize,
    storage: SomeStorageType,
}
<span class="boring">}</span></code></pre></pre>
<p>第一直覺肯定是選用<a href="collections/deque/../doubly_linked_list">雙向鏈結串列</a>可以雙向增刪節點的特性，作為解決方案。不過這裡我們採用動態陣列實作，更精確來說，底層儲存容器同樣是有兩個分別指向頭尾的指標的「環形緩衝區（Ring buffer）」。</p>
<h3 id="環形緩衝區"><a class="header" href="#環形緩衝區">環形緩衝區</a></h3>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/Circular_buffer.svg/240px-Circular_buffer.svg.png" alt="" /></p>
<p><a href="https://en.wikipedia.org/wiki/Circular_buffer">環形緩衝區（Ring buffer）</a> 是一個長度大小固定的緩衝區，可以視為頭尾相連的記憶體區塊，上圖雖以環狀呈現，但在計算機架構中儲存方式通常是線性陣列，再搭配指向頭端的 <code>head</code> 與指向尾端的 <code>tail</code> 兩個指標構成。</p>
<p>環形緩衝區有分兩種，一種是有循環的，緩衝區寫滿了就覆蓋尾端舊的資料，另一種是不會循環，緩衝區會放滿的，後者就是本次實作會用到的，以下將來探討：</p>
<ul>
<li>如何表示環形緩衝區為空</li>
<li>如何表示環形緩衝區已滿</li>
<li>環形緩衝區如何增加元素</li>
</ul>
<p>這節以 ASCII chart 表示之。</p>
<ul>
<li><code>h</code>: head</li>
<li><code>t</code>: tail</li>
<li><code>x</code>: no data</li>
<li><code>[number]</code>: has data</li>
</ul>
<p>下面一個容量為 8，尚未有任何元素存入的環形緩衝區，這裡觀察到，若 head 與 tail 指向的儲存單元相同，換句話說<strong>兩者索引值相同，則緩衝區為空</strong>。</p>
<pre><code>scenario: empty buffer

h
t
---------------
x x x x x x x x
---------------
</code></pre>
<p>再來，從頭端增加一個元素，此時 head 指向的儲存單元會存入元素，並且 head 索引加一。</p>
<pre><code>scenario: add one data onto head

t h
---------------
1 x x x x x x x
---------------
</code></pre>
<p>我們再連續加幾個元素，可以觀察到，head 最終指向的儲存單元永遠為空：</p>
<pre><code>scenario: add more data onto head

t   h
---------------
1 2 x x x x x x
---------------

t     h
---------------
1 2 3 x x x x x
---------------

t       h
---------------
1 2 3 4 x x x x
---------------
</code></pre>
<p>再來，我們從尾端增加元素，首先 tail 減一，並在移動過後的 tail 指向的儲存單元放入元素。因為 tail 原本為 0，減一之後為 -1，但索引不該有 -1，所以我們採取類似環繞算術運算（wrapping arithmetic operation）處理<a href="https://en.wikipedia.org/wiki/Integer_overflow">整數溢位</a>，因此 tail 索引從 0 變成 7（總共 8 個儲存單元）。</p>
<pre><code>scenario: add data onto tail

        h     t
---------------
1 2 3 4 x x x 5
---------------

</code></pre>
<blockquote>
<p>日常生活中，環繞算術運算可見於汽車儀錶板或是電錶，9999 轉過頭後會自動變成 0000，可以想像成在萬分位進位了，但我們看不到。上述減一也可以想像二進位退一位，但我們看不到，所以從 <code>0b000</code>（0）變成了 <code>0b111</code>（7）。</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/5/53/Odometer_rollover.jpg" width="300px">
</blockquote>
<p>我們從尾端加更多資料到緩衝區：</p>
<pre><code>scenario: add more data onto tail

        h   t
---------------
1 2 3 4 x x 6 5
---------------

        h t
---------------
1 2 3 4 x 7 6 5 --&gt; full
---------------
</code></pre>
<p>欸，怎麼加到第七個就停了？</p>
<p>由於目前僅探討<strong>不循環</strong>的環形緩衝區，已經規範 <code>head = tail</code> 代表緩衝區為空，如果貿然加上第八個元素，就無法分辨緩衝區是空是滿，恐導致轉盈為空。所以當緩衝區容量減去元素個數為 1 時，換句話說就是當剩餘最後一個空儲存單元時，表示該緩衝區已滿，不能再增加元素。由此推論環形緩衝區永遠會剩下一個沒使用的儲存單元。</p>
<p>至此，環形緩衝區的特性很符合雙端佇列的需求，總結一下：</p>
<ol>
<li><code>head = tail</code> 時，表示緩衝區為空。</li>
<li>容量僅剩一個儲存單元時，表示緩衝區已滿。</li>
<li>head 永遠指向一個空的儲存單元。</li>
<li>邏輯索引的映射會利用環繞算術運算配合<a href="https://en.wikipedia.org/wiki/Modulo_operation">模除運算</a>，將索引值限制在緩衝區範圍內。</li>
</ol>
<p>第四點很難懂齁？免驚，下面實作範例「<a href="collections/deque/index.html#%E9%82%8F%E8%BC%AF%E7%B4%A2%E5%BC%95%E6%98%A0%E5%B0%84">邏輯索引映射</a>」段落就會解釋給你聽！</p>
<h3 id="手動配置記憶體"><a class="header" href="#手動配置記憶體">手動配置記憶體</a></h3>
<p>這一段，我們將為環形緩衝區打造屬於它自己的底層儲存空間。你可能想問，既然環形緩衝區是一個固定長度的陣列，為什麼不直接利用 Rust 標準函式庫的 <code>Vec</code> 呢？因為 <a href="https://doc.rust-lang.org/1.49.0/alloc/vec/struct.Vec.html#capacity-and-reallocation"><code>Vec</code> 的容量和記憶體配置</a>屬於實作細節，雖然目前是滿了才擴充容量重新配置空間，但難保未來改變，為了更細緻控制記憶體，決定弄髒手，自行配置記憶體。</p>
<blockquote>
<p>⚠️ 以下範例有 <code>unsafe</code> 程式碼，未經審計，請謹慎使用。</p>
</blockquote>
<p>首先，宣告一個 <code>RawVec</code> 結構體，儲存了兩個欄位：</p>
<ul>
<li><code>ptr</code>：指向陣列最前端的指標，因為底層陣列會變化，所以是可變裸指標 <a href="https://doc.rust-lang.org/1.49.0/std/primitive.pointer.html"><code>*mut T</code></a>。</li>
<li><code>cap</code>：當前 <code>RawVec</code> 的容量。注意，容量需永遠大於等於元數個數，否則會發生<a href="https://en.wikipedia.org/wiki/Buffer_overflow">緩衝區溢位</a>。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RawVec&lt;T&gt; {
    ptr: *mut T,
    cap: usize,
}
<span class="boring">}</span></code></pre></pre>
<p>接下來，我們要為 <code>RawVec</code> 實作三個方法，完成自我管理記憶體的偉大志向：</p>
<ul>
<li><code>with_capacity</code>：建立指定容量的 <code>RawVec</code>，會在堆疊上配置一塊記憶體。</li>
<li><code>try_grow</code>：嘗試將 <code>RawVec</code> 的容量加倍，會觸發記憶體的重新配置。</li>
<li><code>drop</code>：實作 <a href="https://doc.rust-lang.org/1.49.0/core/ops/trait.Drop.html"><code>Drop</code></a> 特徵，會釋放在堆疊上手動配置的記憶體。</li>
</ul>
<p>先來看 <code>with_capacity</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; RawVec&lt;T&gt; {
    // ...
    pub fn with_capacity(cap: usize) -&gt; Self {
        let layout = Layout::array::&lt;T&gt;(cap).unwrap(); // 1

        // 2
        if layout.size() == 0 {
            // This is safe for zero sized types. However, be careful when facing
            // zero capacity layouts. It must be replaced with an actual pointer
            // before operations such as dereference or read/write.
            let ptr = ptr::NonNull::dangling().as_ptr(); // 3
            Self { ptr, cap: 0 }
        } else {
            // This is safe because it conforms to the [safety contracts][1].
            //
            // [1]: https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-1
            let ptr = unsafe { alloc(layout) }; // 4
            if ptr.is_null() {
                handle_alloc_error(layout);
            }
            Self {
                ptr: ptr.cast(),
                cap,
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>首先，我們先透過 <a href="https://doc.rust-lang.org/1.49.0/alloc/alloc/struct.Layout.html#method.array"><code>Layout::array</code></a> 取得給定長度給定型別的陣列的記憶體佈局，這個佈局包含<a href="https://en.wikipedia.org/wiki/Data_structure_alignment">記憶體對齊</a>（二的倍數的位元組）與佔用記憶體大小等資訊。</li>
<li>再來這個 <code>layout.size()</code> 條件式是因為 <a href="https://doc.rust-lang.org/1.49.0/alloc/alloc/fn.alloc.html"><code>alloc</code></a> 為 <code>unsafe</code> 函式，需遵守其安全條款：<a href="https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-1">不允許配置大小為零的空間</a>。因此，必須判斷實際上需要配置記憶體與否，有兩種情況不需配置：
<ul>
<li><code>T</code> 是 <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">Zero Sized Types（ZSTs）</a>，也就是不需要空間的型別。</li>
<li><code>cap</code> 為零，所以不需要容量。</li>
</ul>
</li>
<li>若記憶體佈局所佔空間大小為零，則配置一個 <a href="https://doc.rust-lang.org/1.49.0/core/ptr/struct.NonNull.html"><code>NonNull</code></a> 的迷途指標。
<ul>
<li>對 ZST 來說，<code>NonNull</code> 是安全的，ZST 的指標算術操作無論如何加減，都會指向原始的指標位址，所以上層可以零成本的抽象操作容器的各種方法，完全不需要配置額外記憶體區塊。</li>
<li>對非 ZST 但容量為零的記憶體佈局來說，<code>NonNull</code> 不會有危害但要非常小心，只有在容量大於 0 且內容有初始化時，才該允許指標算術，否則可能存取到未初始化的記憶體位址，進而引發未定義行為。</li>
</ul>
</li>
<li>很簡單地呼叫 <a href="https://doc.rust-lang.org/1.49.0/alloc/alloc/fn.alloc.html"><code>alloc</code></a> 讓 Rust 全域預設的配置器幹一塊空間資源來。因為 <code>alloc</code> 發生記憶體配置錯誤時會回傳空指標，所以這裡按照官方建議用 <code>handle_alloc_error</code> 捕捉這個行為，防止空指標被當作合法指標使用。</li>
</ol>
<blockquote>
<p>Rust 1.28 導入 <a href="https://doc.rust-lang.org/edition-guide/rust-2018/platform-and-target-support/global-allocators.html">Global allocators</a> 的功能，讓使用者使用 <a href="https://doc.rust-lang.org/1.49.0/std/alloc/trait.GlobalAlloc.html"><code>#[global_allocator]</code></a> 屬性，替標準函式庫註冊全域的記憶體配置器，也因此，上述的 <code>alloc</code>、<code>realloc</code>、<code>dealloc</code> 即將在 <a href="https://github.com/rust-lang/rust/issues/32838">allocator_api</a> 穩定後被取代。</p>
</blockquote>
<p>看完配置記憶體，來看如何手動釋放記憶體。Rust 的 <a href="https://doc.rust-lang.org/1.49.0/core/ops/trait.Drop.html"><code>Drop</code></a> 特徵有 <code>drop()</code> 方法，會在數值不需要時呼叫，類似其他語言的解構函式（destructor）。我們將釋放記憶體的邏輯放在 <code>RawVec::drop</code> 裡面，當 <code>RawVec</code> 不被需要時，就會協助我們釋放手動配置的記憶體。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Drop for RawVec&lt;T&gt; {
    /// Deallocates the underlying memory region by calculating the type layout
    /// and number of elements.
    ///
    /// This only drop the memory block allocated by `RawVec` itself but not
    /// dropping the contents. Callers need to drop the contents by themselves.
    fn drop(&amp;mut self) {
        let layout = Layout::array::&lt;T&gt;(self.cap).unwrap(); // 1
        if layout.size() &gt; 0 {
            // This is safe because it conforms to the [safety contracts][1].
            //
            // [1]: https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-2
            unsafe { dealloc(self.ptr.cast(), layout) }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>實作上，第一步取得當前記憶體佈局，並透過 <a href="https://doc.rust-lang.org/1.49.0/alloc/alloc/fn.dealloc.html"><code>dealloc</code></a> 配合指標來釋放記憶體。當然，ZST 或是容量為零的狀況並沒有配置記憶體，額外判斷無需釋放。</p>
<p>最後，來瞧瞧 <code>try_grow</code>，為了簡化實作，每次呼叫時，記憶體區塊就單純加倍。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; RawVec&lt;T&gt; {
    // ...
    pub fn try_grow(&amp;mut self) {
        if mem::size_of::&lt;T&gt;() == 0 {
            return; // 1
        }

        if self.cap == 0 {
            *self = Self::with_capacity(1); // 2
            return;
        }

        let old_layout = Layout::array::&lt;T&gt;(self.cap).unwrap(); // 3
        let new_cap = self.cap &lt;&lt; 1;
        let new_size = old_layout.size() * new_cap;
        // This is safe because it conforms to the [safety contracts][1].
        //
        // [1]: https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-4
        let ptr = unsafe { realloc(self.ptr.cast(), old_layout, new_size) };
        if ptr.is_null() {
            handle_alloc_error(old_layout);
        }
        // ...Old allocation is unusable and may be released from here at anytime.

        self.ptr = ptr.cast(); // 4
        self.cap = new_cap;
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>ZST 的空間不需加倍，直接返回。</li>
<li>原本空間容量為零的狀況，直接配置容量為一的空間。</li>
<li>準備 <code>realloc</code> 需要的參數：容量超過零的，取得舊的記憶體佈局，並乘上翻倍後的容量，算出新的空間大小。這讓之後呼叫 <code>realloc</code> 時符合其安全條款：合法指標、空間大於零、記憶體佈局為該區塊的舊佈局。</li>
<li>呼叫 <code>realloc</code> 之後，原先記憶體區塊可能被釋放，因此不該繼續用舊指標，此以新指標取代之。</li>
</ol>
<p>終於將手動配置記憶體的邏輯封裝在 <code>RawVec</code> 裡面，外部不需要弄髒手搞記憶體了！</p>
<h3 id="deque"><a class="header" href="#deque"><code>Deque</code></a></h3>
<p>有了 <code>RawVec</code>，現在可以將先前缺失的 <code>SomeStorageType</code> 補上，初始化的方法也異常單純。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Deque&lt;T&gt; {
    tail: usize,
    head: usize,
    ring_buf: RawVec&lt;T&gt;,
}

impl&lt;T&gt; Deque&lt;T&gt; {
    pub fn new() -&gt; Self {
        Self {
            tail: 0,
            head: 0,
            ring_buf: RawVec::with_capacity(DEFAULT_CAPACITY),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>至此，<code>Deque</code> 結構體的佈局設計告一段落，接下來就是各種方法實作。</p>
<h2 id="基本操作-2"><a class="header" href="#基本操作-2">基本操作</a></h2>
<p>身為一個雙端佇列，會有以下符合定義的基本操作：</p>
<ul>
<li><code>new</code>：初始化一個容器。</li>
<li><code>push_front</code>：在容器最前端新增一個元素。</li>
<li><code>push_back</code>：在容器最末端新增一個元素。</li>
<li><code>pop_front</code>：移除在容器最前端的元素。</li>
<li><code>pop_back</code>：移除在容器最末端的元素。</li>
</ul>
<p>另外為了提升方便性，也提供了一些方法：</p>
<ul>
<li><code>front</code>：查看容器最前端的元素。</li>
<li><code>back</code>：查看容器最末端的元素。</li>
<li><code>len</code>：檢查容器內的元素數目。</li>
<li><code>is_empty</code>：檢查容器內是否沒有任何元素。</li>
<li><code>iter</code>、<code>iter_mut</code>、<code>into_iter</code>：產生一個疊代容器內所有元素的疊代器。</li>
</ul>
<p>因為需要比較動態精細地控制記憶體，少不了一些內部方法：</p>
<ul>
<li><code>is_full</code>：檢查底層環形緩衝區是否滿載。</li>
<li><code>try_grow</code>：嘗試動態增加底層儲存空間。</li>
<li><code>wrapping_add</code>、<code>wrapping_sub</code>：確保邏輯索引的增減正確映射到底層實際索引位址。</li>
</ul>
<h3 id="邏輯索引映射"><a class="header" href="#邏輯索引映射">邏輯索引映射</a></h3>
<p><a href="collections/deque/index.html#%E7%92%B0%E5%BD%A2%E7%B7%A9%E8%A1%9D%E5%8D%80">前一段</a>提及環形緩衝區可以從頭尾增加元素，這一段來說明「如何封裝環形緩衝區內部的物理索引」，讓外部的邏輯索引可映射到內部已儲存合法數值的緩衝區位址。</p>
<p>再回來看容量為 8 的雙端佇列的例子，已進行一系列操作：</p>
<ol>
<li>push_back 1</li>
<li>push_back 2</li>
<li>push_back 3</li>
<li>push_back 4</li>
<li>push_front 5</li>
<li>push_front 6</li>
</ol>
<pre><code>        h   t
---------------
1 2 3 4 x x 6 5
---------------
</code></pre>
<p>如果我們要按照順序，從佇列的 tail 到 head 印出所有元素，應該從 tail 開始，逐一增加索引，依序 6 5 1 2 3 4 印出，我們畫上虛擬的元素對應位置：</p>
<pre><code>~: virtual element

        h   t --&gt;
-----------------------
1 2 3 4 x x 6 5 1 2 3 4
-----------------------
                ~ ~ ~ ~
</code></pre>
<p>顯而易見，虛擬元素對應的索引是 8、9、10、11，已經超過緩衝區的長度，可以利用<a href="https://en.wikipedia.org/wiki/Modulo_operation">模除運算</a>計算物理索引，將索引固定在一定長度內。目前緩衝區容量為 8，所以將索引全部
模除 8：</p>
<ul>
<li><code>8 % 8 = 0</code>：對應到 [0] 的元素 1</li>
<li><code>9 % 8 = 1</code>：對應到 [1] 的元素 2</li>
<li><code>10 % 8 = 2</code>：對應到 [2] 的元素 3</li>
<li><code>11 % 8 = 3</code>：對應到 [3] 的元素 4</li>
</ul>
<p>模除是直觀的作法，但還有更神奇的思路：位元運算（bitwise arithmetic）。只要拿 7 跟這些索引做 <code>&amp;</code> 位元 AND 運算，也能得到相同結果。</p>
<pre><code>       8        9       10       11 &lt;- Logical

  0b1000   0b1001   0b1010   0b1011
&amp; 0b0111   0b0111   0b0111   0b0111
-----------------------------------
  0b0000   0b0001   0b0010   0b0011
=      0        1        2        3 &lt;- Actual
</code></pre>
<p>這邊使用 7 有其意義：</p>
<ol>
<li>7 是 $2^3 - 1$，剛好 $2^n - 1$ 在是二進位制中全部位元都會是 1 ，任意數與 $2^n - 1$ 做位元 AND 運算，可以得到低位 n 位中有多少 1，同時捨棄大於 n 的位元。這個特性不偏不倚和模除的結果相同。</li>
<li>還記得環形緩衝區有個特性嗎：<strong>容量僅剩一個儲存單元時，表示緩衝區已滿</strong>。若能保證環形緩衝區的容量必為 $2^n$，當緩衝區滿時，元素個數定為 $2^n - 1$，完全符合前一點的特性。</li>
</ol>
<p>綜合以上，只需要保證緩衝區容量是 $2^n$，將邏輯索引映射到實際索引，只要將索引和實際可用容量（$2^n - 1$）做位元 AND 運算即可：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn wrap_index(index: usize, size: usize) -&gt; usize {
    debug_assert!(size.is_power_of_two());
    index &amp; (size - 1)
}
<span class="boring">}</span></code></pre></pre>
<p>接下來，就可以推出 <code>wrapping_add</code> 和 <code>wrapping_sub</code> 這兩支正確增減索引的方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Deque&lt;T&gt; {
    // ...
    fn wrapping_add(&amp;self, index: usize, addend: usize) -&gt; usize {
        wrap_index(index.wrapping_add(addend), self.cap())
    }

    fn wrapping_sub(&amp;self, index: usize, subtrahend: usize) -&gt; usize {
        wrap_index(index.wrapping_sub(subtrahend), self.cap())
    }

    fn cap(&amp;self) -&gt; usize {
        self.ring_buf.cap()
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>上面用環繞算術運算（wrapping arithmetic operation） 可以使開發更方便，例如遇上 index 0 而 subtrahend 1 時，巧妙避開 $0 - 1 = -1$ 但 <code>usize</code> 不能為負的限制，直接環繞回 <code>usize::MAX</code>。</p>
</blockquote>
<p>值得一提的是，在 <code>Deque::cap</code> 這個簡單的封裝上呼叫了 <code>RawVec::cap</code>，這是新增的方法，旨在提供 ZST 一個很大很大的虛擬容量，但同時保證是 2 的次方：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; RawVec&lt;T&gt; {
    // ...
    pub fn cap(&amp;self) -&gt; usize {
        if mem::size_of::&lt;T&gt;() == 0 {
            1usize &lt;&lt; (mem::size_of::&lt;usize&gt;() * 8 - 1)
        } else {
            self.cap
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="動態增加記憶體空間"><a class="header" href="#動態增加記憶體空間">動態增加記憶體空間</a></h3>
<p>前面提及環形緩衝區是長度固定的陣列，但雙端佇列若必須固定長度就太沒路用，直觀作法就是透過加倍 <code>RawVec</code> 容量，再繼續新增元素。這個想法沒錯，但會遇到一個問題：如何確保邏輯索引在記憶體加倍後依然正確映射到實際索引？這裡舉一個實際案例：</p>
<pre><code>Before:
         h   t
[o o o o x x o o]

Resize:
         h   t
[o o o o x x o o | x x x x x x x x]
</code></pre>
<p>同樣一個容量為 8 的佇列，觸發了記憶體重新配置，所以記憶體加倍，無奈今非昔比，現在的邏輯索引 tail 無法映射到實際索引，環形緩衝區的「環」已經斷掉。若我們繼續 <code>push_back</code> 往 head 添加元素，就會覆蓋掉 tail 和後面的元素。</p>
<pre><code>after 4 push_back:

overwritten: ⌀
newly added: _

             t h
[o o o o o o ⌀ ⌀ | x x x x x x x x]
         _ _ _ _
</code></pre>
<p>有鑑於此，需要修正將斷掉的環，最簡單的作法就是將緩衝區首個索引到 head 之前的索引這段記憶體空間，複製到新翻倍的空間上，讓 tail 在 head 前面，合法的記憶體區塊再次變得連續：</p>
<pre><code>Before:
         h   t
[o o o o x x o o]

Resize:
         h   t
[o o o o x x o o | x x x x x x x x]

Copy:
             t           h
[x x x x x x o o | o o o o x x x x]
 _ _ _ _           _ _ _ _
</code></pre>
<p>了解實作的目標後，先定義個容量已滿的方法暖暖身：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn is_full(&amp;self) -&gt; bool {
        self.cap() - self.len() == 1
    }
<span class="boring">}</span></code></pre></pre>
<p>然後是 <code>try_grow</code> 的實作：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn try_grow(&amp;mut self) {
        if self.is_full() {
            let old_cap = self.cap(); // 1
            self.ring_buf.try_grow(); // 2

            // 3
            if self.tail &gt; self.head {
                // The content of ring buffer won't overlapped, so it's safe to
                // call `copy_nonoverlapping`. It's also safe to advance the
                // pointer by `old_cap` since the buffer has been doubled.
                unsafe {
                    let src = self.ptr(); // 4-1
                    let dst = self.ptr().add(old_cap); // 4-2
                    ptr::copy_nonoverlapping(src, dst, self.head);
                }
                self.head += old_cap; // 5
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>將舊的容量存起來，因為當 <code>ring_buf</code> 容量翻倍後，<code>cap()</code> 返回的容量就會翻倍。</li>
<li>呼叫 <code>RawVec::try_grow()</code> 讓容量翻倍。</li>
<li>在 <code>tail</code> 大於 <code>head</code> 時，代表環在翻倍後會不連續，所以需要複製元素。</li>
<li>這裡用 <a href="https://doc.rust-lang.org/1.49.0/std/ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a> 進行位元複製，此函式語義上與 C 的 <a href="https://en.cppreference.com/w/c/string/byte/memcpy"><code>memcpy</code></a> 相同。
<ol>
<li>取得緩衝區首個索引的位址，作為複製的起始位址。</li>
<li>取擴增後部分的首個索引位址，作為複製的目標位址。</li>
<li>實際呼叫 <code>memcpy</code> ，因為 head 永遠比最後一個元素索引多 1，剛好可作為元素數目。</li>
</ol>
</li>
<li>被複製的元素位移了 <code>old_cap</code>，因此更新 <code>head</code> 映射到正確的 <code>head + old_cap</code>。</li>
</ol>
<p>我們完成了動態增加容量的方法的同時，也維持邏輯索引映射的正確性。</p>
<blockquote>
<p>這裡維持索引正確性有稍微簡化，更高效優美的解法請參考標準函式庫 <a href="https://github.com/rust-lang/rust/blob/a118ee2/library/alloc/src/collections/vec_deque/mod.rs#L405-L447"><code>VecDeque::handle_capacity_increase</code></a> 。</p>
</blockquote>
<h3 id="查看元素"><a class="header" href="#查看元素">查看元素</a></h3>
<p>查看首末兩段的元素非常簡單，不過由於涉及底層儲存空間的指標操作，所以需要寫 Unsafe Rust：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        if self.is_empty() {
            return None;
        }
        // This is safe because the offset is wrapped inside valid memory region.
        unsafe { Some(&amp;*self.ptr().add(self.tail)) }
    }

    pub fn back(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        if self.is_empty() {
            return None;
        }
        let head = self.wrapping_sub(self.head, 1);
        // This is safe because the offset is wrapped inside valid memory region.
        unsafe { Some(&amp;*self.ptr().add(head)) }
    }
<span class="boring">}</span></code></pre></pre>
<p>兩個函式都先判斷雙端佇列是否為空，再做指標位移運算，head - 1 是 <code>back</code> 的指標位移量，而 <code>front</code> 就直接回傳 tail 指向的值。其中 <code>&amp;*</code> 是常見的 Rust 模式，可視為<strong>將裸指標「升級」為更安全的引用型別</strong>，步驟如下：</p>
<ol>
<li>解引用裸指標，得到底下的裸數值。</li>
<li>建立一個安全的引用，指向裸數值。</li>
</ol>
<p>這裡再來品嚐 <code>is_empty</code> 和 <code>len</code> 的實作：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn is_empty(&amp;self) -&gt; bool {
        self.len() == 0
    }

    pub fn len(&amp;self) -&gt; usize {
        self.head.wrapping_sub(self.tail) &amp; (self.cap() - 1)
    }
<span class="boring">}</span></code></pre></pre>
<p><code>len</code> 用了環繞算術運算，讓 <code>head - tail</code> 能正確算出兩者的距離，並在用前面提及的「容量 - 1」的 $2^n - 1$ 做位元 AND 運算來捨棄高位。</p>
<h3 id="增刪元素"><a class="header" href="#增刪元素">增刪元素</a></h3>
<p>來看從頭尾刪除元素的 <code>pop_front</code> 和 <code>pop_back</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.is_empty() {
            return None; // 1
        }

        let tail = self.tail;
        self.tail = self.wrapping_add(self.tail, 1); // 2

        // This is safe because the offset is wrapped inside valid memory region.
        unsafe { Some(self.ptr().add(tail).read()) } // 3
    }

    pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.is_empty() {
            return None; // 1
        }

        self.head = self.wrapping_sub(self.head, 1); // 2

        // This is safe because the offset is wrapped inside valid memory region.
        unsafe { Some(self.ptr().add(self.head).read()) } // 3
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>同樣先判斷雙端佇列是否為空。</li>
<li>再來移動到下一個合法的索引上，會是 head - 1 或 tail + 1。</li>
<li>最後是指標位移再讀取，注意，雖然 <a href="https://doc.rust-lang.org/1.49.0/core/ptr/fn.read.html"><code>ptr::read</code></a> 會複製指標指向的值，但可視為所有權轉移到回傳值上了，這是因為倘若原始 <code>src</code> 指向的資料帶有其他指標，那麼繼續使用 <code>src</code> 就可能導致記憶體安全問題。</li>
</ol>
<p>再來看增加元素的 <code>push_front</code> 與 <code>push_back</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn push_front(&amp;mut self, elem: T) {
        self.try_grow(); // 1
        self.tail = self.wrapping_sub(self.tail, 1); // 2

        // This is safe because the offset is wrapped inside valid memory region.
        unsafe { self.ptr().add(self.tail).write(elem) } // 3
    }

    pub fn push_back(&amp;mut self, elem: T) {
        self.try_grow(); // 1
        let head = self.head;
        self.head = self.wrapping_add(self.head, 1); // 2

        // This is safe because the offset is wrapped inside valid memory region.
        unsafe { self.ptr().add(head).write(elem) } // 3
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>同樣先判斷雙端佇列是否為空。</li>
<li>再來移動到下一個合法的索引上，會是 head + 1 或 tail - 1。</li>
<li>最後是指標位移再寫入， <a href="https://doc.rust-lang.org/1.49.0/core/ptr/fn.write.html"><code>ptr::write</code></a> 不會觸發讀取或是 drop 裸指標指向的值，但使用上仍然要確認存取該位址是否合法。</li>
</ol>
<p>以上就是 <code>Deque</code>   基本操作方法，至此，剩下最後一步「<a href="collections/deque/index.html#drop">正確釋放記憶體</a>」，雙端佇列基本款就完成了。</p>
<h2 id="特徵"><a class="header" href="#特徵">特徵</a></h2>
<p>Rust 提供許多特徵（Trait），實作特徵可以讓資料結構更方便，更符合 Rust 社群的寫作慣例。</p>
<h3 id="drop"><a class="header" href="#drop"><code>Drop</code></a></h3>
<p>這是 <code>Deque</code> 最重要的特徵之一，也是完成 <code>Deque</code> 基本款的最後一個必要功能。<code>Drop</code> 會用來釋放儲存在 <code>Deque</code> 裡面元素的資源。實作是將所有元素 <code>pop_back</code> 出來，所有權轉移到 <code>drop</code> 函式內，函式本體執行結束後，就會自動呼叫該元素型別的 <code>drop</code> 並釋放資源。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Drop for Deque&lt;T&gt; {
    fn drop(&amp;mut self) {
        while let Some(_) = self.pop_back() {}
    }
}
<span class="boring">}</span></code></pre></pre>
<p>也許你會問「為什麼不在 <code>Deque.ring_buf</code> 的 <code>RawVec</code> 實作 <code>Drop</code> 來釋放其內容的資源？」主因是權責區分，<code>RawVec</code> 僅負責釋放它自行配置的堆疊記憶體，不清楚內容元素該如何釋放記憶體，例如內容可能是 <a href="https://en.wikipedia.org/wiki/Region-based_memory_management">Region-based memory management</a>，一起釋放效率更高，元素各別 <code>mem::drop</code> 反而拖累效率。</p>
<blockquote>
<p>事實上 <code>Deque::drop</code> 也能更高效，<a href="https://github.com/rust-lang/rust/blob/a118ee2/library/alloc/src/collections/vec_deque/mod.rs#L117-L139"><code>std::colletions::VecDeque::drop</code></a> 就是直接 drop 兩個指向切片（slice）的指標，而非每個元素各自處理，雖然最後可能殊途同歸，視編譯器最佳化程度而定。</p>
</blockquote>
<h3 id="iterator"><a class="header" href="#iterator"><code>Iterator</code></a></h3>
<p>身為容器型別，沒有疊代器簡直不能用，Rust 提供許多疊代器特徵供實作，其中 <a href="https://doc.rust-lang.org/1.49.0/core/iter/trait.Iterator.html"><code>Iterator</code></a> 特徵最為基礎且重要，實作 <code>Iterator</code> 特徵需求一個 <code>next</code> 方法，會不斷回傳下一個元素。任何實作 <code>Iterator</code> 特徵的型別，都可以放入 for 迴圈疊代。</p>
<p>而 Rust 常見的疊代器設計模式包含三個產生疊代器的方法：</p>
<ul>
<li><code>iter()</code>：慣例上回傳會產生不可變引用 <code>&amp;T</code> 的 <code>Iterator</code>。</li>
<li><code>iter_mut()</code>：慣例上回傳會產出可變引用 <code>&amp;mut T</code> 的 <code>Iterator</code>。</li>
<li><code>into_iter()</code>：慣例上回傳吃掉所有權 <code>T</code> 的 <code>Iterator</code> ，通常直接實作 <code>IntoIterator</code> 特徵即可，我們在<a href="collections/deque/index.html#intoiterator">下一段</a>介紹它。</li>
</ul>
<p>實作 <code>Iterator</code> 需要新的結構體，以儲存疊代的內部狀態：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Iter&lt;'a, T&gt; {
    head: usize,
    tail: usize,
    ring_buf: &amp;'a [T],
}

pub struct IterMut&lt;'a, T&gt; {
    head: usize,
    tail: usize,
    ring_buf: &amp;'a mut [T],
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>Iter</code>：由於定位 <code>Deque</code> 中有元素的合法記憶體區域需要 <code>head</code> 和 <code>tail</code>，因此儲存該兩者，並且儲存底層的環形緩衝區的切片引用，方便存取元素。</li>
<li><code>IterMut</code>：同 <code>Iter</code>，但改為儲存可變的切片引用。</li>
</ul>
<p>來看看 <code>Iter</code> 如何實作疊代器：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.tail == self.head {
            return None; // 1
        }
        let tail = self.tail; // 2
        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring_buf.len()); // 3
        self.ring_buf.get(tail) // 4
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>當 tail 等於 head 時，代表環形緩衝區為空，直接回傳 <code>None</code>。</li>
<li>tail 是 <code>Deque</code> 最前端，這裡先將當前的 tail 儲存起來。</li>
<li>再將 Iter 上的 tail 增加 1（不影響原始 Deque），下一次呼叫 <code>next</code> 就會取得下一個元素。</li>
<li>利用第二步儲存的當前 tail，配合 <code>slice::get</code> 直接回傳一個元素。</li>
</ol>
<p>再來處理 <code>IterMut::next</code>，直觀上將 <code>Iter::next</code> 的 <code>self.ring_buf.get(tail)</code> 改成 <code>get_mut</code> 即可。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.tail == self.head {
            return None;
        }
        let tail = self.tail;
        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring_buf.len());
        self.ring_buf.get_mut(tail) // Change to `get_mut`
    }
}
<span class="boring">}</span></code></pre></pre>
<p>欸！居然編譯失敗了，到底為什麼呢？</p>
<pre><code class="language-console">error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements
   --&gt; src/collections/deque/mod.rs:353:23
    |
353 |         self.ring_buf.get_mut(tail)
    |                       ^^^^^^^
    |
note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 347:5...
   --&gt; src/collections/deque/mod.rs:347:5
    |
347 |     fn next(&amp;mut self) -&gt; Option&lt;&amp;'a mut T&gt; {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: ...so that reference does not outlive borrowed content
   --&gt; src/collections/deque/mod.rs:353:9
    |
353 |         self.ring_buf.get_mut(tail)
    |         ^^^^^^^^^^^^^
note: but, the lifetime must be valid for the lifetime `'a` as defined on the impl at 344:6...
   --&gt; src/collections/deque/mod.rs:344:6
    |
344 | impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    |      ^^
note: ...so that the expression is assignable
   --&gt; src/collections/deque/mod.rs:353:9
    |
353 |         self.ring_buf.get_mut(tail)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: expected `Option&lt;&amp;'a mut T&gt;`
               found `Option&lt;&amp;mut T&gt;`
</code></pre>
<p>這個編譯錯誤是因為匿名的 <code>&amp;mut self</code> 和 <code>Self::Item</code> 兩者生命週期不匹配。以下把函式簽名的生命週期展開來看：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn next&lt;'anonymous&gt;(&amp;'anonymous mut self) -&gt; Option&lt;&amp;'a mut T&gt; {
        // ...
        self.ring_buf // &amp;'anonymous [T]
            .get_mut(tail) // Some(&amp;'anonymous mut T)
    }
<span class="boring">}</span></code></pre></pre>
<p>嗯，這不太對，我們知道 Rust 保證「就算 drop 了疊代器本身，產出的元素仍然合法」，產出的元素若為引用絕對<a href="https://users.rust-lang.org/t/iterator-lifetime-error-only-when-using-a-mutable-reference/50460/6">不會是迷途引用</a>，例如下面範例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = iter.next().unwrap();
let b = iter.next().unwrap();
drop(iter);
use_both(a, b);
<span class="boring">}</span></code></pre></pre>
<p>但編譯器只看型別是否正確，並無法檢查執行期間的 <code>&amp;mut self</code> 內部 <code>ring_buf</code> 和 <code>Self::Item</code> 是否活得一樣久，且由於 <code>Iterator::next</code> 函式簽名上沒有對 <code>&amp;mut self</code> 的生命週期做任何限制，因此無法寫出下列這種預期中的生命週期限制（可視為要求 <code>'b</code> 至少活得跟 <code>'a</code> 一樣長）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next&lt;'b: 'a&gt;(&amp;'b mut self) -&gt; Option&lt;Self::Item&gt; {
        // ...omit
    }
}

// error[E0195]: lifetime parameters or bounds on method `next` do not match the trait declaration
//    --&gt; src/collections/deque/mod.rs:347:12
//     |
// 347 |     fn next&lt;'b: 'a&gt;(&amp;'b mut self) -&gt; Option&lt;Self::Item&gt; {
//     |            ^^^^^^^^ lifetimes do not match method in trait
<span class="boring">}</span></code></pre></pre>
<p>當然，我們知道回傳 <code>ring_buf</code> 的 <code>&amp;'a mut T</code> 在生命週期上合法，但編譯器認不出來，所以 unsafe 又要來拯救世界。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.tail == self.head {
            return None;
        }
        let tail = self.tail;
        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring_buf.len());
        // This unsafe block is needed for solving the limitation of Iterator
        // trait: the `&amp;mut self` is bound to an anonymous lifetime which rustc
        // cannot figure out whether it would outlive returning element. Hence
        // the explicit pointer casting is required.
        unsafe {
            let ptr = self.ring_buf as *mut [T]; // 1
            let slice = &amp;mut *ptr; // 2
            slice.get_mut(tail) // 3
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>將 <code>ring_buf</code> 轉換成裸指標，因為裸指標無生命週期，所以 <code>&amp;mut self</code> 給的限制不見了。</li>
<li>再把 <code>ptr</code> 指向的 <code>*mut [T]</code> 裸指標轉換成有生命週期的可變引用 <code>&amp;mut [T]</code> 的切片。藉由 Rust 對回傳型別的自動推斷，此切片的實際型別會是 <code>&amp;'a mut [T]</code>。Got it！這就是我們所要的。</li>
<li>老老實實地呼叫 <code>slice::get_mut</code>，完全正確。</li>
</ol>
<blockquote>
<p>這類 <em>An iterator yields borrowing contents from it<code>self</code></em> 的問題，有個俗名叫做 <em>streaming iterator</em>，可以透過<strong>泛型關聯型別</strong>（generic associated type a.k.a GAT）解決，但目前 GAT 尚未穩定。詳情可參考這篇介紹 <a href="https://lukaskalbertodt.github.io/2018/08/03/solving-the-generalized-streaming-iterator-problem-without-gats.html">GAT 與 streaming iterator workaroud</a> 的文章。</p>
</blockquote>
<blockquote>
<p>欸，或許你有疑惑，<code>Iter::next</code> 不也同樣有生命週期問題嗎，為什麼沒有報錯呢？這是因為<a href="https://doc.rust-lang.org/1.49.0/core/marker/trait.Copy.html#impl-Copy-130">所有 <code>&amp;T</code> 引用都預設實作 Copy 特徵</a>，呼叫 <code>slice::get()</code> 時會<strong>自動複製</strong> <code>ring_buf</code> 的引用，因此沒有生命週期的問題，但 <code>&amp;mut T</code> 並沒有實作 Copy 特徵，才會遇上生命週期不符的編譯錯誤。</p>
</blockquote>
<h3 id="intoiterator"><a class="header" href="#intoiterator"><code>IntoIterator</code></a></h3>
<p>相較於 <code>Interator</code>，<a href="https://doc.rust-lang.org/1.49.0/core/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> 是一個讓容器型別錦上添花的特徵，主要功能是：將一個型別自動轉換為有實作 <code>Iterator</code> 的型別，實作後該型別就可以直接放入 for 迴圈中。</p>
<p>例如下列用法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut d = Deque::new();
d.push_back(1);
d.push_back(2);
d.push_front(3);
d.push_front(4);

for elem in &amp;d {
    println!("{:?}". elem);
}

for elem in &amp;mut d {
    *elem *= *elem;
}
<span class="boring">}</span></code></pre></pre>
<p>實作上分三個：</p>
<ul>
<li><code>impl&lt;T&gt; IntoIterator for Deque&lt;T&gt;</code>：將容器轉換成疊代器，並轉移容器和元素的所有權。</li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a Deque&lt;T&gt;</code>：將容器不可變引用轉換成不可變元素的疊代器。</li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut Deque&lt;T&gt;</code>：將容器可變引用轉換成可變元素的疊代器。</li>
</ul>
<p>先說明後面兩者。以下實作非常簡單，只要根據容器引用可變與否，對應呼叫前一段提及的 <code>Deque::iter</code> 或 <code>Deque::iter_mut</code> 即可，這算是 Rust 容器型別的一貫作法。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T&gt; IntoIterator for &amp;'a Deque&lt;T&gt; {
    type Item = &amp;'a T;
    type IntoIter = Iter&lt;'a, T&gt;;

    fn into_iter(self) -&gt; Self::IntoIter {
        self.iter()
    }
}

impl&lt;'a, T&gt; IntoIterator for &amp;'a mut Deque&lt;T&gt; {
    type Item = &amp;'a mut T;
    type IntoIter = IterMut&lt;'a, T&gt;;

    fn into_iter(self) -&gt; Self::IntoIter {
        self.iter_mut()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>至於 <code>impl&lt;T&gt; IntoIterator for Deque&lt;T&gt;</code> 和 <code>iter</code> 與 <code>iter_mut</code> 不一樣，會吃所有權，所以需要宣告額外的結構體來儲存其內部狀態，並直接實作 <code>IntoIterator</code> 要求的 <code>into_iter</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IntoIter&lt;T&gt;(Deque&lt;T&gt;);

impl&lt;T&gt; IntoIterator for Deque&lt;T&gt; {
    type Item = T;
    type IntoIter = IntoIter&lt;T&gt;;

    fn into_iter(self) -&gt; Self::IntoIter {
        IntoIter(self)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>此疊代方法中，佇列內元素的所有權會轉移，所以不需要跟 <code>Iter</code> 一樣保存切片，可以直接存整個 <code>Deque</code> 作為內部狀態，拿走 <code>Deque</code> 的所有權。</p>
<p>既然掌控 <code>Deque</code> 所有權，實作疊代器就沒有困難了，直接將所有元素 pop 取出即可。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.pop_front()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="index-and-indexmut"><a class="header" href="#index-and-indexmut"><code>Index</code> and <code>IndexMut</code></a></h3>
<p>用索引下標 <code>array[index]</code> 取值的語法常見於各大主流語言，Rust 提供 <a href="https://doc.rust-lang.org/1.49.0/core/ops/trait.Index.html"><code>Index</code></a> 和 <a href="https://doc.rust-lang.org/1.49.0/core/ops/trait.IndexMut.html"><code>IndexMut</code></a> 兩個特徵來實作這個運算子，讓容器型別更符合人體工學。</p>
<p>實作方法是利用<a href="collections/deque/index.html#%E9%82%8F%E8%BC%AF%E7%B4%A2%E5%BC%95%E6%98%A0%E5%B0%84">邏輯索引映射</a> 段落實作的 <code>wrap_index</code> 得出實際索引，再透過指標取值即可。唯一需要注意的是越界存取（out of bound access）可能產生未定義行為，不符合 Rust 對記憶體安全的要求，所以在裸指標存取之前，就要直接 <code>assert!</code> 索引是否在元素數量的安全範圍內，防止越界存取。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Index&lt;usize&gt; for Deque&lt;T&gt; {
    type Output = T;

    fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
        assert!(index &lt; self.len(), "Out of bound");
        let index = self.wrapping_add(self.tail, index);
        // This is safe because the offset is wrapped inside valid memory region.
        unsafe { &amp;*self.ptr().add(index) }
    }
}

impl&lt;T&gt; IndexMut&lt;usize&gt; for Deque&lt;T&gt; {
    fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut T {
        assert!(index &lt; self.len(), "Out of bound");
        let index = self.wrapping_add(self.tail, index);
        // This is safe because the offset is wrapped inside valid memory region.
        unsafe { &amp;mut *self.ptr().add(index) }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="debug"><a class="header" href="#debug"><code>Debug</code></a></h3>
<p>最後，介紹一下 <code>fmt::Formatter</code> 有許多方便的 debug 格式化輸出的方法，例如 <a href="https://doc.rust-lang.org/1.49.0/alloc/fmt/struct.Formatter.html#method.debug_list"><code>debug_list</code></a> 可以丟一個疊代器，會轉化成序列般的輸出格式。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: fmt::Debug&gt; fmt::Debug for Deque&lt;T&gt; {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        f.debug_list().entries(self.iter()).finish()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>當然，如果想要對 <code>RawVec</code> 實作 <code>Debug</code> 特徵，免手寫，可直接用 <code>derive</code> 屬性讓<a href="https://doc.rust-lang.org/stable/book/appendix-03-derivable-traits.html#debug-for-programmer-output">編譯器推導實作</a>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)] // Add this line to derive Debug trait automatically.
struct RawVec&lt;T&gt; {
    ptr: *mut T,
    cap: usize,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="效能-16"><a class="header" href="#效能-16">效能</a></h2>
<p>以環形緩衝區為底層儲存容器的雙端序列，各操作複雜度如下:</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Best case</th><th>Worst case</th></tr></thead><tbody>
<tr><td>push_front(v)</td><td>$O(1)$</td><td>$O(1)$~</td></tr>
<tr><td>push_back(v)</td><td>$O(1)$</td><td>$O(1)$~</td></tr>
<tr><td>pop_front(v)</td><td>$O(1)$</td><td>$O(1)$~</td></tr>
<tr><td>pop_back(v)</td><td>$O(1)$</td><td>$O(1)$~</td></tr>
<tr><td>front</td><td>$O(1)$</td><td>$O(1)$</td></tr>
<tr><td>back</td><td>$O(1)$</td><td>$O(1)$</td></tr>
<tr><td>len</td><td>$O(1)$</td><td>$O(1)$</td></tr>
</tbody></table>
</div>
<blockquote>
<p>$n$：資料筆數。<br />
$v$：資料值。<br />
<strong>~</strong>：平攤後的複雜度（amortized）。</p>
</blockquote>
<p>雙端佇列任何操作都是直接對 head 或 tail 的索引讀寫記憶體，複雜度皆為 $O(1)$，不過因為增減元素需要動態調整儲存空間大小，所以這些方法的時間複雜度需要平攤。</p>
<p>空間複雜度則是只用了一個環形緩衝區儲存元素，和幾個欄位儲存 tail、head 還有容量，因此額外空間複雜度只有 $O(1)$。</p>
<h2 id="參考資料-17"><a class="header" href="#參考資料-17">參考資料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/collections/vec_deque/struct.VecDeque.html">Rust Documentation: <code>VecDeque</code></a></li>
<li><a href="https://github.com/rust-lang/rust/blob/ff6ee2a/library/alloc/src/raw_vec.rs">Rust <code>RawVec</code> Implementation</a></li>
<li><a href="https://en.wikipedia.org/wiki/Circular_buffer">Wiki: Circular buffer</a></li>
<li>Circular Buffer Image by Cburnett <a href="https://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA-3.0</a> via Wikimedia Commons.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="鏈結串列-linked-list"><a class="header" href="#鏈結串列-linked-list">鏈結串列 Linked list</a></h1>
<p>鏈結串列是一種基本線性資料集合，每一個資料元素都是獨立的物件。儲存資料的方式和一般陣列配置連續物理記憶體空間不同，而是在各節點儲存額外的指標指向下一個節點。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Singly-linked-list.svg/612px-Singly-linked-list.svg.png" alt="" /></p>
<p><em>(單向鏈結串列示意圖）</em></p>
<h2 id="特性"><a class="header" href="#特性">特性</a></h2>
<p>鏈結串列有以下特性與優點：</p>
<ul>
<li>不需事先知道資料型別大小，充分利用動態記憶體管理。</li>
<li>以常數時間插入／刪除，不需重新配置記憶體（reallocation）。</li>
</ul>
<p>但也因動態配置記憶體等因素，連帶產生一些缺陷：</p>
<ul>
<li><strong>空間開銷大</strong>：每個元素需儲存額外的指標空間。</li>
<li><strong>較差的 CPU 快取</strong>：不連續存取的特性，不利於 <a href="https://en.wikipedia.org/wiki/CPU_cache">CPU 快取</a>。</li>
<li><strong>不允許隨機存取（random access）</strong>：搜尋特定節點仍需線性時間循序存取。</li>
</ul>
<h2 id="適用場景"><a class="header" href="#適用場景">適用場景</a></h2>
<p>大多數的場景其實不太常使用鏈結串列，Rust 內建的 <a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html"><code>LinkedList</code></a> 文件也建議，除非肯定要用鏈結串列，不然建議優先考慮其他類似的資料結構如 <a href="https://doc.rust-lang.org/std/collections/vec_deque/struct.VecDeque.html"><code>VecDeque</code></a>。話雖如此，鏈結串列仍有不少應用場景：</p>
<ul>
<li>需要頻繁地插入與刪除資料。</li>
<li>需要頻繁分離與合併（split and merge）資料。</li>
<li>不需要隨機存取的資料。</li>
<li>遞迴友好，因此成為大多函數式語言中基本資料型別之一。</li>
<li>教學上，常用於實作抽象資料型別，如<a href="collections/linked_list/../stack">堆疊</a>與<a href="collections/linked_list/../queue">佇列</a>等等。</li>
</ul>
<h2 id="術語"><a class="header" href="#術語">術語</a></h2>
<h3 id="node"><a class="header" href="#node">Node</a></h3>
<p>又稱「節點」，為組成鏈結串列的基本元素，節點包含資料儲存區與指標儲存區，指標儲存區用以儲存指向其他節點位址的變數。此外，最後一個節點的不指向其他節點位址的指標成為 null pointer，慣例以 NULL 表示。</p>
<p><img src="collections/linked_list/../singly_linked_list/node-box.svg" alt="node-box" /></p>
<p><em>（節點示意圖）</em></p>
<h3 id="head-and-tail"><a class="header" href="#head-and-tail">Head and tail</a></h3>
<p>Head 為指向整個串列第一個節點的指標。而 tail 則為指向最後一個節點的指標。用 ASCII 圖表示如下：</p>
<pre><code>   head                      tail
    |                         |
    v                         v
+--------+   +--------+   +--------+
|        |   |        |   |        |
| node 0 |--&gt;| node 1 |--&gt;| node 2 |--&gt; NULL
|        |   |        |   |        |
+--------+   +--------+   +--------+
</code></pre>
<h3 id="sentinel-node"><a class="header" href="#sentinel-node">Sentinel node</a></h3>
<p>Sentinal node 一個特殊的節點，資料值為 NULL 的節點，用意代表鏈結串列的端點。也就是說，sentinel node 指向串列第一個節點，而串列最後一個節點也會指向 sentinel node，就像哨兵一樣守著串列前後，因而得名。</p>
<p>實作鏈結串列時，常常因為判斷節點是否為 NULL 而讓程式變得複雜，而 sentinel node 可減少程式操作步驟，也能增加程式可讀性。詳細資訊可以參考這篇 <a href="https://stackoverflow.com/questions/5384358/">NULL 與 sentinel node 的比較討論</a>。</p>
<pre><code>    +-----------------------------------------------+
    |                                               |
    v                                               |
+---------+   +--------+   +--------+   +--------+  |
|sentinel |   |        |   |        |   |        |  |
|         |--&gt;| node 0 |--&gt;| node 1 |--&gt;| node 3 |--+
|  node   |   |        |   |        |   |        |
+---------+   +--------+   +--------+   +--------+
</code></pre>
<h2 id="種類"><a class="header" href="#種類">種類</a></h2>
<p>依據每個節點的鏈結多寡，可分為</p>
<p><a href="collections/linked_list/../singly_linked_list">單向鏈結串列</a>，每個節點只有一個指標，指向下一個節點。</p>
<pre><code>+--------+   +--------+   +--------+
|        |   |        |   |        |
| node 0 |--&gt;| node 1 |--&gt;| node 2 |--&gt; NULL
|        |   |        |   |        |
+--------+   +--------+   +--------+
</code></pre>
<p><a href="collections/linked_list/../doubly_linked_list">雙向鏈結串列</a>，每個節點有兩個指標，分別指向前後一個節點。</p>
<pre><code>        +--------+   +--------+   +--------+
        |        |--&gt;|        |--&gt;|        |--&gt; NULL
        | node 0 |   | node 1 |   | node 2 |
NULL &lt;--|        |&lt;--|        |&lt;--|        |
        +--------+   +--------+   +--------+
</code></pre>
<p>倘若該鏈結串列末端節點的指標指向第一個的節點，形成一個循環，則稱之為「<a href="collections/linked_list/../circular_linked_list">循環鏈結串列</a>」。</p>
<pre><code>Singly linked list as circular

+-----------------------------------------+
|                                         |
|   +--------+   +--------+   +--------+  |
|   |        |   |        |   |        |  |
+--&gt;| node 0 |--&gt;| node 1 |--&gt;| node 3 |--+
    |        |   |        |   |        |
    +--------+   +--------+   +--------+
</code></pre>
<p>詳細說明與實作請點選各個連結。</p>
<h2 id="參考資料-18"><a class="header" href="#參考資料-18">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Linked_list">Wiki: Linked list</a></li>
<li>Singly linked list SVG By Lasindi [Public domain], via Wikimedia Commons.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="單向鏈結串列-singly-linked-list"><a class="header" href="#單向鏈結串列-singly-linked-list">單向鏈結串列 Singly linked list</a></h1>
<p>單向鏈結串列是鏈結串列家族中最簡單的版本，特色是每兩個節點間只有一個單向的鏈結。</p>
<pre><code>   head
    |
    v
+--------+   +--------+   +--------+
|        |   |        |   |        |
| node 0 |--&gt;| node 1 |--&gt;| node 2 |--&gt; NULL
|        |   |        |   |        |
+--------+   +--------+   +--------+
</code></pre>
<p>比起 <a href="collections/singly_linked_list/doubly.html">雙向鏈結串列</a>，單向鏈結串列少了一個額外的指標開銷，在基本操作的花費也較低。在不需要雙向疊代情形下單向鏈結串列很適用。</p>
<p>此外，單向鏈結串列也支援 tail-sharing，也就是共享 sublist。藉由共享 sublist，單向鏈結串列很容易實作 <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">persistent data structure</a>，再配合 immutable 特性，使得單向鏈結串列幾乎成為函數式程式語言最常見的集合型別之一。可以參考這篇 <a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/third.html">persistent immutable stack 實作</a>文章。</p>
<blockquote>
<p>本次實作的程式碼置於 <a href="collections/singly_linked_list//doc/rust_algorithm_club/collections/struct.SinglyLinkedList.html"><code>rust_algorithm_club::collections::SinglyLinkedList</code></a> API 文件中。</p>
</blockquote>
<h2 id="實作設計"><a class="header" href="#實作設計">實作設計</a></h2>
<h3 id="node-1"><a class="header" href="#node-1">Node</a></h3>
<p>先建立最基本的節點 Node。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// cannot compile
struct Node&lt;T&gt; {
    elem: T,
    next: Node&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Node.elem</code> 很直觀地儲存實際資料。而 <code>Node.next</code> 則是指向下個 Node。但這樣編譯不會成功，Rust 編譯時需要決定每個型別該配置多少記憶體空間，這種遞迴型別使得編譯器無限循環，無法決定配置大小。</p>
<p><img src="collections/singly_linked_list/node-recursive.svg" alt="node-recursive" /></p>
<p>很簡單，我們使用 <a href="https://doc.rust-lang.org/std/boxed/index.html"><code>Box&lt;T&gt;</code></a> 這個<a href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html">智慧指標</a>，直接將 Node 配置在記憶體 heap 上。如此以來，編譯器就會知道 <code>next</code> 只佔了一個指標的空間。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Node&lt;T&gt; {
    elem: T,
    next: Box&lt;Node&lt;T&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><img src="collections/singly_linked_list/node-box.svg" alt="node-box" /></p>
<p>由於 Rust 沒有 null pointer，但照鏈結串列的定義，<code>Node.next</code> 可以是 NULL，因此我們使用 <a href="https://doc.rust-lang.org/std/option/index.html"><code>Option&lt;T&gt;</code></a> 模擬 null pointer 的行為。最後，Node 的定義如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Node&lt;T&gt; {
    elem: T,
    next: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="singlylinkedlist"><a class="header" href="#singlylinkedlist">SinglyLinkedList</a></h3>
<p>在開始實作各種增刪節點的操作之前，我們需要建立一個 struct 存放指向鏈結串列 head 的指標，同時，各種操作也會實作在這個 struct 上。事實上，這個 struct 就是對外公開的資料結構。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SinglyLinkedList&lt;T&gt; {
    head: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>選擇把操作串列的函式寫在另一個 struct 而非 Node 上有幾個原因，1）外部並不需知道串列內部如何實作，公開 Node 會暴露實作。2）每個 Node 都帶有成員函式的話，函式指標會佔用太多額外資源。</p>
<h2 id="基本操作-3"><a class="header" href="#基本操作-3">基本操作</a></h2>
<p>串列的基本操作如下：</p>
<ul>
<li><code>new</code>：初始化一個空串列。</li>
<li><code>push_front</code>：新增節點到開頭的位置。</li>
<li><code>pop_front</code>：將開頭第一個節點移除。</li>
<li><code>insert_after</code>：在指定索引位置後插入一個新節點。</li>
<li><code>remove</code>：移除任意索引下的節點。</li>
<li><code>clear</code>：清除所有節點。</li>
<li><code>is_empty</code>：檢查串列是否沒有任何節點。</li>
<li><code>reverse</code>：反轉整個串列（head 變成 tail）。</li>
</ul>
<h3 id="初始化與清除資料"><a class="header" href="#初始化與清除資料">初始化與清除資料</a></h3>
<p>實做初始化與清除資料非常直觀。其中清除其實就只是將 <code>self</code> 指向新的串列實例。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; SinglyLinkedList&lt;T&gt; {
    pub fn new() -&gt; Self {
        Self { head: None }
    }


}
<span class="boring">}</span></code></pre></pre>
<p>你可能會想，在清除所有資料時，資源需不需要手動釋放？</p>
<p>和 C++ 的 RAII 一樣，Rust 有一個名叫 <code>drop</code> 的解構式，只要程式執行離開了資源擁有者的可視範圍（out of scope），就會自動呼叫 <code>drop</code>。我們在 <a href="collections/singly_linked_list/index.html#drop-trait">Drop trait</a> 一節會再深入探討。</p>
<h3 id="增刪首個節點"><a class="header" href="#增刪首個節點">增刪首個節點</a></h3>
<p>單向鏈結串列在第一個節點前增加新節點，或是刪除第一個節點，都可以在常數時間完成。新增節點 <code>push_front</code> 的概念很簡單，1）建立新的節點，並把新節點 <code>next</code> 指標指向串列第一個節點。2）把串列的 head 指向新建立的節點。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn push_front(&amp;mut self, elem: T) {
        let next = self.head.take(); // 1
        self.head = Some(Box::new(Node { elem, next })); // 2
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>釋放 SinglyLinkedList 對第一個節點的所有權</li>
<li>建立一新節點，並將原本第一個節點所有權轉移給新節點。再將新節點所有權轉移到串列本身。</li>
</ol>
<p>刪除第一個節點 <code>pop_front</code> 的實作步驟如下：首先取得第一個節點的所有權，再將 head 指向第一個節點 <code>Node.next</code> 下一個節點，再返回第一個節點的資料給呼叫端。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
        // Take ownership of head
        let head = self.head.take()?; // 1
        self.head = head.next; // 2
        Some(head.elem) // 3
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>取得第一個元素的所有權，若無首個元素，表示串列為空，此處利用 <a href="http://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html"><code>?</code> 運算子</a>直接回傳 <code>None</code>。</li>
<li>將 head 指向下一個節點。</li>
<li>返回即將刪除節點的資料。</li>
</ol>
<h3 id="插入刪除任意節點"><a class="header" href="#插入刪除任意節點">插入刪除任意節點</a></h3>
<p>鏈結串列新增和刪除第一個節點都可以在 $O(1)$ 時間內做完，那為什麼插入刪除任意節點沒有辦法呢？原因是鏈結串列不支援隨機存取（random access），就是無法透過索引在常數時間內取得資料，每次的搜尋都只能從 head 開始。因此，當我們需要在某個索引的節點後新增一筆資料，我們會需要最差 $O(n)$ 的複雜度。</p>
<p>實作插入 <code>insert_after</code> 分為幾個步驟：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn insert_after(&amp;mut self, pos: usize, elem: T) -&gt; Result&lt;(), usize&gt; {
        let mut curr = &amp;mut self.head;
        let mut pos_ = pos;

        // Find the node at `pos`.
        while pos_ &gt; 0 {
            // 1
            curr = match curr.as_mut() {
                Some(node) =&gt; &amp;mut node.next,
                None =&gt; return Err(pos - pos_),
            };
            pos_ -= 1;
        }

        // Take the ownership of current node.
        match curr.take() {
            // 2
            Some(mut node) =&gt; {
                // Node A
                // Create new node.
                let new_node = Box::new(Node {
                    // 3: Node B
                    elem,
                    next: node.next,
                });
                // Re-link new node and current node.
                node.next = Some(new_node); // 4

                // Assign current node back to the list.
                *curr = Some(node); // 5
            }
            None =&gt; return Err(pos - pos_),
        }
        Ok(())
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>找到對應索引值的節點 A，若找不到則回傳這個串列的資料長度。</li>
<li>先取得節點 A 的所有權，才能修改它的值。</li>
<li>建立新節點 B，同時將節點 B 的 <code>next</code> 指向 A 的後一個節點。</li>
<li>將新節點 B 做為節點 A 後一個節點 <code>next</code>。</li>
<li>把修改過的節點 A，重新賦值給指向節點 A 的指標 <code>curr</code>（可視為歸還所有權）。</li>
</ol>
<p>而實作刪除任意索引下的節點 <code>remove</code> 和插入非常相似。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn remove(&amp;mut self, pos: usize) -&gt; Option&lt;T&gt; {
        let mut curr = &amp;mut self.head;
        let mut pos = pos;

        // Find the node at `pos`.
        while pos &gt; 0 {
            // 1
            curr = &amp;mut curr.as_mut()?.next;
            pos -= 1;
        }

        // Assign next node to previous node.next pointer.
        let node = curr.take()?; // 2: Node A
        *curr = node.next; // 3: node.next is Node B
        Some(node.elem) // 4
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>找到對應索引值的節點 A，若找不到則回傳 <code>None</code>。</li>
<li>先取得節點 A 的所有權，才能修改它的值。</li>
<li>把節點 A 的後一個節點 B 賦值給原本指向節點 A 的指標 <code>curr</code>。</li>
<li>回傳節點 A 的值。</li>
</ol>
<h3 id="反轉"><a class="header" href="#反轉">反轉</a></h3>
<p>反轉鏈結串列是工作面試時很常見的考題，這裡來實作看看。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn reverse(&amp;mut self) {
        let mut prev = None; // 1: prev -&gt; Node P
        let mut curr = self.head.take(); // 2
        while let Some(mut node) = curr {
            // 3: node -&gt; Node A
            let next = node.next; // 3-1: next -&gt; Node B
            node.next = prev.take(); // 3-2: Take ownership from previous node.
            prev = Some(node); // 3-3: Transfer ownership from current node to previous.
            curr = next; // 3-4: curr references to next node for next iteration.
        }
        self.head = prev.take(); // 4
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>先建立一個暫時變數 <code>prev</code>，儲存疊代時的前一個節點。</li>
<li>從串列 head 取得第一個節點的所有權。</li>
<li>依序疊代整個串列
<ol>
<li>將節點 A 的後一個節點 B 暫存起來。</li>
<li>節點 A 的 <code>next</code> 指向暫存在變數 <code>prev</code> 的節點 P。</li>
<li>節點 A 暫存在變數 <code>prev</code> 內，保留到下一個疊代使用。</li>
<li>將節點 B 儲存在變數 <code>curr</code> 內。此時<br />
<code>prev</code>：節點 A，A 的 <code>next</code> 指向 P，<br />
<code>curr</code>：節點 B，B 的 <code>next</code> 指向 A。</li>
</ol>
</li>
<li>最後一次疊代時，變數 <code>prev</code> 會儲存原始串列末端節點，這時轉移所有權到 head，完成反轉。</li>
</ol>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>除了基本操作，<code>SinglyLinkedList</code> 實作了許多 trait，使用上更方便更符合 Rust 的慣例。</p>
<h3 id="drop-trait"><a class="header" href="#drop-trait">Drop trait</a></h3>
<p>如果一個 struct 有許多成員，則會遞迴呼叫 struct 的 <code>drop</code> 成員函式。因此，一個串列的解構式很可能發生深層的巢狀遞迴：</p>
<pre><code># a linked list
a -&gt; b -&gt; c -&gt; x -&gt; y -&gt; z

# call stack when `drop` being called

(a.drop
  (b.drop
    (c.drop
      (x.drop
        (y.drop
          (z.drop
          (z.dropped
        (y.dropped
      (x.dropped
    (c.dropped
  (b.dropped
(a.dropped
</code></pre>
<p>如果節點一多，肯定會 stack overflow，太可怕了！</p>
<p>既然如此，那麼就透過 <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop trait</a>，實作一個疊代版本的解構式，消弭可怕的 call stack 吧。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Drop for SinglyLinkedList&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut link = self.head.take(); // 1
        while let Some(mut node) = link {
            // 2
            link = node.next.take(); // 3: Take ownership of next `link` here.
        }
        // 4: Previous `node` goes out of scope and gets dropped here.
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>取得 head 的所有權。</li>
<li>透過 pattern matching 取得 Node 裡面 Box 的所有權。</li>
<li>取得下一個 Node 的所有權，並將它指向共用的變數 <code>link</code>。</li>
<li>離開了 <code>node</code> 的 scope，<code>node</code> 呼叫 <code>drop</code> 釋放自身資源。</li>
</ol>
<blockquote>
<p>詳細思路過程可查看 Learning Rust With Entirely Too Many Linked Lists 的 <a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/first-drop.html">Drop</a> 章節，該章完整闡述為什麼不能用 tail recursive 來實作，但最大的原因是 Rust core team 暫時延緩實踐 <a href="https://github.com/rust-lang/rfcs/pull/1888">tail call optimization</a>。</p>
</blockquote>
<p>實際上，透過呼叫 <code>pop_front()</code>，不斷移除第一個節點，並使用 <code>is_some()</code> 檢查是否仍有節點，幾乎可以達到同樣的 drop 效果，而且更簡潔易懂。差別僅在於，相較於前個實作自己處理 call stack，這個實作每次移除元素都需要 <code>pop_front()</code> 與 <code>is_some()</code> 的 stack，多了些微小的開銷，雖然可透過 <a href="https://doc.rust-lang.org/1.49.0/reference/attributes/codegen.html#the-inline-attribute"><code>#[inline]</code></a> attribute 提示編譯器，但終究只是提示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Drop for SinglyLinkedList&lt;T&gt; {
    fn drop(&amp;mut self) {
        while self.pop_front().is_some() {}
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="iterator-and-intoiterator-traits"><a class="header" href="#iterator-and-intoiterator-traits">Iterator and IntoIterator traits</a></h3>
<p>既然鏈結串列是一種序列（sequence，有序的資料結構），少不了實作 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Iterator</a>、<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html">IntoIterator</a> 等 trait，使串列可以輕鬆使用 for-in loop 遍歷（traverse）。</p>
<p>首先，先定義幾個疊代器的 struct。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IntoIter&lt;T&gt;(SinglyLinkedList&lt;T&gt;);

pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;, // 1
}

pub struct IterMut&lt;'a, T&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>建立這三個 iterator struct 是常見的 Rust 設計模式。</p>
<ul>
<li><code>IntoIter</code>：產生 <code>T</code>，實作會吃掉元素所有權的 <code>IntoIterator</code> trait</li>
<li><code>Iter</code>：產生 <code>&amp;T</code>，實作提供 immutable borrow 的 <code>Iterator</code> trait。</li>
<li><code>IterMut</code>：產生 <code>&amp;mut T</code>，實作提供 mutable borrow 的 <code>Iterator</code> trait。</li>
</ul>
<p>相對應的，<code>SinglyLinkedList</code> 則新增三個成員函式：</p>
<ul>
<li><code>fn into_iter(self) -&gt; IntoIter&lt;T&gt;</code>：轉移所有權的疊代器。<em>Into</em> 一詞慣例上指涉所有權移轉。</li>
<li><code>fn iter(&amp;self) -&gt; Iter&lt;T&gt;</code>：以 immutable reference 疊代串列。</li>
<li><code>fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt;</code>：以 mutable reference 疊代串列。</li>
</ul>
<p>先來看 <code>IntoIter</code> 實作。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1
pub struct IntoIter&lt;T&gt;(SinglyLinkedList&lt;T&gt;);

// 2
impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.pop_front()
    }
}

// 3
impl&lt;T&gt; IntoIterator for SinglyLinkedList&lt;T&gt; {
    type Item = T;
    type IntoIter = IntoIter&lt;T&gt;;

    /// Creates a consuming iterator, that is, one that moves each value out of
    /// the list (from start to end). The list cannot be used after calling this.
    fn into_iter(self) -&gt; Self::IntoIter {
        IntoIter(self)
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>宣告一個 tuple struct，唯一的成員是 <code>SinglyLinkedList</code>。</li>
<li>實作 <code>Iterator</code> trait 的 required method <code>next</code>，為了達成 <em>Into</em> 會消耗原始資料，轉換所有權的特性，我們利用 <code>pop_front()</code> 將節點的資料依序刪除（pop）。</li>
<li><code>IntoInterator</code> 的 required method 傳遞 <code>self</code> 進來，所以無論怎麼實作 <code>IntoIter</code> struct，呼叫 <code>into_iter()</code> 後，外部就無法再次存取此 <code>SinglyLinkedList</code> 實例，達到所有權轉移的目標。</li>
</ol>
<blockquote>
<p>可能有人會疑惑，<code>IntoIter</code> 並沒有內部狀態記錄欄位，疊代器如何依據狀態產生下一筆資料？受惠於 <code>IntoIterator</code> 傳遞所有權的特性，<code>IntoIter</code> 可直接改變原始串列的內部狀態，例如 <code>pop_front</code> 會移除原始串列的節點。因此，相較於 <code>Iter</code>、<code>IterMut</code> 額外記錄狀態，<code>IntoIter</code> 不需自行記錄疊代器的疊代狀態。</p>
</blockquote>
<p>再來看看 <code>Iter</code> 怎麼實踐。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;, // 1
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T; // 2

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let node = self.next?;
        self.next = node.next.as_deref(); // 3
        Some(&amp;node.elem)
    }
}

impl&lt;T&gt; SinglyLinkedList&lt;T&gt; {
    // ...

    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        // 4
        Iter {
            next: self.head.as_deref(), // 5
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>這個 struct 的 <code>next</code> 是為了儲存 <code>Node</code> 資訊，方便記錄疊代器當前的狀態。加上生命週期 <code>'a</code> 是因編譯器無法推敲 <code>Option&lt;&amp;Node&lt;T&gt;&gt;</code> 會活多久，需要顯著標明 <code>&amp;Node</code> 至少與該疊代器同生共死。</li>
<li>由於 <code>Iter</code> 是為了實作產生 <code>&amp;T</code> 的疊代器，associated type 設為  <code>&amp;'a T</code>。</li>
<li>將當前節點的後一個節點設為 <code>Iter</code> 疊代器的狀態。並回傳當前節點的資料。<br />
這邊用了 <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.as_deref"><code>Option::as_deref()</code></a>，可直接將 <code>Option&lt;T&gt;</code> 轉換成 <code>Option&lt;&amp;T&gt;</code>，若 <code>T</code> 有實作 <a href="http://doc.rust-lang.org/core/ops/trait.Deref.html"><code>Deref</code></a> 特徵，更可以將 <code>T</code> 轉為 <code>Deref::Target</code>，例如這裡就是藉由 <a href="http://doc.rust-lang.org/alloc/boxed/struct.Box.html#method.deref"><code>Box::deref()</code></a> 將 <code>Box&lt;Node&lt;T&gt;&gt;</code> 轉換為 <code>&amp;Node&lt;T&gt;</code>。</li>
<li>在 <code>SinglyLinkedList</code> 上加 <code>iter()</code> 成員函式回傳 <code>Iter</code> 疊代器。</li>
<li>產生疊代器初始化狀態，和第三步一模一樣。</li>
</ol>
<p>最後，<code>IterMut</code> 與 <code>Iter</code> 疊代器實作上大同小異。把 <code>Iter</code> 用到 <code>Option::as_deref()</code> 改為 <code>Option::as_deref_mut()</code>，其他 <code>&amp;</code> 改成 <code>&amp;mut</code> 即可。</p>
<h3 id="partialeq-trait"><a class="header" href="#partialeq-trait">PartialEq trait</a></h3>
<p><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">PartialEq trait</a> 是用來實現兩個串列是否能夠比較，而我們在此定義如下：</p>
<p>有兩個 <code>SinglyLinkedList</code> Sa、Sb，Sa、Sb 的元素皆符合 <code>PartialEq</code> trait。當</p>
<ul>
<li>Sa 的總節點數 等於 Sb 的總節點數，</li>
<li>Sa 所有元素依序等於 Sb 所有元素，</li>
</ul>
<p>則稱 Sa 與 Sb 有 partial equiavalence（<code>Sa == Sb</code>）。</p>
<p>實作上我們用了 <code>iter</code> 成員函式把兩個串列 <code>zip</code> 在一起，在用 <code>all</code> 確認元素兩兩相等，十分 Rust 風格的作法。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: PartialEq&gt; PartialEq for SinglyLinkedList&lt;T&gt; {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        if self.len() != other.len() {
            return false;
        }
        self.iter().zip(other.iter()).all(|pair| pair.0 == pair.1)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="debug-trait"><a class="header" href="#debug-trait">Debug trait</a></h3>
<p>為了方便修復臭蟲，通常會實作 <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug trait</a> 印出有助於解決問題的資料。歸功於 <code>Iterator</code> 的實踐，我們可以快速用 <code>self.iter()</code> 印出所有節點內的元素，客製化 <code>Debug</code> 的顯示方式。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: std::fmt::Debug&gt; std::fmt::Debug for SinglyLinkedList&lt;T&gt; {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
        for node in self.iter() {
            write!(f, "{:?} -&gt; ", node)?
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="效能-17"><a class="header" href="#效能-17">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Complexity</th></tr></thead><tbody>
<tr><td>get</td><td>$O(n)$</td></tr>
<tr><td>insert</td><td>節點已知：$O(1)$ ；節點未知：$O(n - i)$</td></tr>
<tr><td>remove</td><td>節點已知：$O(1)$ ；節點未知：$O(n - i)$</td></tr>
<tr><td>append</td><td>$O(n)$</td></tr>
<tr><td>prepend</td><td>$O(1)$</td></tr>
<tr><td>pop first</td><td>$O(1)$</td></tr>
<tr><td>pop last</td><td>$O(n)$</td></tr>
<tr><td>space</td><td>$O(n)$ + 各節點額外一個指標 $n$ 個</td></tr>
</tbody></table>
</div>
<blockquote>
<p>$n$：資料筆數。<br />
$i$：相對於整個容器的索引位置。</p>
</blockquote>
<p>值得觀察的是，許多操作因為單向鏈結串列只能從 head 開始搜索的緣故，執行時間都呈線性，使用上要特別注意。</p>
<h2 id="參考資料-19"><a class="header" href="#參考資料-19">參考資料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/src/alloc/linked_list.rs.html">Rust Documentation: LinkedList</a></li>
<li><a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/README.html">Learning Rust With Entirely Too Many Linked Lists</a></li>
<li><a href="https://stackoverflow.com/questions/51134192/">Duscussions at Stackoverflow</a></li>
<li><a href="https://codereview.stackexchange.com/questions/150906">StackExchange: Reversal of a singly-linked list in Rust</a></li>
<li>SVG of node memory representation modified from <a href="https://doc.rust-lang.org/book">The Rust Programming Language</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="關聯容器-associative-container"><a class="header" href="#關聯容器-associative-container">關聯容器 Associative Container</a></h1>
<p>關聯容器是一種抽象資料型別，儲存鍵與值配對關係（key-value pair）的集合，並透過鍵存取元素，所謂「鍵值對」好比身份證字號與公民，戶政單位知道一個人證號，就可在關聯容器內，透過證號查找是否有這個公民，以及此證號對應的公民基本資訊。</p>
<p>關聯容器有許多別名，例如字典（dictionary）、關聯陣列（associative array）、映射（map）、表（table）等。在大多數程式語言函式庫中，關聯容器通常是最基本的容器型別之一，如 Python 的 <code>dict</code>，JavaScript 的 <code>Map</code>，以及 Rust 的 <code>HashMap</code>。</p>
<p>方便起見，本文以「<strong>映射表</strong>」統稱這類集合型別。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/Hash_table_5_0_1_1_1_1_0_LL.svg/1280px-Hash_table_5_0_1_1_1_1_0_LL.svg.png" alt="" /></p>
<p><em>（雜湊表示意圖）</em></p>
<h2 id="特性-1"><a class="header" href="#特性-1">特性</a></h2>
<p>一般來說，映射表有以下特性：</p>
<ul>
<li><strong>鍵值對為單向關係</strong>：可透過鍵取得其唯一值；但無法確保一值僅對應唯一的鍵。</li>
<li><strong>鍵值唯一性</strong>：同個映射表內，同個鍵不重複，只會出現一次。</li>
<li><strong>元素組合性</strong>：映射表內每個元素都是「鍵值對」，鍵或值無法單獨存在。</li>
<li><strong>操作開銷小</strong>：合理實作下，基本操作開銷相對較小，不高於線性時間。</li>
</ul>
<blockquote>
<p>註：多重映射表為一對多的例外。</p>
</blockquote>
<p>映射表會有以下幾種基本操作：</p>
<ul>
<li><strong>新增</strong>：配對鍵值關聯，又稱為綁定 binding。</li>
<li><strong>修改</strong>：修改任意鍵之下的值。</li>
<li><strong>移除</strong>：透過任意鍵移除該鍵值對，又稱 unbinding。</li>
<li><strong>查找</strong>：透過任意鍵搜尋該鍵值對。</li>
</ul>
<p>不難看出，基本操作都是透過鍵取得值。事實上，合理實作的映射表，只要透過鍵來操作，就能有良好效能，甚至上述操作能達到 $O(1)$ 複雜度。</p>
<h2 id="適用場景-1"><a class="header" href="#適用場景-1">適用場景</a></h2>
<p>雖然映射表依實作不同，效能有所權衡。但其最大優勢仍是可「高效地透過鍵尋找值」，只要有映射關係的資料，都非常適合使用映射表。例如，快取暫存機制需透過特定鍵快速查找暫存值。此外，現代常用的 JSON、TOML 等資料交換格式，都是「鍵—值對」的形式，非常適合使用映射表處理。而應用映射表最有名的實際案例莫過於資料庫的索引，透過索引，我們可以大大降低搜尋的成本，從線性時間直落到對數甚至常數時間，不過相對就需要付出額外時空間建立索引。</p>
<p>我們再次把應用場景條列出來，方便懶人帶著走。</p>
<ul>
<li>有映射關係，處理「鍵—值」配對的資料結構。</li>
<li>處理 JSON、TOML 等資料交換，資料序列化。</li>
<li>實作快取（cache）機制。</li>
<li>資料庫索引的實作方法之一。</li>
<li>查找操作頻率遠高於其他操作時。</li>
</ul>
<p>總的來說，只要資料有對應綁定關係，就可以考慮使用映射表處理。</p>
<h2 id="種類-1"><a class="header" href="#種類-1">種類</a></h2>
<p>以下簡單介紹常見的映射表，詳情請點擊各連結。</p>
<h3 id="雜湊表-hash-map"><a class="header" href="#雜湊表-hash-map">雜湊表 Hash Map</a></h3>
<p><a href="collections/associative-container/../hash_map">雜湊表</a>是以雜湊函數實作的映射表。透過<a href="collections/associative-container/../../hash">雜湊函數</a>將任意資料轉換為固定長度的雜湊值，並將此鍵與一筆資料綁定，再映射到內部資料結構的某位置。理論上，只要雜湊函數品質過得去，雜湊表的基本操作都能在常數時間完成。</p>
<h3 id="有序映射表-ordered-map"><a class="header" href="#有序映射表-ordered-map">有序映射表 Ordered Map</a></h3>
<p><a href="collections/associative-container/../ordered_map">有序映射表</a>係一種有特定排序方式的映射表。常見兩種排序方式，其一是依照插入映射表的先後順序；其二則是依照鍵的大小。不同排序的底層資料結構各異，操作複雜度也不盡相同，如依鍵大小排序的映射表通常使用搜索樹實作，因此「新增」操作的複雜度為較差的 $O(\log n)$。</p>
<h3 id="多重映射表-multimap"><a class="header" href="#多重映射表-multimap">多重映射表 Multimap</a></h3>
<p><a href="collections/associative-container/../multimap">多重映射表</a>允許鍵值對重複，一個鍵可對應多個值（一對多）。類似於映射表內放入陣列，但能以較方便輕鬆的介面來操作或疊代整張映射表。</p>
<h3 id="集合-set"><a class="header" href="#集合-set">集合 Set</a></h3>
<p><a href="collections/associative-container/../set">集合</a>實際上並無鍵值「關聯」，可將其想像成普通的映射表。只關心鍵而值不重要。集合借用了數學<a href="https://en.wikipedia.org/wiki/Set_theory">集合論（set theory）</a>中有限集合的概念，常應用於需要操作交集、聯集、差集等集合運算場景。</p>
<h3 id="布隆過濾器-bloom-filter"><a class="header" href="#布隆過濾器-bloom-filter">布隆過濾器 Bloom Filter</a></h3>
<p><a href="collections/associative-container/../bloom_filter">布隆過濾器</a>是一種類似於集合，但只會回報「絕對不存在」或「可能存在」的機率資料結構，實作上節省空間，常用於在海量資料中確認成員是否存在，並能有一定容錯率的場景。</p>
<h2 id="參考資料-20"><a class="header" href="#參考資料-20">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Associative_array">Wiki: Associative array</a></li>
<li><a href="https://en.wikipedia.org/wiki/Associative_containers">Wiki: Associative containers</a></li>
<li><a href="https://en.cppreference.com/w/cpp/container/map">cpprefernce.com: std::map</a></li>
<li><a href="https://doc.rust-lang.org/stable/std/collections/">Rust documentation: std::colledtion</a></li>
<li>Map graph by Jorge Stolfi <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA-3.0</a> via Wikimedia Commons.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="雜湊表-hash-map-1"><a class="header" href="#雜湊表-hash-map-1">雜湊表 Hash Map</a></h1>
<p>雜湊表是以雜湊函數實作的關聯容器。透過雜湊函數，計算鍵（key）對應到容器內部的索引位置，進而找到對應的值（value）。一般來說，雜湊表最常見的實作是以一個簡單陣列儲存資料。</p>
<p>雜湊表的優勢是：</p>
<ul>
<li>在資料量大時，仍然維持常數時間的高效能。</li>
<li>若資料數量上限已知，就可避免重新配置記憶體，效能更佳。</li>
<li>若資料形態已知，就可針對該資料形態找尋適合的雜湊函數最佳化。</li>
</ul>
<p>而雜湊表相對有以下短處：</p>
<ul>
<li>資料量不夠大時，單一操作需要雜湊計算，開銷相對高。</li>
<li>效能與雜湊函數息息相關，較差的函數容易雜湊碰撞，較佳函數計算成本通常較高。</li>
<li>只能以某種偽隨機的順序疊代雜湊表。</li>
</ul>
<blockquote>
<p>本次實作的程式碼置於 <a href="collections/hash_map//doc/rust_algorithm_club/collections/struct.HashMap.html"><code>rust_algorithm_club::collections::HashMap</code></a> API 文件中。</p>
</blockquote>
<h2 id="概念"><a class="header" href="#概念">概念</a></h2>
<p>建立雜湊表的第一步，就是配置一定大小的陣列（通常稱為 bucket array），來儲存對應索引的鍵值對。我們以建立電話簿為例，儲存人名與號碼的對應關係。</p>
<pre><code>Create an empty phone book with some blank slots.

          +--------------+
          | 0:           |
          +--------------+
          | 1:           |
          +--------------+
          | 2:           |
          +--------------+
          | 3:           |
          +--------------+
</code></pre>
<p>我們嘗試插入第一筆資料，記錄 Frodo 以及他的手機號碼 88-7-666。</p>
<ol>
<li>透過雜湊函數，計算出 Frodo 的索引值為 1。</li>
<li>將 88-7-666 插入 table[1] 的位置上。</li>
</ol>
<blockquote>
<p>table[1] 這種 bucket array 下的個別索引空間，通常稱為一個 slot 或 bucket。</p>
</blockquote>
<pre><code>Fordo: hash_function(Frodo) --&gt; 1

          +-------------+
          | 0:          |
          +-------------+
Frodo --&gt; | 1: 88-7-666 |
          +-------------+
          | 2:          |
          +-------------+
          | 3:          |
          +-------------+
</code></pre>
<p>嘗試插入另外二筆資料，記錄 Sam 的手機 11-2-333，以及 Gollum 的手機 00-0-000。</p>
<ol>
<li>透過雜湊函數，計算出 Sam 的索引值為 2。</li>
<li>將 11-2-333 插入 table[2] 的位置上。</li>
<li>透過雜湊函數，計算出 Gollumn 的索引值為 0。</li>
<li>將 00-0-000 插入 table[0] 的位置上。</li>
</ol>
<pre><code>Sam: hash_function(Sam) --&gt; 2

          +-------------+
          | 0:          |
          +-------------+
          | 1: 88-7-666 |
          +-------------+
Sam   --&gt; | 2: 11-2-333 |
          +-------------+
          | 3:          |
          +-------------+


Gollum: hash_function(Gollum) --&gt; 0

          +-------------+
Gollum -&gt; | 0: 00-0-000 |
          +-------------+
          | 1: 88-7-666 |
          +-------------+
          | 2: 11-2-333 |
          +-------------+
          | 3:          |
          +-------------+
</code></pre>
<p>若需要取得 Sam 的手機號碼，只要</p>
<ol>
<li>透過雜湊函數，計算出 Sam 的索引值為 2。</li>
<li>從 table[2] 的索引位置上，找到 Sam 的手機號碼</li>
</ol>
<pre><code>Sam: hash_function(Sam) --&gt; 2

          +-------------+
          | 0: 00-0-000 |
          +-------------+
          | 1: 88-7-666 |
          +-------------+
Sam   --&gt; | 2: 11-2-333 | --&gt; Sam's phone number
          +-------------+
          | 3:          |
          +-------------+
</code></pre>
<p>這就是最基本，以陣列實作的雜湊表了。</p>
<p>然而，你可能已經開始好奇了。</p>
<ul>
<li>雜湊是什麼？怎麼知道要映射到哪個索引位置？</li>
<li>雜湊函數是否會計算出相同的索引值？要如何解決？</li>
<li>若預先配置的陣列填滿了，該如何處理？</li>
</ul>
<p>接下來，將探討這幾個魔術般的因子，從簡單介紹雜湊函數，到如何解決雜湊碰撞，最後探討陣列塞滿重配置解決方案。</p>
<blockquote>
<p>註：雜湊表也可以搜尋樹等其他資料結構實作，在此不深入討論。</p>
</blockquote>
<h3 id="雜湊"><a class="header" href="#雜湊">雜湊</a></h3>
<p>所謂的雜湊函數，就是一種將「較寬的定義域映射到較窄值域」的函數。簡單來說，就是輸入任意值到此函數，則輸出值會落在一已知範圍。再白話一點，雜湊函數就是用來「化繁為簡」，把複雜多變的東西，透過函數生成簡化版本。此外，相同的輸入鍵，必須得到相同的輸出雜湊值，這是雜湊函數很重要的一個特性，以虛擬碼表示：</p>
<pre><code>key1 == key2 -&gt; hash(key1) == hash(key2)
</code></pre>
<p>「映射」這部分只是使用雜湊的一小步。雜湊表根據程式實作的不同，底層儲存資料的形式也不盡相同，為了完全放入陣列中，通常會對雜湊值（雜湊函數的計算結果）取模（modulo）。也就是說：假設有長度為 <em>n</em> 的陣列。1）先對 key 取雜湊值。2）再對雜湊值取模，確認索引值落在陣列內部。</p>
<pre><code>Assumed: array_size = n

hash_value = hash_function(key) // 1

index = hash_value % array_size // 2
</code></pre>
<p>如此一來，所有可能的值都會落在陣列內，這就是最簡單普遍的雜湊兩步驟：計算雜湊值﹢取模。</p>
<h3 id="選擇雜湊函數"><a class="header" href="#選擇雜湊函數">選擇雜湊函數</a></h3>
<p>接下來，你會緊接著向問第二個問題「函數計算出相同索引值該怎麼辦？」不同輸入產生相同雜湊值，多個值映射到同個索引上，這種狀況科學家稱之<strong>雜湊碰撞（hash collision）</strong>。</p>
<p>首先，要瞭解雜湊函數本身就是時空間的權衡，如果記憶體空間夠多，那讓輸入值與雜湊值呈一對一的完美關係，就不會出現碰撞；大多數情況，尤其是實作泛用的雜湊函式庫，無法預期輸入資料的範圍，實務上會鎖定一個輸出雜湊值的範圍，僧多粥少，難免碰撞。</p>
<p>好的雜湊函數還必須符合一些條件：</p>
<ol>
<li>同一筆輸入資料，必須得到相同的雜湊值。</li>
<li>結果必須能夠高效的計算出來（預期為常數時間）。</li>
<li>任意輸入資料所得之雜湊值在值域內需接近<a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)">均勻分佈（uniform distribution）</a>，才能減少碰撞機率。</li>
</ol>
<p>但總歸一句，欲達成上述條件，就是一種權衡取捨，例如，<a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">加密雜湊函數（cryptographic hash function）</a>即是非常優秀的雜湊函數，但相對需付出更高的計算成本。</p>
<p>更多雜湊函數相關的討論，會另撰<a href="collections/hash_map/../../hash">專文</a>。</p>
<h3 id="處理雜湊碰撞"><a class="header" href="#處理雜湊碰撞">處理雜湊碰撞</a></h3>
<p>既然雜湊函數人生在世難免碰撞，科學家也研究幾個處理雜湊碰撞的策略，分別是 separate chaining 與 open addressing。</p>
<p><strong>Separate chaining</strong> 可以說是最直觀的做法，就是設法讓同一個索引下，可以儲存多個碰撞的值。依據儲存資料的形式，可分為幾種實作：</p>
<ul>
<li><strong>鏈結串列</strong>：以<a href="collections/hash_map/../linked_list">鏈結串列（linked list）</a>儲存元素。發生碰撞時，新的元素串接在既有元素之後。</li>
<li><strong>動態陣列</strong>：新增元素時，在該位址配置<a href="collections/hash_map/../dynamic_array">動態陣列（dynamic array）</a>儲存元素。發生碰撞時，直接將新元素加在陣列尾端。</li>
</ul>
<p>不同實作方式有各自優缺點，例如串列版本容易實作，但需額外儲存指標資訊；用動態陣列，則會有更好的 CPU caching，但相對地碰撞過多則需要重配置陣列。</p>
<p>以 ASCII 表述使用串列實作 separate chaining 示意圖如下：</p>
<pre><code>... assumed hash values of Gimli and Gollum collided.

                          +----------------+
                      +-&gt; |Gollum, 00-0-000| (linked list)
                      |   +----------------+
                      |            |
Gimli -+              |            v
       |              |   +---------------+
       |  +--------+  |   |Gimli, 99-9-999|
Gollum --&gt;|0: ptr  |--+   +---------------+
          +--------+
Frodo  --&gt;|1: ptr  |----&gt; +---------------+ 
          +--------+      |Frodo, 88-7-666|
Sam    --&gt;|2: ptr  |--+   +---------------+
          +--------+  |
          |3: null |  +-&gt; +---------------+
          +--------+      | Sam, 11-2-333 |
     (main bucket array)  +---------------+
</code></pre>
<p>而這邊也有精美的實作示意圖，將串列首個元素 head 直接放置在 slot 中的作法，減少一次指標操作。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/Hash_table_5_0_1_1_1_1_0_LL.svg/1280px-Hash_table_5_0_1_1_1_1_0_LL.svg.png" alt="" /></p>
<p><em>(利用 separate chaining 實作的雜湊表，並將串列第一個元素放在 bucket array 中)</em></p>
<p>另一方面 <strong>Open addressing</strong> 則走完全不同的套路，不額外配置儲存空間給碰撞的元素，而是繼續在同個陣列內「探測」其他可用的 slot，再把資料塞進尚未被佔據的 slot 中。而 Open addressing 依據不同探測序列（probe sequence）有不同實作，常見的有：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Linear_probing"><strong>Linear probing</strong></a>：從發生碰撞索引開始，依序往下一個 slot 探測是否可用，因此得名「線性」。</li>
<li><a href="https://en.wikipedia.org/wiki/Quadratic_probing"><strong>Quadratic probing</strong></a>：從碰撞索引開始，間隔以二次式增加往下探測可用 slot，如 $i + 1^2, i + 2^2, i + 3^2$。</li>
<li><a href="https://en.wikipedia.org/wiki/Double_hashing"><strong>Double hashing</strong></a>：以固定間隔大小 $k$（probe distance），依序探測 $i + k, i + k \cdot 2 …$ 的 slot 是否為空。而這個間隔是以另外一個雜湊函數計算所得，因此得名「雙雜湊」。</li>
</ul>
<blockquote>
<p>$i$ 為發生碰撞的索引位置。</p>
</blockquote>
<p>這些方法的差異主要在於 CPU caching 的效能，以及 HashMap 資料的群聚效應（clustering）的敏感程度。當然，論 caching 絕對非 linear probing 莫屬，但 linear probing 以線性一個挨一個探勘，效能較容易受雜湊值群聚影響。</p>
<p>以下是 linear probing（間隔 = 1）的示意圖。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/90/HASHTB12.svg/1280px-HASHTB12.svg.png" alt="" /></p>
<h3 id="動態調整雜湊表大小"><a class="header" href="#動態調整雜湊表大小">動態調整雜湊表大小</a></h3>
<p>若資料的筆數已知，那初始配置的陣列大小設定與資料筆數成比例，就不必擔心雜湊表空間不夠，需要重新配置（reallocate）儲存空間的困擾。倘若資料量未知，而最初配置的 bucket array 滿了，該如何重新配置呢？</p>
<p>動態調整大小對雜湊表來說，不同於一般動態陣列，舊的雜湊表若要對應到新雜湊表，是每個鍵都需要重新計算雜湊值（rehash），成本相對較高。因此，減少動態調整的次數，可說是調教雜湊表的重點之一。說到調教雜湊表，必定要瞭解一個重要指標：<em>load factor</em>。</p>
<p>$$\text{load factor} = \frac{n}{k}$$</p>
<blockquote>
<p>$n$：已放入雜湊表內的資料總數。<br />
$k$：雜湊表配置的儲存空間（bucket 總數）。</p>
</blockquote>
<p>Load factor 代表目前雜湊表的「使用率」，若三筆資料放在四個 bucket 內，則 load factor 為 $3/4 = 75%$。Load factor 太大會更容易碰撞，會有效能上的影響；太小則代表過多冗餘空間沒有使用。如何維持 load factor 在一定範圍內至關重要。一般來說，75% 的 load factor 就可以準備重新配置雜湊表了，當然，這個門檻仍要以實作經驗為主，例如 Rust 的 <a href="https://doc.rust-lang.org/stable/std/collections/hash_map/index.html"><code>HashMap</code></a> 使用了 <a href="https://github.com/rust-lang/rust/blob/1.29.0/src/libstd/collections/hash/map.rs#L82-L103">Robin Hood Hashing</a>，將 load factor 調教到 90%。</p>
<p>重配置雜湊表與動態陣列的動態調整大小雷同，達到某個門檻值，就會將底層陣列大小翻倍。為了避免開銷過高，通常元素減少時，不會主動調整大小，而是提供一個 <code>shrink_to_fit</code> 一類的方法，讓呼叫端自行決定釋放多餘空間的時機。</p>
<h2 id="架構設計-3"><a class="header" href="#架構設計-3">架構設計</a></h2>
<p>在介紹架構設計之前，我們先來瞭解 Rust 雜湊相關的觀念與 trait。</p>
<h3 id="hash-and-eq"><a class="header" href="#hash-and-eq">Hash and Eq</a></h3>
<p>要實作雜湊函數，當然可以自幹計算雜湊值的函式來用，那為什麼還要使用 Rust 定義好的 <a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a> 呢？當然是希望將雜湊的介面抽象化，只要型別宣告符合 <code>Hash</code> trait，任何人都可以輕鬆計算雜湊值。而實作 <a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a> 很簡單，只要寫一個 <code>fn hash()</code>，呼叫端就能透過它計算雜湊，例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::hash::{Hash, Hasher};

struct Car {
  brand: String,
}

impl Hash for Car {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.brand.hash(state);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>光是計算雜湊值還不夠，要確定「當鍵相等時，其雜湊值也相等」這極為重要的雜湊特性，這時候除了實作 <code>Hash</code> trait，<code>Eq</code> trait 也要同時實作，該型別才能夠「被比較」，標準函式庫的 <code>HashMap</code> 的鍵就是實作 <code>Hash + Eq</code> 的型別，詳情請參閱 trait 的文件說明。</p>
<p>綜合以上，可以大膽定論，我們將實作的雜湊表的 key 一定符合 <code>K: Hash + Eq</code>，key 本身才能相互比較（實作 <code>Eq</code>），並開放呼叫端自定義型別實作不同的雜湊計算方式（實作 <code>Hash</code>）。</p>
<p>為了方便計算雜湊值，我們寫了一個輔助函式，以達成雜湊兩步驟：<strong>計算雜湊值﹢取模</strong>。其中，我們使用了 Rust 預設的雜湊演算法 <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.DefaultHasher.html">DefaultHasher</a>，省下實作雜湊函數的功夫。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_hash&lt;X&gt;(x: &amp;X, len: usize) -&gt; Option&lt;usize&gt;
    where X: Hash + ?Sized,                   // 1
{
    if len == 0 { return None; }              // 2
    let mut hasher = DefaultHasher::new();    // 3
    x.hash(&amp;mut hasher);
    Some(hasher.finish() as usize % len)
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li><code>X</code> 泛型參數除了 <code>Hash</code>，還必須是 <a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait">Dynamically Sized Type</a>（DST，型別記作 <code>?Sized</code>）</li>
<li>防止以 0 取模（<code>%</code> modulo），除數不能為 0。</li>
<li>Rust 的 hasher 是一狀態機，每餵他吃資料，<code>hasher.finish()</code> 產生的雜湊值就不同，為了確保雜湊相同，這裡每次呼叫就建立一個全新的 hasher。</li>
</ol>
<blockquote>
<p>所謂 <strong>Dynamically Sized Types（DSTs）</strong> 是指無法靜態得知大小的型別，例如 slice，或是一個函式的參數接受實作某個 trait 型別（<a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">trait object</a>），而在 Rust 幾乎所有基礎型別預設都是 <code>Sized</code> 編譯期就可得知大小。而在這裡我們不關心知道實作該型別可否靜態決定大小，只需知道它是否實作 <code>Hash</code>，所以明確添加 <code>?Sized</code> 表示接受 DSTs。</p>
</blockquote>
<h3 id="記憶體佈局"><a class="header" href="#記憶體佈局">記憶體佈局</a></h3>
<p>我們嘗試建立可以儲存 key-value pair 的結構體，裡面配置一個 bucket array <code>buckets</code>。其中 <code>K</code> 泛型參數是準備計算雜湊的鍵，而 <code>V</code> 則是與鍵配對的資料。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct HashMap&lt;K, V&gt; where K: Hash + Eq {
    buckets: Vec&lt;(K, V)&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>可是，用單一 <code>Vec</code> 儲存所有資料，萬一雜湊碰撞，不同鍵指向同個索引值該如何？這次先挑選相對容易的方案 separate chaining 處理碰撞，並以 <code>Vec</code> 動態陣列作為每個 bucket 儲存碰撞元素的容器，因此，<code>buckets</code> 陣列裡面改存 <code>Bucket</code> 陣列，而 <code>Bucket</code> 則儲存真正的 key-value pair。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Bucket&lt;K, V&gt; = Vec&lt;(K, V)&gt;;              // 1

pub struct HashMap&lt;K, V&gt; where K: Hash + Eq {
   buckets: Vec&lt;Bucket&lt;K, V&gt;&gt;,                // 2
   len: usize,                                // 3
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>宣告 bucket 的型別 <code>Bucket</code>，實際上是一個 type alias 指向儲存鍵值 <code>(K, V)</code> 的動態陣列。</li>
<li>將 <code>HashMap.buckets</code> 改為儲存 <code>Bucket</code> 的動態陣列。</li>
<li>新增 <code>len</code> 記錄容器當前鍵值對數目，在增刪資料時， <code>len</code> 都會同步更新。</li>
</ol>
<p>之所以使用額外的成員記錄資料數目，是為了計算數目能在 O(1) 時間內完成，nested array 動態疊代每個 <code>Bucket</code> 計算的成本太高。</p>
<p>這就是 <strong>Vector-based separate chaining HashMap</strong> 的記憶體佈局，來看張精美的雜湊表架構佈局圖吧！</p>
<p><img src="collections/hash_map/layout.svg" alt="" /></p>
<h2 id="基本操作-4"><a class="header" href="#基本操作-4">基本操作</a></h2>
<p>雜湊表有以下幾個基本操作：</p>
<ul>
<li><code>new</code>：初始化一個空雜湊表。</li>
<li><code>with_capacity</code>：配置特定數量 bucket 的雜湊表。</li>
<li><code>get</code>：取得指定鍵對應的資料。</li>
<li><code>get_mut</code>：取得指定鍵對應的資料，並可寫入修改（mutable）。</li>
<li><code>insert</code>：在任意位置插入一組鍵值對。</li>
<li><code>remove</code>：移除任意位置下的鍵值對。</li>
<li><code>clear</code>：清除所有鍵值對。</li>
<li><code>is_empty</code>：檢查雜湊表是否沒有任何鍵值對。</li>
<li><code>len</code>：檢查目前鍵值對的數目。</li>
<li><code>bucket_count</code>：檢查目前 bucket 的數目。</li>
</ul>
<p>以及幾個內部方法：</p>
<ul>
<li><code>try_resize</code>：根據給定條件，決定調整 bucket 數目的時機，讓 load factor 維持最適狀態。</li>
<li><code>make_hash</code>：從輸入資料產生雜湊值，再模除 bucket 數，得到輸入資料對應的索引位置。</li>
</ul>
<p>接下來解釋實作的重點。</p>
<h3 id="初始化與預設值"><a class="header" href="#初始化與預設值">初始化與預設值</a></h3>
<p>雜湊表初始化相對容易，一樣慣例使用 <code>new</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;K, V&gt; HashMap&lt;K, V&gt; where K: Hash + Eq {
    pub fn new() -&gt; Self {
        Default::default()
    }
    /// ...
}

impl&lt;K, V&gt; Default for HashMap&lt;K, V&gt; 
    where K: Hash + Eq 
{
    fn default() -&gt; Self { 
        Self { buckets: Vec::&lt;Bucket&lt;K, V&gt;&gt;::new(), len: 0 }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>這裡為了符合人因工程，使用了 <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> trait 設定初始值。此外，由於 Rust 的容器型別慣例上沒有任何元素時，不會配置任何記憶體空間，僅有初始的 pointer。 HashMap 初始化後，記憶體空間僅需</p>
<ul>
<li><code>buckets</code> 的 <code>Vec</code> 佔據 3 個 usize 大小（一個 heap 指標，兩個記錄容量與長度的 usize。</li>
<li><code>len</code> 本身佔據 1 個 usize 大小。</li>
</ul>
<p>所以預設初始化的 HashMap 在 64bit machine 上佔 4 * usize = 32 bytes。</p>
<p>為了後續實作 resize 容易些，同時實作了指定 bucket 數目的建構式。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn with_capacity(cap: usize) -&gt; Self {
    let mut buckets: Vec&lt;Bucket&lt;K, V&gt;&gt; =  Vec::new();
    for _ in 0..cap {
        buckets.push(Bucket::new());
    }
    Self { buckets, len: 0 }
} 
<span class="boring">}</span></code></pre></pre>
<p>很清楚地，同樣建立一個空的 bucket array，再預先配置給定數量的 <code>Bucket</code> 。<code>len</code> 則因為沒有開始增加新值，而設定為 0。</p>
<h3 id="存取單一元素"><a class="header" href="#存取單一元素">存取單一元素</a></h3>
<p>存取元素的實作也非常直觀，</p>
<ol>
<li>使用 <code>make_hash</code> 計算出 key 對應的索引位置，</li>
<li>再透過 <code>Vec::get</code> 取得該索引下的 bucket，找不到時則返回 <code>None</code>，</li>
<li>找到 bucket 後則對整個 bucket 線性搜索與 key 相同的鍵值對。</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get(&amp;self, key: &amp;K) -&gt; Option&lt;&amp;V&gt; {
    let index = self.make_hash(key)?;
    self.buckets.get(index).and_then(|bucket|
        bucket.iter()
            .find(|(k, _)| *k == *key)
            .map(|(_, v)| v)
    )
}
<span class="boring">}</span></code></pre></pre>
<p>事實上，這個 <code>get</code> 不是非常方便使用，當我們透過 <code>HashMep::get</code> 搜尋特定鍵時，必須傳入一模一樣的型別，例如 <code>HashMap&lt;&amp;str, u8&gt;</code> 就只能透過相同的 borrowed value <code>&amp;str</code> 搜索，而不能透過 owned value <code>&amp;String</code> 尋找，就算兩個型別可無痛轉換也無法。</p>
<p>因此我們可以參考 Rust 標準函式庫為泛型參數 <code>K</code> 實作 <a href="https://doc.rust-lang.org/stable/std/borrow/trait.Borrow.html">Borrow</a> trait，抽象化 owned 與 borrowed 間的型別，讓呼叫端無論傳 owned 或 borrowed 型別都可以有相同的行為。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get&lt;Q&gt;(&amp;self, q: &amp;Q) -&gt; Option&lt;&amp;V&gt;
    where
        K: Borrow&lt;Q&gt;,
        Q: Hash + Eq + ?Sized
{
    let index = self.make_hash(q)?;
    self.buckets.get(index).and_then(|bucket|
        bucket.iter()
            .find(|(k, _)| q == k.borrow())
            .map(|(_, v)| v)
    )
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><code>fn get_mut()</code> 與 <code>fn get()</code> 的差異只在於呼叫了 <code>self.bucket.get_mut</code> 取得 mutable reference，這裡就不多做說明。</p>
</blockquote>
<h3 id="插入與刪除元素"><a class="header" href="#插入與刪除元素">插入與刪除元素</a></h3>
<p>插入與刪除比較特別，需要做些額外的功夫：</p>
<ul>
<li>在操作完成之後需依據操作結果增減 <code>HashMap.len</code>，確保 <code>len</code> 永遠記錄正確的鍵值對數目。</li>
<li>在執行插入之前，需額外「動態調整」儲存空間，確保記憶體配置足夠空間新增元素。</li>
</ul>
<p>先來看看刪除怎麼實作。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn remove&lt;Q&gt;(&amp;mut self, q: &amp;Q) -&gt; Option&lt;V&gt;
    where
        K: Borrow&lt;Q&gt;,
        Q: Hash + Eq + ?Sized
{
    let index = self.make_hash(q)?;                     // 1
    self.buckets.get_mut(index).and_then(|bucket| {     // 2
        bucket.iter_mut()
            .position(|(k, _)| q == (*k).borrow())
            .map(|index| bucket.swap_remove(index).1)
    }).map(|v| {                                        // 3
        self.len -= 1; // Length decreases by one.
        v
    })
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>所有涉及搜尋的操作，第一步一定是計算雜湊值。</li>
<li>建立 mutable 的疊代器，利用 <a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.position"><code>posiion</code></a> 找到對應的鍵值對，再呼叫 <code>Vec::swap_remove</code> 移除。</li>
<li>前一步驟若有 return value 產生，表示移除一個元素，因此 <code>self.len</code> 需手動減一。</li>
</ol>
<blockquote>
<p><code>Vec::swap_remove</code> 不需要 resize array，而是取得最後一個元素填補該空間，由於雜湊表的排序不重要，我們選擇 <code>swap_remove</code> 減少一點開銷。</p>
</blockquote>
<p>而插入與移除非常相似。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn insert(&amp;mut self, key: K, value: V) -&gt; Option&lt;V&gt; {
    self.try_resize();                                      // 1
    let index = self                                        // 2
        .make_hash(&amp;key)
        .expect("Failed to make a hash while insertion");
    let bucket = self.buckets
        .get_mut(index)
        .expect(&amp;format!("Failed to get bucket[{}] while insetion", index));
    match bucket.iter_mut().find(|(k, _)| *k == key) {      // 3
        Some((_ , v)) =&gt;  Some(mem::replace(v, value)),     // 3.1
        None =&gt; {
            bucket.push((key , value));                     // 3.2
            self.len += 1;
            None
        }
    }                                                       // 4
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>嘗試調整雜湊表大小，以確保 load factor 在閾值之間。</li>
<li>同樣地，根據鍵計算雜湊值，以取得對應的內部 bucket 位置。</li>
<li>疊代整個 bucket 尋找鍵相同的鍵值對。
<ol>
<li>若找到，使用 <a href="https://doc.rust-lang.org/stable/std/mem/fn.replace.html"><code>mem::replace</code></a> 資料部分，不需取代整個鍵值對。</li>
<li>若找無，則新增一組新鍵值對到該 bucket 中，並將長度加一。</li>
</ol>
</li>
<li>若插入操作實際上是更新原有資料，則回傳被更新前的舊資料 <code>Some((K, V))</code>，反之則回傳 <code>None</code>。</li>
</ol>
<blockquote>
<ul>
<li>原則上「動態調整儲存空間」正確實作下，步驟二的 <code>expect</code> 不會發生 panic。</li>
<li><code>mem::replace</code> 可當作將同型別兩變數的記憶體位置互換，也就同時更新了原始資料。</li>
</ul>
</blockquote>
<h3 id="動態調整儲存空間"><a class="header" href="#動態調整儲存空間">動態調整儲存空間</a></h3>
<p>動態調整儲存空間大概是整個實作中最詭譎的一部分。首先，我們需要知道</p>
<ul>
<li>容器內鍵值對的總數：透過 <code>self.len</code>，我們將取得 <code>self.len</code> 的邏輯包裝在 <code>fn len(&amp;self)</code>，以免未來長度移動至別處儲存計算。</li>
<li>容器內 bucket 的總數：計算 <code>self.bucket.len()</code>，同樣地，將之包裝在 <code>fn bucket_count(&amp;self)</code>，並開放給外界呼叫。</li>
<li>Load factor 閾值：記錄在 <code>const LOAD_FACTOR</code>，設定為 0.75。</li>
</ul>
<p>前情提要完畢，接下來就是程式碼的部分了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn try_resize(&amp;mut self) {
    let entry_count = self.len();                               // 1
    let capacity = self.bucket_count();

    // Initialization.
    if capacity == 0 {                                          // 2
        self.buckets.push(Bucket::new());
        return
    }

    if entry_count as f64 / capacity as f64 &gt; LOAD_FACTOR {     // 3
        // Resize. Rehash. Reallocate!
        let mut new_map = Self::with_capacity(capacity &lt;&lt; 1);   // 4
        self.buckets.iter_mut()                                 // 5
            .flat_map(|bucket| mem::replace(bucket, vec![]))
            .for_each(|(k, v)| { new_map.insert(k, v); });
        *self = new_map;                                        // 6
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>取得所有需要用到的長度資料。</li>
<li>若當前容量為 0，表示尚未新增任何元素，我們 push 一個空 bucket 進去，讓其他操作可以正常新增鍵值對。</li>
<li>判斷 load factor，決定需不需要動態調整大小。</li>
<li>透過 <code>HashMap::with_capacity</code> 建立容量兩倍大的空雜湊表。</li>
<li>開始疊代舊的 bucket，並利用 <a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.flat_map"><code>flat_map</code></a> 打平 nested vector，再利用 <a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.for_each"><code>for_each</code></a> 將每個元素重新 insert 到新雜湊表。</li>
<li>把 <code>self</code> 的值指向新雜湊表，舊雜湊表的記憶體空間會被釋放。</li>
</ol>
<h3 id="實作疊代器方法"><a class="header" href="#實作疊代器方法">實作疊代器方法</a></h3>
<p>一個集合型別當然少不了簡易的產生疊代器實作。</p>
<p>根據之前其他方法的實作，要疊代整個雜湊表非常簡單，就是疊代所有 bucket，並利用 <code>flat_map</code> 打平 nested vector。簡單實作如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn iter() -&gt; std::slice::Iter&lt;(&amp;k, &amp;v)&gt; {
    self.buckets.iter_mut()
        .flat_map(|b| b)
        .map(|(k, v)| (k, v))
}
<span class="boring">}</span></code></pre></pre>
<p>但最終會發現，我們的程式完全無法編譯，也無法理解這麼長的閉包（closure）究竟要如何寫泛型型別。得了吧 Rust，老子學不動了！</p>
<pre><code>error[E0308]: mismatched types
   --&gt; src/collections/hash_map/mod.rs:253:9
    |
253 | /         self.buckets.iter()
254 | |             .flat_map(|b| b)
255 | |             .map(|(k, v)| (k, v))
    | |_________________________________^ expected struct `std::slice::Iter`, found struct `std::iter::Map`
    |
    = note: expected type `std::slice::Iter&lt;'_, (&amp;K, &amp;V)&gt;`
               found type `std::iter::Map&lt;std::iter::FlatMap&lt;std::slice::Iter&lt;'_, std::vec::Vec&lt;(K, V)&gt;&gt;, &amp;std::vec::Vec&lt;(K, V)&gt;, [closure@src/collections/hash_map/mod.rs:254:23: 254:28]&gt;, [closure@src/collections/hash_map/mod.rs:255:18: 255:33]&gt;`
</code></pre>
<p>幸好，在 Rust 1.26 釋出時，大家期待已久的 <strong>impl trait</strong> 穩定了。如同字面上的意思，impl trait 可以用在函式參數與回傳型別的宣告中。代表這個型別有 impl 對應的 trait，所以不必再寫出落落長的 Iterator 泛型型別。impl trait 有另一個特點是以靜態分派（static dispatch）來呼叫函式，相較於 trait object 的<a href="https://en.wikipedia.org/wiki/Dynamic_dispatch">動態分派（dynamic dispatch）</a>，impl trait 毫無效能損失。</p>
<p>實作如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn iter(&amp;self) -&gt; impl Iterator&lt;Item = (&amp;K, &amp;V)&gt; {
    self.buckets.iter()
        .flat_map(|b| b)
        .map(|(k, v)| (k, v))
}
<span class="boring">}</span></code></pre></pre>
<p>更多 impl trait 相關資訊可以參考：</p>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md">Rust RFC: impl trait</a></li>
<li><a href="https://blog.rust-lang.org/2018/05/10/Rust-1.26.html#impl-trait">Rust 1.26: impl trait</a></li>
<li><a href="https://doc.rust-lang.org/reference/types.html#trait-objects">Rust Reference: Trait objects</a></li>
<li><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">The Rust Programming Language: Trait objects</a></li>
</ul>
<h2 id="效能-18"><a class="header" href="#效能-18">效能</a></h2>
<p>以陣列實作的雜湊表各操作複雜度如下</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Best case</th><th>Worst case</th></tr></thead><tbody>
<tr><td>add(k, v)</td><td>$O(1)$~</td><td>$O(n)$</td></tr>
<tr><td>update(k, v)</td><td>$O(1)$</td><td>$O(n)$</td></tr>
<tr><td>remove(k)</td><td>$O(1)$~</td><td>$O(n)$</td></tr>
<tr><td>search(k)</td><td>$O(1)$</td><td>$O(n)$</td></tr>
</tbody></table>
</div>
<blockquote>
<p>$n$：資料筆數。<br />
$k$：欲綁定資料的鍵。<br />
$v$：欲與鍵綁定的資料。<br />
<strong>~</strong>：平攤後的複雜度（amortized）。</p>
</blockquote>
<h3 id="時間複雜度"><a class="header" href="#時間複雜度">時間複雜度</a></h3>
<p>在預期情況下，只要雜湊函數品質穩定，大部分操作都可達到在常數時間， 但由於部分操作，尤其是新增或刪除元素的操作，會需要調整 bucket array 的空間，重新配置記憶體空間，所以需要平攤計算複雜度。</p>
<p>而最差複雜度出現在每個元素都發生雜湊碰撞。若使用 open addressing 處理碰撞，則會把雜湊表配置的每個位置都填滿，而所有操作都從同個位置開始，搜尋對應的鍵，複雜度與陣列的線性搜索相同為 $O(n)$；若使用 separate chaining，碰撞代表所有元素都會在同一個 bucket 裡面，也就是只有一個 bucket 上會有一個長度為 <em>n</em> ，被塞滿的陣列或鏈結串列，結果同樣是線性搜索的 $O(n)$。</p>
<p>我們嘗試使用數學表示搜索的複雜度。另</p>
<ul>
<li>$n$：已放入雜湊表內的資料總數。</li>
<li>$k$：雜湊表配置的儲存空間（bucket 總數）。</li>
<li>$\text{load factor} = \frac{n}{k}$：預期每個 bucket 儲存的資料筆數。</li>
</ul>
<p>則預期執行時間為</p>
<p>$$\Theta(1+\frac{n}{k}) = O(1) \ \text{ if } \frac{n}{k} = O(1)$$</p>
<p>而 <strong>1</strong> 為計算雜湊與取得索引（random access）的執行時間，$\frac{n}{k}$ 則是搜尋陣列的執行時間。只要 load factor 越接近 $n$，執行時間就相對增加。</p>
<h3 id="空間複雜度"><a class="header" href="#空間複雜度">空間複雜度</a></h3>
<p>雜湊表的空間複雜度取決於實作預先配置的陣列大小，並與維持 <em>load factor</em> 息息相關。一般來說，仍與資料筆數成線性關係，因此空間複雜度只有資料本身 $O(n)$。而以 separate chaining 會額外配置陣列或鏈結串列儲存碰撞元素，理論上需負擔更多額外的指標儲存空間。</p>
<h2 id="參考資料-21"><a class="header" href="#參考資料-21">參考資料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/collections/hash_map/index.html">Rust Documentation: HashMap</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hash_table">Wiki: Hash table</a></li>
<li><a href="https://en.wikipedia.org/wiki/Open_addressing">Wiki: Open addressing</a></li>
<li><a href="https://algs4.cs.princeton.edu/34hash/">Algorithms, 4th Edition by R. Sedgewick and K. Wayne: 3.4 Hash Tables</a></li>
<li><a href="https://courses.csail.mit.edu/6.006/fall11/notes.shtml">MIT 6.006: Introduction to Algorithms, fall 2011: Unit 3 Hashing</a></li>
<li>Map graph by Jorge Stolfi <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA-3.0</a> via Wikimedia Commons.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集合-set-1"><a class="header" href="#集合-set-1">集合 Set</a></h1>
<p>集合是一種抽象資料型別（Abstract data type），概念衍生自數學的<a href="https://en.wikipedia.org/wiki/Set_theory">集合論</a>，和陣列類似，為不同元素所組成的資料結構，不同在於集合有些重要的特性：</p>
<ul>
<li>無序性：集合內各元素無特定排序或排序不重要。</li>
<li>互異性：集合內每個元素且只能出現一次。</li>
</ul>
<p>一般來說，集合的實作會盡量貼近集合論中的有限集合定義，本次實作同樣遵照數學定義。</p>
<blockquote>
<p>本次實作的程式碼置於 <a href="collections/set//doc/rust_algorithm_club/collections/struct.HashSet.html"><code>rust_algorithm_club::collections::HashSet</code></a> API 文件中。</p>
</blockquote>
<h2 id="架構設計-4"><a class="header" href="#架構設計-4">架構設計</a></h2>
<h3 id="以雜湊表為底層容器"><a class="header" href="#以雜湊表為底層容器">以雜湊表為底層容器</a></h3>
<p>集合能以許多不同的資料結構實現，通用的集合實作多會最佳化取得、增加、移除元素等運算，這讓我們想到了「<a href="collections/set/../hash_map">雜湊表</a>」，雜湊表正是能將集合運算最佳化的一種資料結構，我們將借用<strong>雜湊表作為底層儲存容器</strong>，進一步實作集合。</p>
<p>你可能好奇，集合明明只有元素，並沒有<strong>鍵值對</strong>，跟雜湊表有啥關係？讓我們回想雜湊表一個重要的特性：每一個鍵（key）只會出現一次，利用雜湊表這個特性，即可達成上述集合兩大特性。</p>
<p>既然選用雜湊表作為底層容器，集合的結構體就非常簡單了，我們可以將集合想像為在 HashMap 薄薄的一層封裝。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct HashSet&lt;T&gt;
where
    T: Hash + Eq,
{
    hash_map: HashMap&lt;T, ()&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>比較特別的是雜湊表的鍵值，這裡使用空的 tuple <code>()</code>，也就是以 <a href="https://doc.rust-lang.org/std/primitive.unit.html">unit type</a> 作為雜湊表之值，只要將集合的元素作為雜湊表鍵，忽略對應的值，就是貨真價實的集合結構。</p>
<h3 id="不佔空間的-unit-type"><a class="header" href="#不佔空間的-unit-type">不佔空間的 Unit Type</a></h3>
<p>這樣多儲存一個 <code>()</code> 會不會造成額外的儲存空間負擔？事實上，Unit type <code>()</code> 在 Rust 語言中是一種 <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">Zero Sized Types (ZSTs)</a>，在編譯時期 Rust 會將 ZST 當作一種型別來操作，但真正輸出的機器碼中，ZST 並不會佔用任何運算空間。<code>Set = HashMap&lt;T, ()&gt;</code> 完全體現了 Rust 零成本抽象的語言特性。</p>
<h2 id="基本操作-5"><a class="header" href="#基本操作-5">基本操作</a></h2>
<p>身為一個容器，集合有以下幾個基本操作：</p>
<ul>
<li><code>new</code>：初始化一個集合。</li>
<li><code>contains</code>：檢查集合內有無特定元素。</li>
<li><code>is_empty</code>：檢查集合內是否沒有任何元素。</li>
<li><code>insert</code>：新增一個元素。</li>
<li><code>remove</code>：移除特定元素。</li>
<li><code>len</code>：檢查集合內的元素數目。</li>
<li><code>iter</code>：產生一個疊代集合內所有元素的疊代器。</li>
</ul>
<p>這些基本操作的實作上，只是對雜湊表的簡單封裝，詳細實作可以參考 <a href="collections/set/../hash_map">HashMap</a>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; HashSet&lt;T&gt;
where
    T: Hash + Eq,
{
    pub fn len(&amp;self) -&gt; usize {
        self.hash_map.len()
    }

    pub fn is_empty(&amp;self) -&gt; bool {
        self.hash_map.is_empty()
    }

    pub fn insert(&amp;mut self, value: T) -&gt; bool { // 1
        self.hash_map.insert(value, ()).is_none()
    }

    pub fn contains&lt;Q&gt;(&amp;self, value: &amp;Q) -&gt; bool // 2
    where
        T: Borrow&lt;Q&gt;,
        Q: Hash + Eq + ?Sized,
    {
        self.hash_map.get(value).is_some()
    }

    pub fn remove&lt;Q&gt;(&amp;mut self, value: &amp;Q) -&gt; bool // 3
    where
        T: Borrow&lt;Q&gt;,
        Q: Hash + Eq + ?Sized,
    {
        self.hash_map.remove(value).is_some()
    }

    pub fn iter(&amp;self) -&gt; impl Iterator&lt;Item = &amp;T&gt; { // 4
        self.hash_map.iter().map(|(k, _)| k)
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li><code>insert</code> 將元素置於 key 上，value 則設為 <code>()</code>。</li>
<li><code>contains</code> 利用 <code>HashMap::get</code> 回傳的 <code>Option&lt;()&gt;</code> 判斷是否已有該的元素。</li>
<li><code>remove</code> 同樣直接呼叫 <code>HashMap::remove</code>，並透過回傳 <code>Option&lt;()&gt;</code> 判斷實際上是否有移除任何元素。</li>
<li><code>iter</code> 則直接利用 <code>HashMap::iter</code> 並捨棄 value。</li>
</ol>
<h2 id="集合運算"><a class="header" href="#集合運算">集合運算</a></h2>
<p>電腦科學的集合型別衍生自<a href="https://en.wikipedia.org/wiki/Set_theory">集合論</a>，當然也得符合<a href="https://en.wikipedia.org/wiki/Algebra_of_sets">集合代數（set algebra）</a>的特性，和算術的加減乘除，集合也有自己的二元運算，我們會實作以下幾個基本方法：</p>
<ul>
<li><code>intersection</code>：交集，A ∩ B 定義為 A 與 B 共有的元素。</li>
<li><code>union</code>：聯集，A ∪ B 定義為 A 與 B 所有的元素。</li>
<li><code>symmetric_difference</code>：對稱差集，定義為 A △ B = (A ∪ B) - (A ∩ B)，就是只出現在 A 或 B，不會在兩集合內同時出現的元素。</li>
<li><code>difference</code>：差集，A \ B 定義為 A 中所有未在 B 中出現的元素。</li>
</ul>
<p><img src="https://i.imgur.com/jeLakB0.png" alt="venn digrams" /></p>
<p>此外，也會介紹許多方便的方法：</p>
<ul>
<li><code>is_disjoint</code>：兩集合是否不交集。</li>
<li><code>is_subset</code>：包含於 ⊆，是否為子集。</li>
<li><code>is_superset</code>：包含 ⊇，是否為超集。</li>
</ul>
<p>哇！好多方法要實作。那就事不宜遲！</p>
<h3 id="實作聯集"><a class="header" href="#實作聯集">實作聯集</a></h3>
<h4 id="第一次嘗試---建立新的聯集集合"><a class="header" href="#第一次嘗試---建立新的聯集集合">第一次嘗試 - 建立新的聯集集合</a></h4>
<p>要取得兩個集合的聯集，最直覺的想法可能是創造一個新的集合，再把 A 和 B 兩個集合的元素通通 <code>insert</code> 進去，就像這樣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 利用 Clone 實現的聯集。完整實作見 bit.ly/caab7fb
pub fn union(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; HashSet&lt;T&gt; {
    // 複製一整份 other 到新的 set
    let mut new_set: HashSet&lt;T&gt; = other.clone();

    // 把現有的 item 一一塞到新的 set，重複的 item 會直接覆寫掉
    self.hash_map.iter().for_each(|(k, _)| {
        new_set.insert(k.clone());
    });

    // 回傳 self 與 other 的聯集
    new_set
}
<span class="boring">}</span></code></pre></pre>
<p>然而，上述做法有兩個缺點：</p>
<ol>
<li>建立了一個全新的 HashSet 實例，花了額外的時間與空間</li>
<li>必須為 <code>HashSet</code> 和 item 的型別 <code>T</code> 額外加上 <code>Clone</code> trait 的限制</li>
</ol>
<p>因此接下來我們嘗試利用 Rust 的 <code>iterator</code> 的特性實現更節省資源的版本！</p>
<blockquote>
<p>更多詳情可參考實作過程的<a href="https://github.com/weihanglo/rust-algorithm-club/pull/15#issuecomment-427587785">討論串</a>與<a href="https://github.com/weihanglo/rust-algorithm-club/pull/15/commits/caab7fbc5323e09eb1e30ea374eb21a59f955bad">第一次嘗試的完整實作</a>。</p>
</blockquote>
<h4 id="第二次嘗試---lazy-iterator"><a class="header" href="#第二次嘗試---lazy-iterator">第二次嘗試 - Lazy Iterator</a></h4>
<p>有了第一次嘗試的經驗，第二次決定讓 <code>union()</code> 回傳一個 lazy iterator，會疊代聯集的元素，必要才從疊代器收集所有元素，再建立新的集合，如此可以節省許多運算資源。</p>
<p>至於實作步驟，我們可以：</p>
<ol>
<li>先製造一個疊代器，包含所有 <code>other</code> 集合的元素，但過濾掉與 <code>self</code> 共有的元素。</li>
<li>再將 <code>self</code> 的疊代器與步驟一產生的疊代器，利用 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain"><code>Iterator::chain</code></a> 連起來。</li>
</ol>
<p>這樣其實就是 <code>other \ self</code> 這個差集，加上 <code>self</code> 自身，剛好就是聯集。程式碼如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 使用 impl trait 語法，避免宣告不同疊代器型別的麻煩。
pub fn union(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;T&gt; {
    // 實際上就是差集
    let other_but_not_self = other.iter().filter(|item| !self.contains(item));
    // 差集 + self 本身
    self.iter().chain(other_but_not_self)
}
<span class="boring">}</span></code></pre></pre>
<h4 id="lifetime-elision"><a class="header" href="#lifetime-elision">Lifetime Elision</a></h4>
<p>但很不幸地，Compiler error E0623（甚至查不到 E0623 是什麼）。</p>
<pre><code class="language-bash">error[E0623]: lifetime mismatch
   --&gt; src/collections/set/mod.rs:117:48
    |
117 |     pub fn union(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;T&gt; {
    |                                -----------     ^^^^^^^^^^^^^^^^^^^^^^^^
    |                                |               |
    |                                |               ...but data from `other` is returned here
    |                                this parameter and the return type are declared with different lifetimes...
</code></pre>
<p>是 <code>self</code> 與 <code>other</code> 的生命週期不同導致，當這兩個集合的疊代器被 chain 起來後回傳，編譯器無法確認 Iterator 的 Item 生命週期多長。你可能很好奇為什麼 <code>self</code> 與 <code>other</code> 生命週期不同，事實上，Rust 為了讓語法輕鬆一點，允許函數省略部分生命週期標註，這個行為稱作 <a href="https://doc.rust-lang.org/nomicon/lifetime-elision.html">Lifetime Elision</a>，會在各種不同的條件下加註生命週期，其中有一條是「<strong>每個被省略的生命週期都會成為獨立的生命週期</strong>」。因此，<code>union()</code> 加上被省略的生命週期，會長得像：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn union&lt;'a, 'b&gt;(&amp;'a self, other: &amp;'b HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;'a ??? &amp;'b ???T&gt;;
<span class="boring">}</span></code></pre></pre>
<p>於是乎，編譯器無法理解 Iterator&lt;Item = &amp;T&gt; 的 <code>&amp;T</code> 到底生命週期是 ’a 還是 ’b，就不給編譯。</p>
<p>解法也很簡單，合併 <code>self</code> 與 <code>other</code> 的生命週期到同一個，不論是語意上（兩個集合至少活得一樣長）還是編譯條件都說得通。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 加上 'a ，讓 self、other 的生命週期至少在這個函數內一樣長
pub fn union&lt;'a&gt;(&amp;'a self, other: &amp;'a HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;T&gt; {
    let other_but_not_self = other.iter().filter(|item| !self.contains(item));
    self.iter().chain(other_but_not_self)
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>更多 Lifetime Elision 的資訊，可以參考 <a href="https://doc.rust-lang.org/nomicon/lifetime-elision.html">Rust 黑魔法 Nomicon</a> 與 <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">Rust TRPL 的解釋</a>，還有相關的 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0141-lifetime-elision.md">RFC</a> 可以看。</p>
</blockquote>
<h4 id="move-closure"><a class="header" href="#move-closure"><code>move</code> closure</a></h4>
<p>解決了生命週期，編譯看看就知道誰沒穿褲子。<a href="https://doc.rust-lang.org/error-index.html#E0373">Compiler error E0373</a>，是野生的 borrow checker！</p>
<pre><code class="language-bash">error[E0373]: closure may outlive the current function, but it borrows `self`, which is owned by the current function
   --&gt; src/collections/set/mod.rs:118:53
    |
118 |         let other_but_not_self = other.iter().filter(|item| !self.contains(item));
    |                                                     ^^^^^^  ---- `self` is borrowed here
    |                                                     |
    |                                                     may outlive borrowed value `self`
    |
note: closure is returned here
   --&gt; src/collections/set/mod.rs:119:9
    |
119 |         self.iter().chain(other_but_not_self)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `self` (and any other referenced variables), use the `move` keyword
    |
118 |         let other_but_not_self = other.iter().filter(move |item| !self.contains(item));
</code></pre>
<p>讓我們嘗試理解，當我們回傳 iterator 時，整個過濾共同元素的 closure 會連帶一起回傳，若 closure 沒有使用 <code>move</code> 關鍵字修飾，編譯器會嘗試以傷害最小的方式去捕獲變數，在這裡會是 immutable borrow <code>&amp;T</code> 捕獲。這裡的 <code>self</code> 實際型別是 <code>&amp;'a mut HashSet&lt;T&gt;</code>，可以想像成 closure 捕獲了 <code>&amp;(&amp;'a mut HashSet&lt;T&gt;)</code>。</p>
<blockquote>
<p>Rust 編譯器遇到 closure 需要捕獲變數時，如果沒有用 <code>move</code> 修飾，會嘗試使用以下順序來捕獲： <code>&amp;T</code> &gt; <code>&amp;mut T</code> &gt; <code>T</code>。若用了 <code>move</code> 修飾，則會直接將所有權轉移進 clousure 中，也就是捕獲 <code>T</code>。</p>
</blockquote>
<p>可惜的是，多出來的這層 borrow 並沒有相同的生命週期 <code>'a</code>，編譯器無法識別它會活到什麼時候，可能 <code>self</code> 的資源已被釋放，但 closure 還沒結束，有機會產生 <a href="https://en.wikipedia.org/wiki/Dangling_pointer">dangling pointer</a>，編譯器因此禁止這種危險操作。</p>
<p>編譯器也十分好心地提示，只要使用 <code>move</code> 關鍵字，將 <code>self</code> 的所有權轉移至 closure 中，就能避免生命週期不一致的問題。你可能有些疑惑，把 <code>self</code> move 進 closure 之後，<code>self</code> 不就會被 drop 釋放掉了？可以這樣理解，轉移進 closure 的型別是整個 <code>self</code>，也就是 <code>&amp;'a mut HashSet&lt;T&gt;</code> 型別，解讀為編譯器將 <code>self</code> 的型別看作新的 owned type，所有權可合法轉移，但底層仍保留指向原始資料的 borrow，巧妙避開生命週期問題。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn union&lt;'a&gt;(&amp;'a self, other: &amp;'a HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;T&gt; {
    // 用 move 修飾 closure
    // self（&amp;'a HashSet&lt;T&gt;）被整個轉移進 closure
    let other_but_not_self = other.iter().filter(move |item| !self.contains(item));
    self.iter().chain(other_but_not_self)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="實作交集差集與對稱差集"><a class="header" href="#實作交集差集與對稱差集">實作交集、差集與對稱差集</a></h3>
<p>呼，上面解決了最困難的生命週期和 borrow checker 問題，接下來的實作只要關注數學上的集合定義就能輕鬆解決了。</p>
<p>首先，交集的定義為「你有，而且我也有的」，簡單，疊代 <code>self</code> 並過濾出 <code>other</code> 也有的元素就好，秒殺！</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn intersection&lt;'a&gt;(&amp;'a self, other: &amp;'a HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;T&gt; {
    self.iter().filter(move |item| other.contains(item))
}
<span class="boring">}</span></code></pre></pre>
<p>再來是差集，概念是就是「我有，但你沒有的」，一樣疊代 <code>self</code> 並過濾出 <code>other</code> 沒有的元素。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn difference&lt;'a&gt;(&amp;'a self, other: &amp;'a HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;T&gt; {
    self.iter().filter(move |item| !other.contains(item))
}
<span class="boring">}</span></code></pre></pre>
<p>剛剛實作 <code>union</code> 有用到差集，我們可以稍微改寫，讓 <code>union</code> 的程式碼更神清氣爽。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn union&lt;'a&gt;(&amp;'a self, other: &amp;'a HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;T&gt; {
    // self ∪ (other \ self)
    self.iter().chain(other.difference(self))
}
<span class="boring">}</span></code></pre></pre>
<p>最後，對稱差集可以透過組合上面的操作算出，可以是：「我有加上你有的，減去我們共同有的」，也可以是「我有但你沒有的，加上你有但我沒有的」，這裡我們選擇第二種實作。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn symmetric_difference&lt;'a&gt;(&amp;'a self, other: &amp;'a HashSet&lt;T&gt;) -&gt; impl Iterator&lt;Item = &amp;T&gt; {
    // (self \ other) ∪ (other \ self)
    self.difference(other).chain(other.difference(self))
}
<span class="boring">}</span></code></pre></pre>
<p>整個集合的基礎在這邊大功告成了！</p>
<h3 id="子集超集與不交集"><a class="header" href="#子集超集與不交集">子集、超集與不交集</a></h3>
<p>經歷 Rust 編譯器的摧殘，來實作比較簡單的方法吧。集合運算常要比較兩個集合的關係，例如 A ⊆ B 代表 A 是 B 的子集，定義是 A 裡面的元素 B 都有。</p>
<p>我們先來實作 <code>is_subset</code> 檢查 <code>self</code> 是否為 <code>other</code> 的子集。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn is_subset(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; bool {
    // 若 self 的元素比 other 多，就不可能是 self ⊆ other
    // 所以提前回傳 false
    if self.len() &gt; other.len() {
        return false;
    }
    // 利用 all 確認 other 內包含 self 的所有元素
    self.iter().all(|item| other.contains(&amp;item))
}
<span class="boring">}</span></code></pre></pre>
<p><code>is_superset</code> 檢查 <code>self</code> 是否為 <code>other</code> 的超集就更簡單了，只要把 <code>is_subset</code> 反過來使用就行了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn is_superset(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; bool {
    // self ⊇ other = other ⊆ self
    other.is_subset(self)
}
<span class="boring">}</span></code></pre></pre>
<p>最後，我們常會檢查兩個集合是否沒有交集（disjoint），這個方法只要檢查交集 <code>intersection()</code> 疊代器的長度是否為 0 就可以了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn is_disjoint(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; bool {
    self.intersection(other).count() == 0
}
<span class="boring">}</span></code></pre></pre>
<h2 id="二元運算與運算子"><a class="header" href="#二元運算與運算子">二元運算與運算子</a></h2>
<p>上面的方法好冗，能不能和 <a href="https://docs.python.org/3/library/stdtypes.html#set">Python</a> 一樣，用簡單明瞭的語法操作集合的二元運算？當然行，Rust 的表達性很強，完全不輸 Python，透過<a href="https://en.wikipedia.org/wiki/Operator_overloading">運算子多載（operator overloading）</a>。</p>
<h3 id="運算子多載"><a class="header" href="#運算子多載">運算子多載</a></h3>
<p>Rust 提供許多 trait 供使用者多載運算子，可以簡化集合的二元運算：</p>
<ul>
<li><code>set | other</code>：bitwise or 運算子，效果同 <code>union</code> 聯集。</li>
<li><code>set &amp; other</code>：bitwise and 效果同 <code>intersection</code> 交集。</li>
<li><code>set - other</code>：substraction 運算子，效果同 <code>difference</code> 差集。</li>
<li><code>set ^ other</code>：bitwise xor 運算子，效果同 <code>symmetric_difference</code> 對稱差集。</li>
</ul>
<p>由於四個運算子實作的概念相同，這裡挑 <code>|</code> <strong>bitwise or</strong> 來解釋如何客製化運算子邏輯。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 實作 BitOr 多載 `|` 運算子
impl&lt;'a, 'b, T&gt; BitOr&lt;&amp;'b HashSet&lt;T&gt;&gt; for &amp;'a HashSet&lt;T&gt;
where
    T: Hash + Eq + Clone, // 實作 Clone 讓 Set 可透過 FromIterator 建立實例
{
    type Output = HashSet&lt;T&gt;;

    fn bitor(self, rhs: &amp;'b HashSet&lt;T&gt;) -&gt; Self::Output {
        // 利用 FromIterator 提供的 collect() 蒐集元素，產生新 Set
        self.union(&amp;rhs).cloned().collect()
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>要多載 bit or 運算子，代表型別要實作 <code>BitOr</code> trait。</li>
<li>由於運算子的 required method 通常會 consume <code>self</code> 的所有權，因此我們要在 impl 動手腳，改以 <code>&amp;HashSet&lt;T&gt;</code> 作為 <code>BitOr</code> 實作的對象。</li>
<li>為了簡化實作，交集聯集等運算子改為產生一個新的 Set 實例，也就是說，<code>T</code> 泛型型別需要實現 <code>Clone</code> trait，才能複製舊的值產生新的 Set。</li>
</ol>
<blockquote>
<p>多載運算子，可以參考 <a href="https://doc.rust-lang.org/beta/std/ops/index.html">Overloadable operators</a> 一頁的說明。</p>
</blockquote>
<h3 id="比較運算子"><a class="header" href="#比較運算子">比較運算子</a></h3>
<p>除了交集、聯集等運算，我們還可以實作集合間的比較，作為檢查是否為子集或超集的運算子。</p>
<ul>
<li><code>A &lt;= B</code>：效果同 <code>is_subset</code>，A 是否為 B 的子集 A ⊆ B。</li>
<li><code>A &lt; B</code>：A 是否為 B 的子集且不等於 B，等同於 A ⊂ B。</li>
<li><code>A &gt;= B</code>：效果同 <code>is_superset</code>，A 是否為 B 的超集 A ⊇ B。</li>
<li><code>A &gt; B</code>：A 是否為 B 的超集且不等於 B，等同於 A ⊃ B。</li>
</ul>
<p>但眼尖的 Rustacean 肯定會發現，<a href="https://doc.rust-lang.org/beta/std/ops/index.html"><code>std::ops</code></a> 裡面根本沒有 <code>lt</code>、<code>gt</code> 等比較運算子。Rust 的「比較」是透過實作幾個 Trait 後，自動推導生成的方法，這些 trait 放在 <a href="https://doc.rust-lang.org/std/cmp/index.html"><code>std::cmp</code></a> module 中，分別是<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>、<a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>ParitalEq</code></a>、<a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>，以及 <a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>ParitalOrd</code></a>。</p>
<p>在開始介紹如何實作比較前，先讓複習一下離散數學學到的二元關係：</p>
<p>若 ∼ 為一種二元關係，A 為任意集合。</p>
<ul>
<li>自反性（Reflexive）：對所有 x ∈ A : x ∼ x。</li>
<li>對稱性（Symmetric）：對所有 x, y ∈ A ，若 x ∼ y 則 y ∼ x。</li>
<li>傳遞性（Transitive）：對所有 x, y, z ∈ A ，若 x ∼ y 且 y ∼ z 則 x ∼ z。</li>
<li>反對稱（Antisymmetric）：對所有 x, y ∈ A，若 x ∼ y 且 x ≠ y 則 y ∼ x 不成立。</li>
</ul>
<p>Rust 中的相等關係有其理論背景，<code>Eq</code> 就是數學上的 <a href="https://en.wikipedia.org/wiki/Equivalence_relation">Equivalence relation</a>，須符合自反性、對稱性，及傳遞性；與之對應的是 <code>PartialEq</code>，<a href="https://en.wikipedia.org/wiki/Partial_equivalence_relation">Partial equivalence</a> 具有對稱性和傳遞性，但並無自反性，有名的例子是 <a href="https://ieeexplore.ieee.org/document/4610935">IEEE754 的浮點數</a> 定義了 <code>NaN == NaN -&gt; false</code>，浮點數因此不符合自反性定義。</p>
<p>回到集合，集合論中的集合相等（set equality）定義為：x = y ⇒ ∀z, (z ∈ x ⇔ z ∈ y)，也就所有屬於集合 x 的元素必屬於集合 y，反之亦然。因此，集合相等具有自反性、對稱性、傳遞性。實作 <code>==</code> 運算子，我們會</p>
<ol>
<li>比較集合 x, y 內元素數目（cardinality）是否一致，以及</li>
<li>疊代集合 x，並檢查是否每個屬於 x 的元素都屬於 y。</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; PartialEq for HashSet&lt;T&gt;
where
    T: Hash + Eq,
{
    fn eq(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; bool {
        // 1. 檢查 cardinality，不同長度就不可能相等
        if self.len() != other.len() {
            return false;
        }
        // 2. 利用 Iterator::all 確保每個 self 的元素都屬於 other。
        self.iter().all(|item| other.contains(&amp;item))
    }
}

/// `Eq` 並沒有 required method，只要實作 `Partial::eq` 方法，就能直接推斷出 `Eq`。
impl&lt;T&gt; Eq for HashSet&lt;T&gt; where T: Hash + Eq {}
<span class="boring">}</span></code></pre></pre>
<p>與相等關係相同，Rust 的排序關係同樣有理論依據，<code>Ord</code> 是數學上的 <a href="https://en.wikipedia.org/wiki/Total_order">Total order</a>，符合反對稱性、傳遞性，以及 <a href="https://en.wikipedia.org/wiki/Connex_relation">connex relation</a>；而 <code>ParitalOrd</code> 則接近數學上的 partial order，Rust 的文件中描述該 trait 須符合反對稱性與傳遞性。</p>
<blockquote>
<p>Connex relation：在集合 X 下，所有 (x, y) pair 都會符合 x ∼ y 或 y ∼ x 的關係。在排序關係上，意指不是 x ≥ y 就是 y ≥ x。</p>
</blockquote>
<p>要把集合的「包含於但不相等」關係 ⊂ 映射到排序關係 <code>x &lt; y</code> 前，先來檢驗 ⊂ 有什麼特性。</p>
<ul>
<li>具反對稱性：若 x ⊂ y 且 x ≠ y 則 y ⊄ x，換句話說，若 x ⊂ y 且 y ⊂ x 則 x = y。</li>
<li>具傳遞性：若 x ⊂ y 且 y ⊂ z 則 x ⊂ z。</li>
<li>不具 connex relation：若 x = {1,2}, y = {3,4}，則 x, y 無法以 ⊂ 表示兩者間的關係。</li>
</ul>
<p>很明顯地，「包含於但不相等」符合 partial order 但不是 total order。我們選擇實作 <code>PartialOrd</code> trait，其有一個 required method <code>PartialOrd::partial_cmp</code>。</p>
<ol>
<li><code>partial_cmp</code> 回傳 <code>Option&lt;Ordering&gt;</code>，因為兩個集合可能無交集，導致無法相互比較。</li>
<li>先檢查 <code>other</code> 是不是子集，再檢查是不是長度相同，得到兩個 <code>bool</code>。</li>
<li>有了上述兩個 <code>bool</code>，就可以用 pattern matching 把所有情況列舉出來。
<ul>
<li>是子集且同長度：相等 <code>=</code>。</li>
<li>是子集但長度不同：包含於 ⊂（<code>&lt;</code>）。</li>
<li>不是子集但長度相同：不相交（disjoint）。</li>
<li>不是子集且長度不同：先假設 self 是 other 的超集，再透過 <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.filter"><code>Option::filter</code></a> 過濾，是超集則回傳 <code>Some(Ordering::Greater)</code>，不是則回傳 <code>None</code>。</li>
</ul>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; PartialOrd for HashSet&lt;T&gt;
where
    T: Hash + Eq,
{
    fn partial_cmp(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; Option&lt;Ordering&gt; { // 1
        let is_subset = self.is_subset(other);                      // 2
        let same_size = self.len() == other.len();
        match (is_subset, same_size) {                              // 3
            (true, true) =&gt; Some(Ordering::Equal),
            (true, false) =&gt; Some(Ordering::Less),
            (false, true) =&gt; None,
            _ =&gt; Some(Ordering::Greater).filter(|_| self.is_superset(other)),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>實作 <code>PartialEq</code>，<code>Eq</code> 與 <code>PartialOrd</code> 後，我們的集合型別終於能和 Python 的集合互別苗頭，有更高層次的表達性！</p>
<blockquote>
<p>有人可能會認為，比較運算還要透過 <code>partial_cmp</code> 判斷 <code>Option</code> 多麻煩，事實上，C++ 20 也帶來了 <code>&lt;=&gt;</code> 運算子以及 <a href="https://en.cppreference.com/w/cpp/language/operator_comparison#Three-way_comparison">three way comparison</a> 衍生的各種型別，partial order 或 parital equal 可說是更精確且必要的比較運算，也是一種趨勢。</p>
</blockquote>
<h2 id="效能-19"><a class="header" href="#效能-19">效能</a></h2>
<p>以雜湊表為底層儲存容器的集合，各操作複雜度如下</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Best case</th><th>Worst case</th></tr></thead><tbody>
<tr><td>insert(v)</td><td>$O(1)$~</td><td>$O(n)$</td></tr>
<tr><td>remove(v)</td><td>$O(1)$~</td><td>$O(n)$</td></tr>
<tr><td>contains(v)</td><td>$O(1)$</td><td>$O(n)$</td></tr>
<tr><td>union</td><td>$O(n)$</td><td>$O(n)$</td></tr>
<tr><td>intersection</td><td>$O(n)$</td><td>$O(n)$</td></tr>
<tr><td>difference</td><td>$O(n)$</td><td>$O(n)$</td></tr>
<tr><td>symmetric difference</td><td>$O(n)$</td><td>$O(n)$</td></tr>
</tbody></table>
</div>
<blockquote>
<p>$n$：資料筆數。<br />
$v$：資料值。<br />
<strong>~</strong>：平攤後的複雜度（amortized）。</p>
</blockquote>
<p>操作的時間與空間複雜度，與其底層儲存容器的實作有關，本次集合實作只是對雜湊表的簡單封裝，詳細演算法複雜度可以參考 <a href="collections/set/../hash_map#%E6%95%88%E8%83%BD">HashMap</a>。</p>
<h2 id="參考資料-22"><a class="header" href="#參考資料-22">參考資料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/collections/hash_set/struct.HashSet.html">Rust Documentation: HashSet</a></li>
<li><a href="https://docs.python.org/3/library/stdtypes.html#set">Python 3: Set</a></li>
<li><a href="https://en.wikipedia.org/wiki/Set_theory">Wiki: Set theory</a></li>
<li>Venn diagrams are screenshoot from Wikipedia via public domain.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="布隆過濾器-bloom-filter-1"><a class="header" href="#布隆過濾器-bloom-filter-1">布隆過濾器 Bloom Filter</a></h1>
<p>Bloom filter 是一種機率資料結構（probabilistic data structure），類似於<a href="collections/bloom_filter/../set">集合</a>，常用於需快速驗證成員是否「可能存在」或是「絕對不存在」在容器中，亦即有機會出現假陽性（false positive），但絕不會有假陰性（false negative）。</p>
<p>Bloom filter 的優勢是：</p>
<ul>
<li>類似<a href="collections/bloom_filter/../set">集合</a>，可在 $O(1)$ 時間複雜度驗證成員是否存在，卻僅需相對少的儲存空間。</li>
<li>承上，<a href="https://hur.st/bloomfilter/?n=1M&amp;p=0.001&amp;m=&amp;k=">在 0.1% 錯誤率下儲存一百萬個元素僅需 1.71 MiB</a>。</li>
<li>非常容易實作的機率資料結構，僅需多次雜湊。</li>
</ul>
<p>Bloom filter 則有以下短處：</p>
<ul>
<li>經典款 Bloom filter 容器大小固定（fixed-size），無法動態調整儲存空間。</li>
<li>可能給出假陽性答案：回報存在但實際不存在，且錯誤隨數量變多上升。</li>
<li>自身不儲存成員資料，需要有額外的儲存資料方案。</li>
<li>只能新增成員，但不能移除成員（可透過<a href="collections/bloom_filter/index.html#%E8%AE%8A%E5%BD%A2">變形</a>解決）。</li>
<li>若輸入資料集本身離散，接近<a href="https://en.wikipedia.org/wiki/Random_access">隨機存取</a>，無法充分利用 CPU cache。</li>
<li>承上，因為隨機存取，不利於延伸到記憶體以外的外部儲存裝置。</li>
</ul>
<p>Bloom filter 常見應用場景為：</p>
<ul>
<li><a href="https://www.postgresql.org/docs/12/bloom.html">資料庫利用 Bloom filter</a> 中減少實際存取 disk 的 IO 開銷。</li>
<li>Chromium 瀏覽器<a href="https://chromiumcodereview.appspot.com/10896048/">驗證大量惡意連結</a>。</li>
<li>Medium <a href="https://blog.medium.com/what-are-bloom-filters-1ec2a50c68ff">避免推薦已推薦過的文章</a>。</li>
</ul>
<blockquote>
<p>小知識：bloom 是開花之意，但 Bloom filter 和開花沒任何關係，只因發明人姓氏為 Bloom</p>
</blockquote>
<blockquote>
<p>本次實作的程式碼置於 <a href="collections/bloom_filter//doc/rust_algorithm_club/collections/struct.BloomFilter.html"><code>rust_algorithm_club::collections::BloomFilter</code></a> API 文件中。</p>
</blockquote>
<h2 id="概念-1"><a class="header" href="#概念-1">概念</a></h2>
<p>Bloom filter 由下列兩個部分組成：</p>
<ul>
<li>一個 $m$ 位元的位元陣列（bit array）</li>
<li>$k$ 個不同的雜湊函數</li>
</ul>
<p>經典款的 Bloom filter 作為一個近似集合的容器，提供下列兩個操作</p>
<ul>
<li><strong>新增：</strong> 新增一個值時，透過 $k$ 個雜湊函數產生 $k$ 個雜湊值，分別代表在位元陣列的索引位置，再將 $k$ 個位置的位元翻轉至 1。</li>
<li><strong>查詢：</strong> 同樣透過 $k$ 個雜湊函數產生 $k$ 個雜湊值作為位元陣列的索引位置，若所有位元皆為 1，則代表該值存在。</li>
</ul>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ac/Bloom_filter.svg/1280px-Bloom_filter.svg.png" alt="" /></p>
<blockquote>
<p>上圖顯示 w 並沒有在 {x,y,z} 集合中，因為 w 的雜湊結果有個位元為 0。</p>
</blockquote>
<p>你可能會開始想：</p>
<ul>
<li>欲儲存一百萬個元素，需要多少位元？</li>
<li>出現假陽性的機率是多少？可以調整嗎？</li>
<li>需要幾個雜湊函數？</li>
<li>可重複使用相同的雜湊函數嗎？</li>
</ul>
<p>回答這些問題需要兩個已知條件：</p>
<ol>
<li>預期會儲存多少 $n$ 個元素到容器。</li>
<li>可容忍的假陽性機率 $\epsilon$，即容器不包含該元素，檢測卻回報存在（所有雜湊位皆為 1）。</li>
</ol>
<p>於是可得位元陣列最佳化的長度為 $m$ 個位元，$m$ 為：</p>
<p>$$m = -\frac{n \ln{\epsilon}}{(\ln{2})^2}$$</p>
<p>而在已知條件下，需要的雜湊函數數量 $k$ 為：</p>
<p>$$k = -\frac{\ln{\epsilon}}{\ln{2}} = -\log_2{\epsilon}$$</p>
<p>當然，這些公式並非憑空冒出，有興趣可以讀讀<a href="https://en.wikipedia.org/wiki/Bloom_filter#Optimal_number_of_hash_functions">維基百科上的數學</a>，和<a href="https://sagi.io/bloom-filters-for-the-perplexed/#false-positive-probability-and-formulae">這段詳細的推導</a>，不過也要注意，Bloom filter 的假設是「每個雜湊函數獨立」但<a href="https://gopiandcode.uk/logs/log-bloomfilters-debunked.html#org7b3d391">位元間是否獨立有待討論</a>，這順便開啟了其他問題，可重複使用相同的雜湊函數嗎？</p>
<p>答案是可以， 這篇<a href="https://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf">「Less Hashing, Same Performance:Building a Better Bloom Filter」</a>提及，在不犧牲漸進假陽性機率（asymptotic false positive probability）的前提下，透過兩個不同的雜湊函數 $h_1(x)$ 和 $h_2(x)$，配合以下公式，就可以模擬出多個雜湊函數：</p>
<p>$$g_i(x) = h_1(x) + ih_2(x)$$</p>
<p>數學看暈了嗎？來點程式碼吧。</p>
<h2 id="架構設計-5"><a class="header" href="#架構設計-5">架構設計</a></h2>
<h3 id="利用-vec-儲存位元"><a class="header" href="#利用-vec-儲存位元">利用 <code>Vec</code> 儲存位元</a></h3>
<p>Bloom filter 底層以位元陣列作為儲存容器，如果目標是最省空間，該用 Rust 的什麼型別來儲存位元呢？</p>
<p>直觀作法是在 struct 新增一個 <code>bits</code> 位元陣列的 <code>array</code> 型別：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BloomFilter {
  bits: [bool; N]
}
<span class="boring">}</span></code></pre></pre>
<p>雖然非常省空間，用了多少 bits 這個 struct 就佔多大，但這語法並非不合法，因為 <code>N</code> 未定義，無法編譯，<a href="https://doc.rust-lang.org/std/primitive.array.html">array</a> 的 <code>N</code> 必須是編譯期就決定的常數，BloomFilter 若寫死 <code>N</code> 就不夠泛用了（除非參考 <a href="https://doc.rust-lang.org/alloc/macro.vec.html"><code>vec!</code></a> 透過 macro 建立）。</p>
<p>不如換個方向，不用 fixed size array，給定動態大小的 <code>slice</code> 試試看。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BloomFilter {
  bits: [bool]
}
<span class="boring">}</span></code></pre></pre>
<p>嗯，可以編譯通過，但如果嘗試建立一個 struct 呢？</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let input_len = 5;
    let bits = [true; input_len];
    BloomFilter { bits };
}</code></pre></pre>
<p>就會發現編譯結果如下：</p>
<pre><code class="language-bash">error[E0435]: attempt to use a non-constant value in a constant
 --&gt; src/main.rs:7:23
  |
7 |     let bits = [true; input_len];
  |                       ^^^^^^^^^ non-constant value

error[E0277]: the size for values of type `[bool]` cannot be known at compilation time
 --&gt; src/main.rs:8:5
  |
8 |     BloomFilter { bits };
  |     ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
</code></pre>
<p>原因有二，其一同樣是 array <code>bits</code> 需要一個常數長度；其二則是 <code>bits</code> 是一個 <a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait">Dynamic Sized Types（Dsts）</a> ，長度無法在編譯時決定，編譯期就無法得知 BloomFilter 的所佔記憶體用量。</p>
<p>看來得放棄用 <code>array</code> 或 <code>slice</code> 這些方法，改用最暴力的 <code>Vec</code> 作為位元陣列儲存容器，<code>Vec</code> 雖可動態調整大小，背後其實是一個 pointer + 一個 <code>usize</code> 的 <code>capacity</code> + 一個 <code>usize</code> 的 <code>len</code> 組成，若是在 64 位元的機器上，<a href="https://cheats.rs/#general-purpose-heap-storage">一個 <code>Vec</code> 就會佔 24 位元組</a>，比起 <code>array</code> 多耗費兩個 2 * 8 個位元組空間，幸好這額外的 16 個位元組是固定支出，不隨著 $m$ 和 $n$ 成長。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BloomFilter {
  bits: Vec&lt;bool&gt;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="儲存兩個雜湊函數"><a class="header" href="#儲存兩個雜湊函數">儲存兩個雜湊函數</a></h3>
<p>再來，要在 <code>BloomFilter</code> 儲存兩個 hasher，也就是實作前面提及<a href="https://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf">用兩個雜湊函數模擬 $k$ 個</a>論文中的兩個 hasher，這兩個在 <code>BloomFilter</code> 建構時同時建立，並在操作 <code>BloomFilter</code> 的方法上共用。</p>
<p>這次直接使用標準函式庫內預設雜湊演算法 <a href="http://doc.rust-lang.org/std/collections/hash_map/struct.DefaultHasher.html"><code>DefaultHasher</code></a> 作為隨機的兩個雜湊函數 <code>BloomFilter.hashers</code>。由於是模擬 $k$ 個函數的雜湊行為，仍需另闢欄位，儲存 $k$ 實際上是多少個雜湊函數 <code>BloomFilter.hash_fn_count</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::hash_map::DefaultHasher;

pub struct BloomFilter {
  /// The bit array of _m_ bits.
  bits: Vec&lt;bool&gt;,
  /// Count of hash functions. Denoted by _k_.
  hash_fn_count: usize,
  /// The hashers that do real works.
  hashers: [DefaultHasher; 2],
}
<span class="boring">}</span></code></pre></pre>
<p>就剩最後一里路了！</p>
<h3 id="使用-phantomdata-讓編譯器閉嘴"><a class="header" href="#使用-phantomdata-讓編譯器閉嘴">使用 <a href="https://doc.rust-lang.org/core/marker/struct.PhantomData.html"><code>PhantomData</code></a> 讓編譯器閉嘴</a></h3>
<p>眾所周知，透過<a href="https://doc.rust-lang.org/book/ch10-01-syntax.html">泛型（Generic）</a>，Rust 可重用相同的容器型別，特化接受不同型別的容器，例如 <code>HashMap&lt;K, V&gt;</code> 可以特化為鍵為 <code>String</code>，值為 <code>u32</code> 的 <code>HashMap&lt;String, u32&gt;</code>，<code>Vec&lt;T&gt;</code> 可以成為二維位元組 <code>Vec&lt;Vec&lt;u8&gt;&gt;</code>。看 <a href="http://doc.rust-lang.org/std/collections/index.html"><code>std::collections</code></a> 提供的容器，所有泛型型別參數（Type Parameter）像是 <code>T</code>、<code>K</code>、<code>V</code> 都是跟著 struct 宣告，也因為這些容器的確實際儲存了這些型別的元素，泛型型別參數跟著 struct 很合理。</p>
<p>有趣的是，作為一個容器，Bloom filter 其實不儲存元素本身，而是記錄元素是否「曾經新增至」該容器中。這給了一些想像空間：如何提供型別參數給 Bloom filter？提供兩個方向：</p>
<ol>
<li><strong>泛型型別參數宣告跟著 struct：</strong> 也就是 <code>struct BloomFilter&lt;T&gt;</code>，如此一來，一個容器實例只能操作一種型別，而且在編譯期就決定。
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bf = BloomFilter::new();
bf.insert(&amp;1);            // infer the type T is i32
bf.insert("wront type");  // compile error: &amp;str is not compatible to i32
<span class="boring">}</span></code></pre></pre>
</li>
<li><strong>泛型型別跟著 struct 的方法，struct 本身不宣告：</strong> 很難想像容器裡面儲存不同的型別，但 BloomFilter 實際上只需要一個 <code>Vec&lt;bool&gt;</code> 記錄存在與否，到底新增了什麼型別的元素其實不重要，型別有實作雜湊就行。這個作法下，你可能會看到這種邪魔歪道：
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bf = BloomFilter::new();
bf.insert(&amp;1);
bf.insert("another type");  // it works
bf.insert(vec![3.14159]);   // it also works
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<p>為了讓容器有一致感，這裡決定選擇法一，讓泛型跟著容器走。實作非常簡單，加上 <code>T</code> 泛型參數就行</p>
<pre><code class="language-diff">use std::collections::hash_map::DefaultHasher;

- pub struct BloomFilter {
+ pub struct BloomFilter&lt;T&gt; {
  /// .. snip
}
</code></pre>
<p>哎呀，編譯失敗！</p>
<pre><code class="language-bash">error[E0392]: parameter `T` is never used
 --&gt; src/lib.rs:3:24
  |
3 | pub struct BloomFilter&lt;T&gt; {
  |                        ^ unused parameter
  |
  = help: consider removing `T`, referring to it in a field, or using a marker such as `std::marker::PhantomData`
</code></pre>
<p>因為 Rust 編譯器認為 <code>BloomFilter</code> 並不實際擁有 <code>T</code> 相關欄位，因此編譯不通過，我們可以利用 <a href="https://doc.rust-lang.org/core/marker/struct.PhantomData.html"><code>std::marker::PhantomData</code></a>，<code>PhantomData</code> 是一個 Zero-Sized Type 不佔空間，就是為了取悅編譯器，製造出 struct 擁有 <code>T</code> 的假象。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::hash_map::DefaultHasher;
use std::marker::PhantomData;

pub struct BloomFilter&lt;T&gt; {
  /// The bit array of _m_ bits.
  bits: Vec&lt;bool&gt;,
  /// Count of hash functions. Denoted by _k_.
  hash_fn_count: usize,
  /// The hashers that do real works.
  hashers: [DefaultHasher; 2],
  _phantom: PhantomData&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="sized-讓容器可以儲存-dsts"><a class="header" href="#sized-讓容器可以儲存-dsts"><code>?Sized</code> 讓容器可以儲存 DSTs</a></h2>
<p>最後，有鑑於讓Bloom fliter 能夠接受更多型別，元素不一定要符合編譯期確定大小的 <a href="http://doc.rust-lang.org/std/marker/trait.Sized.html"><code>Sized</code></a> trait bound，可以透過加上 <code>?Sized</code> trait bound 解除預設的限制，如此一來 <code>BloomFilter</code> 就可接受 slice 和 trait object 這些 <a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait">DSTs</a> 了，傳入 string literal 變為可能 <code>bloom_filter.insert("1234")</code>。</p>
<pre><code class="language-diff">use std::collections::hash_map::DefaultHasher;
use std::marker::PhantomData;

- pub struct BloomFilter&lt;T&gt; {
+ pub struct BloomFilter&lt;T: ?Sized&gt; {
    // .. snip
}
</code></pre>
<h2 id="基本操作-6"><a class="header" href="#基本操作-6">基本操作</a></h2>
<p>Bloom filter 為類似集合的容器，當然有<a href="collections/bloom_filter/../set#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">類似的操作</a>，事實上，這類機率性集合成員檢測的資料結構有個較少聽見但令人印象深刻的名字，稱為「Approximate Membership Query（AMQ）」，提供 <code>add(element)</code> 和 <code>query(element)</code> 兩個基本操作。</p>
<p>本文的 <code>BloomFilter</code> 提供下列幾個公開方法：</p>
<ul>
<li><code>new</code>：初始化一個容器。</li>
<li><code>insert</code>：新增一個元素。</li>
<li><code>contains</code>：檢查容器內有無特定元素（是否曾新增過）。</li>
</ul>
<p>以及幾個內部輔助方法：</p>
<ul>
<li><code>make_hash</code>：給定輸入元素資料，透過兩個雜湊函數產生兩個雜湊值。</li>
<li><code>get_index</code>：將 <code>make_hash</code> 的兩雜湊值帶入 $g_i(x) = h_1(x) + ih_2(x)$ 計算單次 <code>i</code> 的索引位置。</li>
<li><code>optimal_bits_count</code>：給定預期儲存元素個數 $n$ 與假陽性機率 $\epsilon$，得位元陣列最適位元數 $m$。</li>
<li><code>optimal_hashers_count</code>：給定預期假陽性機率，得最適雜湊函數個數 $k$。</li>
</ul>
<h3 id="初始化"><a class="header" href="#初始化">初始化</a></h3>
<p>Bloom filter 有四個參數 $m$、$n$、$k$、$\epsilon$ 可以調整（詳見 <a href="collections/bloom_filter/index.html#%E6%95%88%E8%83%BD">效能</a>一節），對使用者來說，有幾個雜湊函數或底層是多少個位元都是實作細節了，更關心的可能是</p>
<p><em>「我有一百萬筆資料需要驗證存在，容錯率需要在 0.1%，我需要多大的儲存空間？」</em></p>
<p>因此，建構函數 <code>new</code> 提供輸入預期儲存元素個數 $n$ 和預期的假陽性機率 $\epsilon$ 是天經地義的事：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new(capacity: usize, err_rate: f64) -&gt; Self;
<span class="boring">}</span></code></pre></pre>
<p>接下來，會實作<a href="collections/bloom_filter/index.html#%E6%A6%82%E5%BF%B5">概念</a>一節的數學公式，找出最適位元數和最適雜湊函數個數。這兩個函數都是以 Rust 表達數學公式，可注意的點是，<a href="http://doc.rust-lang.org/std/f32/consts/index.html"><code>std::f32::consts</code></a> 和 <a href="http://doc.rust-lang.org/std/f64/consts/index.html"><code>std::f64::consts</code></a>，提供許多數學上常見的常數老朋友，操作浮點數和雙精度浮點數就不用自己手動重算了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// m = -1 * (n * ln ε) / (ln 2)^2
fn optimal_bits_count(capacity: usize, err_rate: f64) -&gt; usize {
    let ln_2_2 = std::f64::consts::LN_2.powf(2f64);
    (-1f64 * capacity as f64 * err_rate.ln() / ln_2_2).ceil() as usize
}

/// k = -log_2 ε
fn optimal_hashers_count(err_rate: f64) -&gt; usize {
    (-1f64 * err_rate.log2()).ceil() as usize
}
<span class="boring">}</span></code></pre></pre>
<p>目前為止，<code>BloomFilter::new</code> 長這樣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new(capacity: usize, err_rate: f64) -&gt; Self {
    let bits_count = Self::optimal_bits_count(capacity, err_rate);
    let hash_fn_count = Self::optimal_hashers_count(err_rate);
}
<span class="boring">}</span></code></pre></pre>
<p>最後，按照前述<a href="https://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf">兩個雜湊函數恰恰好</a>的道理，建立兩個不同的雜湊函數，並初始化位元陣列，大功告成！</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new(capacity: usize, err_rate: f64) -&gt; Self {
    // #1 Get optimal count of bit
    let bits_count = Self::optimal_bits_count(capacity, err_rate);
    // #2 Get optimal count of hash functions
    let hash_fn_count = Self::optimal_hashers_count(err_rate);
    // #3 Use RandomState to build different hasher
    let hashers = [
        RandomState::new().build_hasher(),
        RandomState::new().build_hasher(),
    ];

    Self {
        bits: vec![false; bits_count], // #4 Initialize a all zero bit array
        hash_fn_count,
        hashers,
        _phantom: PhantomData,
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>透過指定假陽性機率與預期元素個數，算得最適位元數</li>
<li>透過指定假陽性機率，算得最適雜湊函數個數</li>
<li>透過 std 內建的 <a href="http://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html"><code>RandomState</code></a> 產生兩個不同初始狀態的雜湊函數，以模擬 $k$ 個雜湊函數</li>
<li>初始化一個全零的位元陣列</li>
</ol>
<h3 id="新增"><a class="header" href="#新增">新增</a></h3>
<p>新增一個元素到 Bloom filter，說穿了就做一件事：將元素透過 $k$ 個雜湊函數，產出 $k$ 個索引位置，並將位元陣列上這些位置的位元翻轉至 1。</p>
<p>整個 <code>insert</code> 函數即為計算 $g_i(x) = h_1(x) + ih_2(x)$ 模擬 $k$ 個雜湊函數的過程：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn insert(&amp;mut self, elem: &amp;T)
where
    T: Hash,
{
    let hashes = self.make_hash(elem);  // #1
    for fn_i in 0..self.hash_fn_count { // #2
        let index = self.get_index(hashes, fn_i as u64); // #3
        self.bits[index] = true;        // #4
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>取得 $h_1(x)$ 和 $h_2(x)$ 的雜湊輸出結果。</li>
<li>疊代 <code>i</code> 次，<code>i</code> 上限為 $k$：初始化時所得的最適雜湊函數個數</li>
<li>計算 $g_i(x) = h_1(x) + ih_2(x)$ 取得索引位置</li>
<li>將索引位置下的位元設定為 1</li>
</ol>
<p>這裡有兩個內部方法，先講解如何計算 $h_1(x)$ 和 $h_2(x)$：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_hash(&amp;self, elem: &amp;T) -&gt; (u64, u64)
where
    T: Hash,
{
    // #1
    let hasher1 = &amp;mut self.hashers[0].clone();
    let hasher2 = &amp;mut self.hashers[1].clone();

    // #2
    elem.hash(hasher1);
    elem.hash(hasher2);

    // #3
    (hasher1.finish(), hasher2.finish())
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>為保存兩個 hasher 內部初始狀態，使用 <code>clone</code> 複製新的 hasher 來做雜湊</li>
<li>將 <code>elem</code> 餵給 hasher 計算雜湊值</li>
<li>輸出雜湊值，由於 <a href="http://doc.rust-lang.org/core/hash/trait.Hasher.html#tymethod.finish"><code>Hasher::finish</code></a> 不會重設 hasher 內部狀態，所以需要步驟一 <code>clone</code> 來保留 hasher 的原始狀態</li>
</ol>
<p>再來是實作計算索引位置 $g_i(x) = h_1(x) + ih_2(x)$，這個函數非常單純，就是輸入 <code>make_hash</code> 所得之雜湊值，然後帶入公式中。為了防止輸出的索引位置超過位元陣列的位元數，這裡以位元數 $m$ 取模（<code>%</code> modulo），加上使用 <code>wrapping_ops</code> 這些 modular arithmetic operation 達成。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_index(&amp;self, (h1, h2): (u64, u64), fn_i: u64) -&gt; usize {
    (h1.wrapping_add(fn_i.wrapping_mul(h2)) % self.bits.len() as u64) as usize
}
<span class="boring">}</span></code></pre></pre>
<h3 id="查詢"><a class="header" href="#查詢">查詢</a></h3>
<p>查詢元素是否在 Bloom filter 裡面，就是看看該元素透過 $k$ 個雜湊函數輸出的每個索引位置<strong>全部為 1</strong>，則可能存在；否則就是絕對不存在。</p>
<p>實作步驟和插入非常相似：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn contains(&amp;self, elem: &amp;T) -&gt; bool
where
    T: Hash,
{
    let hashes = self.make_hash(elem); // #1
    (0..self.hash_fn_count).all(|fn_i| { // #1 使用 iter
        let index = self.get_index(hashes, fn_i as u64);
        self.bits[index]
    })
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>取得 $h_1(x)$ 和 $h_2(x)$ 的雜湊輸出結果。</li>
<li>使用 <a href="http://doc.rust-lang.org/1.45.2/core/iter/trait.Iterator.html#method.all">Iterator::all</a> 疊代收集 $k$ 個雜湊函數的輸出</li>
<li>計算 $g_i(x) = h_1(x) + ih_2(x)$ 取得索引位置</li>
<li>回傳索引位置下的位元 <code>bool</code> 值，此值會匯集起來，於步驟二確認命中全部 $k$ 個索引，即為元素存在</li>
</ol>
<p>完整程式碼如下，或轉駕到 <a href="collections/bloom_filter//doc/rust_algorithm_club/collections/struct.BloomFilter.html">API 文件</a>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BloomFilter&lt;T: ?Sized&gt; {
    bits: Vec&lt;bool&gt;,
    hash_fn_count: usize,
    hashers: [DefaultHasher; 2],
    _phantom: PhantomData&lt;T&gt;,
}

impl&lt;T: ?Sized&gt; BloomFilter&lt;T&gt; {
    pub fn new(capacity: usize, err_rate: f64) -&gt; Self {
        let bits_count = Self::optimal_bits_count(capacity, err_rate);
        let hash_fn_count = Self::optimal_hashers_count(err_rate);
        let hashers = [
            RandomState::new().build_hasher(),
            RandomState::new().build_hasher(),
        ];

        Self {
            bits: vec![false; bits_count],
            hash_fn_count,
            hashers,
            _phantom: PhantomData,
        }
    }

    pub fn insert(&amp;mut self, elem: &amp;T)
    where
        T: Hash,
    {
        // g_i(x) = h1(x) + i * h2(x)
        let hashes = self.make_hash(elem);
        for fn_i in 0..self.hash_fn_count {
            let index = self.get_index(hashes, fn_i as u64);
            self.bits[index] = true;
        }
    }

    pub fn contains(&amp;self, elem: &amp;T) -&gt; bool
    where
        T: Hash,
    {
        let hashes = self.make_hash(elem);
        (0..self.hash_fn_count).all(|fn_i| {
            let index = self.get_index(hashes, fn_i as u64);
            self.bits[index]
        })
    }

    fn get_index(&amp;self, (h1, h2): (u64, u64), fn_i: u64) -&gt; usize {
        (h1.wrapping_add(fn_i.wrapping_mul(h2)) % self.bits.len() as u64) as usize
    }

    fn make_hash(&amp;self, elem: &amp;T) -&gt; (u64, u64)
    where
        T: Hash,
    {
        let hasher1 = &amp;mut self.hashers[0].clone();
        let hasher2 = &amp;mut self.hashers[1].clone();

        elem.hash(hasher1);
        elem.hash(hasher2);

        (hasher1.finish(), hasher2.finish())
    }

    /// m = -1 * (n * ln ε) / (ln 2)^2
    fn optimal_bits_count(capacity: usize, err_rate: f64) -&gt; usize {
        let ln_2_2 = std::f64::consts::LN_2.powf(2f64);
        (-1f64 * capacity as f64 * err_rate.ln() / ln_2_2).ceil() as usize
    }

    /// k = -log_2 ε
    fn optimal_hashers_count(err_rate: f64) -&gt; usize {
        (-1f64 * err_rate.log2()).ceil() as usize
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="效能-20"><a class="header" href="#效能-20">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Notation</th><th>Description</th></tr></thead><tbody>
<tr><td>$n$</td><td>預期儲存 $n$ 個元素到容器中</td></tr>
<tr><td>$m$</td><td>使用 $m$ 位元的位元陣列來儲存</td></tr>
<tr><td>$k$</td><td>有 $k$ 個雜湊函數計算索引位置</td></tr>
<tr><td>$\epsilon$</td><td>假陽性錯誤的機率 $\epsilon$</td></tr>
</tbody></table>
</div>
<p>和常見的容器資料結構不太一樣，複雜度和 $n$ 元素個數脫鉤，而是和 $k$ 和 $m$ 相關：</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time complexity</th></tr></thead><tbody>
<tr><td>insert(v)</td><td>$O(k)$</td></tr>
<tr><td>contains(v)</td><td>$O(k)$</td></tr>
</tbody></table>
</div>
<p>而儲存空間複雜度則是 $O(m)$。</p>
<p>新增和搜尋一個元素個別需要雜湊 $k$ 次，因此時間複雜度為 $O(k)$ 顯而易見，然而，$k$ 通常相對 $m$ $n$ 是非常小的數字，例如
<a href="https://hur.st/bloomfilter/?n=1M&amp;p=0.001&amp;m=&amp;k=">在 0.1% 錯誤率下儲存一百萬個元素僅需 1.71 MiB 和 7 個雜湊函數</a>，實務上直接當作 $O(1)$ 也不算錯。</p>
<p>至於空間複雜度，由於必須事先配置好 $m$ 位元的位元陣列，就算新增的元素 $n \gt m$，也不會再新增新位元，因此空間使用為 $O(m)$ 個位元。實務上，當 $n$ 成長到接近 $m$ 時，假陽性的機率會大增，不堪使用，進而需要能動態調整儲存空間的 Bloom filter 變形。</p>
<h2 id="變形-3"><a class="header" href="#變形-3">變形</a></h2>
<p>經典款 Bloom filter 容易實作，歷久不衰，不過仍有許多可以增進空間：</p>
<ul>
<li>Data locality 不夠好：Bloom filter 底層儲存是位元陣列<a href="https://en.wikipedia.org/wiki/Random_access">隨機存取</a>，較不符合現代 CPU 架構的 cache line 使用姿勢。Cloudflare 技術部落格文 <a href="https://blog.cloudflare.com/when-bloom-filters-dont-bloom/">When Bloom filters don’t bloom</a> 以幽默筆法帶出這個問題，值得一讀。</li>
<li>雜湊次數過多：Bloom filter 每一個新增查詢操作都需要雜湊 $k$ 次，就算利用 double hashing 還是要雜湊兩次，比起其他類似資料結構硬生生多雜湊數次。</li>
<li>位元陣列大小固定：Bloom filter 容器大小固定，給你預期的元素個數後，無法動態調整儲存空間，</li>
<li>bits per entry 較高：以類似功能的的資料結構來說，Bloom filter 在空間利用率上，欲維持一定的假陽性機率，每個元素所需位元數相對較高，需要 $1.44 \log_2{\frac{1}{\epsilon}}$ 個位元。</li>
</ul>
<p>這裡介紹幾款嘗試解決上述問題的 filter，您也可以去 <a href="https://en.wikipedia.org/wiki/Bloom_filter#Extensions_and_applications">Wikipedia 看看其他更多變形的介紹</a>。</p>
<h3 id="可以計數的-counting-bloom-filter"><a class="header" href="#可以計數的-counting-bloom-filter">可以計數的 Counting Bloom filter</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Counting_Bloom_filter">📚 維基百科</a></p>
<p>經典款 Bloom filter 之所以無法刪除元素，是因為沒有記錄哪些元素新增/刪除的資訊，而 Counting Bloom filter 顧名思義，原本用一個位元儲存 0 / 1 資訊，延伸為多位元方便儲存計數（counting），有了個別元素增刪資訊，Bloom filter 因此能實作「刪除元素」。搜尋一個 Counting Bloom filter 是否擁有 n 次以上 x，答案一樣和 Bloom filter 類似是「可能有 n 次以上的 x」或是「x 絕對沒有 n 次以上」。事實上，可將 Counting Bloom filter 視為 Bloom filter 的一般化形式（generalized form），而經典款 Bloom filter 反過來可當作只記一次數的特化。</p>
<p>但 Counting Bloom filter 的缺點是空間需求大，端看決定要用幾個位元計數，例如常見用 4 個位元計數，則是經典款的四倍空間消耗。</p>
<h3 id="動態適應空間大小的-scalable-bloom-filter"><a class="header" href="#動態適應空間大小的-scalable-bloom-filter">動態適應空間大小的 Scalable Bloom Filter</a></h3>
<p><a href="https://gsd.di.uminho.pt/members/cbm/ps/dbloom.pdf">📚 論文連結</a></p>
<p>Scalable Bloom Filter 的特色是：動態適應空間大小，不需事先知道預期儲存的元素個數。</p>
<p>Scalable Bloom Filter 的實作蠻暴力的，本身是由一至多個經典款 Bloom filter 組成，若一個 filter 滿了（超過 fill ratio），則會新增一個 filter，往後所有新增都在這個新 filter 上面，直到它也滿了，可視為一個 recursive data structure。</p>
<p>至於查詢，這就是 Scalable Bloom Filter 比較弱的地方，查詢會從第一個 filter 開始找，若找不到往下一個 filter 找，找到會沒有下一個 filter 為止。若 filter 數量為 $l$，則查詢的時間複雜度從 $O(k)$ 變成 $O(k \cdot l)$。</p>
<p>除了初始化大小和假陽性機率率，Scalable Bloom Filter 提供設定成長率和假陽性錯誤緊縮率：</p>
<ul>
<li>成長因子 $s$：每個新增的 filter 空間大小成長率，論文的經驗法則得出預期小成長趨勢選擇 $s = 2$，有較大成長趨勢則 $s = 4$ 效果好。</li>
<li>錯誤緊縮率 $r$： 每個新增的 filter 會以等比級數得到更緊縮的假陽性機率上限，由於是等比級數，逼近極限時會小於原始機率，這讓整體假陽性機率得以保持。論文中實證 0.8 到 0.9 在元素預期有大成長率下有最佳平均空間利用率。</li>
</ul>
<h3 id="quotient-filter"><a class="header" href="#quotient-filter">Quotient filter</a></h3>
<p><a href="http://vldb.org/pvldb/vol5/p1627_michaelabender_vldb2012.pdf">📚 論文連結</a>（直接讀論文更易懂）</p>
<p>商數過濾器（Quotient filterF）利用<a href="collections/bloom_filter/../hash_map">雜湊表</a>為底層儲存容器，來做集合成員檢測的 AMQ，為了節省空間使用量，Quotient filter 的雜湊表只儲存 partial-key，俗稱指紋（fingerprint），指紋的鍵短空間用量低，副作用是更容易碰撞，代表需要更有效處理雜湊碰撞（hash collision）。</p>
<p>一般來說，<a href="collections/bloom_filter/../hash_map#%E8%99%95%E7%90%86%E9%9B%9C%E6%B9%8A%E7%A2%B0%E6%92%9E">處理雜湊碰撞</a>有 separate chaining 和 Open addressping 兩大類方法，而 Quotient filter 選擇了另一條詭譎的方法：利用 open addressing 中 linear probing 的方式，對每個 slot 儲存額外資訊，使得我們可辨認碰撞的元素是在相同指紋下的同個 bucket 內。換句話說，額外資訊就是在「透過 linear probing 模擬 separate chaining」。</p>
<p>回到指紋，Quotient filter 實際上並不直接儲存指紋，而是將指紋 $f$ 進一步拆成商 $f_q$ 與餘數 $f_r$，商作為索引位置，而餘數則為真實被儲存的值。透過商和餘數，可重組回推原本的指紋。不需存完整的指紋，又再次減少空間使用量，帥！</p>
<p>簡單總結 Quotient filter 的特性：</p>
<ul>
<li>使用 linear probing 解決雜湊碰撞，data locality 好，有 cache friendly。</li>
<li>有額外儲存資訊，可在不重建不 rehash filter 的情況下支援刪除、合併、調整空間。</li>
<li>綜合上述兩點，非常適合 LSM-tree 等需要存取 SSD 的場景，大幅減少 I/O。</li>
<li>Throughput 受到雜湊表 load factor 影響較大。</li>
<li>空間用量仍比經典款 Bloom filter 多 10% 到 25%。</li>
</ul>
<p><img src="collections/bloom_filter/./quotient-filter.png" alt="" /></p>
<blockquote>
<p>Quotient filter 與它等價的 open addressing hash map</p>
</blockquote>
<p><em>Image Source: <a href="http://vldb.org/pvldb/vol5/p1627_michaelabender_vldb2012.pdf">Bender, et al., 2012. “Don’t Thrash: How to Cache Your Hash on Flash”</a>.</em></p>
<h3 id="支援刪除元素的-cuckoo-filter"><a class="header" href="#支援刪除元素的-cuckoo-filter">支援刪除元素的 Cuckoo filter</a></h3>
<p><a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf">📚 論文連結</a>（有趣易讀，誠摯推薦）</p>
<p>Cuckoo hashing 是一種解決雜湊碰撞的方法，透過一次計算兩個雜湊函數產生兩個索引位置，若其中一個位置有空位則插入空位，若都沒有空位，則隨機踢掉一個，被踢掉的再去找下一個替死鬼，直到全部都有位置，或踢掉次數大於一定值則停止。這種行為和杜鵑鳥（cuckoo、布穀鳥）鳩佔鵲巢的生物習性很像，因此得名。</p>
<p>Cuckoo filter 利用<a href="collections/bloom_filter/./hash_map">雜湊表</a>為底層儲存容器，來做集合成員檢測的 AMQ，會和 cuckoo 扯上關係則是因為使用 Cuckoo hashing 解決雜湊碰撞，以增加空間使用率（達到 95% occupancy）。Cuckoo filter 的雜湊表和 Quotient filter 一樣，為了減少空間使用量而只儲存 partial-key。</p>
<p>儲存指紋導致鍵變短，容易碰撞，也代表萬一碰撞，沒辦法透過原始的鍵再次雜湊來找到 Cuckoo hasing 對應另一位置，不過 Cuckoo filter 巧妙利用 XOR 的 identity $x \oplus x = 0$ 解決問題，double hashing 公式奉上：</p>
<p>$$
h_1(x) = hash(x) \\
h_2(x) = h_1(x) \oplus hash(fingerprint(x))
$$</p>
<p>如此一次，透過 $h_2(x)$ 和指紋的 XOR 就可以得到 $h_1(x)$，公式進而可一般化成：</p>
<p>$$j = i \oplus hash(fingerprint(x))$$</p>
<p>其中 $j$ 與 $i$ 為同個元素經過兩個雜湊函數中任一的值，神奇吧！</p>
<p>Cuckoo filter 的特性是：</p>
<ul>
<li>支援動態新增與刪除元數。</li>
<li>比其他 filter 變形（例如 Quotient filter）好實作，如果懂 Cuckoo hashing 的話。</li>
<li>查詢效能比經典款 Bloom filter 好，bits per item 也比較低（$(\log_2{\frac{1}{\epsilon}} + 2) / \alpha$，$\alpha$ 是雜湊表的 load factor，通常為 95.5%）。</li>
<li>缺點是「一定要先新增過一個元素，才能對 filter 刪除該元素」，但這是所有支援刪除的 filter 的通病，不然就會有假陽性發生。</li>
</ul>
<p><img src="collections/bloom_filter/./cuckoo-filter.png" alt="" /></p>
<p><em>Image Source: <a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf">Fan, et al., 2014. “Cuckoo Filter: Practically Better Than Bloom”</a>.</em></p>
<h2 id="參考資料-23"><a class="header" href="#參考資料-23">參考資料</a></h2>
<ul>
<li><a href="https://citeseerx.ist.psu.edu/viewdoc/download;?doi=10.1.1.641.9096&amp;rep=rep1&amp;type=pdf">Burton H. Bloom: Space/Time Trade-offs in Hash Coding with Allowable Errors</a></li>
<li><a href="https://en.wikipedia.org/wiki/Bloom_filter">Wiki: Bloom filter</a></li>
<li><a href="https://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf">Less Hashing, Same Performance:Building a Better Bloom Filter</a></li>
<li><a href="https://onatm.dev/2020/08/10/let-s-implement-a-bloom-filter/">Onat: Let’s implement a Bloom Filter</a></li>
<li><a href="https://github.com/google/guava/blob/v29.0/guava/src/com/google/common/hash/BloomFilter.java">Google Guava: BloomFilter</a></li>
<li><a href="https://hur.st/bloomfilter/">Bloom Filter Calculator</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="漢明距離-hamming-distance"><a class="header" href="#漢明距離-hamming-distance">漢明距離 Hamming distance</a></h1>
<p>漢明距離（Hamming distance）是指兩個相同長度的序列（sequence）在相同位置上，有多少個數值不同，對二進位序列來說就是「相異位元的數目」。漢明距離同時也是一種編輯距離，即是將一個字串轉換成另一個字串，需要經過多少次置換操作（substitute）。</p>
<p>漢明距離多應用於編碼理論中的錯誤更正（error-correcting），漢明碼（Hammming code）中計算距離的演算法即為漢明距離。</p>
<blockquote>
<p>本次實作的程式碼置於</p>
<ul>
<li><a href="hamming_distance//doc/rust_algorithm_club/fn.hamming_distance.html"><code>rust_algorithm_club::hamming_distance</code></a></li>
<li><a href="hamming_distance//doc/rust_algorithm_club/fn.hamming_distance_str.html"><code>rust_algorithm_club::hamming_distance_str</code></a></li>
</ul>
<p>API 文件中。</p>
</blockquote>
<h2 id="位元版實作"><a class="header" href="#位元版實作">位元版實作</a></h2>
<p>計算相異位元的數目其實就是一堆位元運算，如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn hamming_distance(source: u64, target: u64) -&gt; u32 {
    let mut count = 0;
    let mut xor = source ^ target; // 1

    // 2
    while xor != 0 {
        count += xor &amp; 1; // 3
        xor &gt;&gt;= 1; // 4
    }

    count as u32
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>透過 XOR 操作，讓兩序列相異位元為 1，相同位元為 0。</li>
<li>如果 XOR 操作不為零，表示還有相異位元，繼續計算。</li>
<li>將 XOR 結果和 1 做 AND 運算，看最低有效位（least significant digit）是否為 1。</li>
<li>將 XOR 做位元右移，捨棄最低有效位，並回到步驟二。</li>
</ol>
<blockquote>
<p>根據 <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators">《The Rust Reference》</a> 指出，Rust 的位元右移在</p>
<ul>
<li>無符號整數（unsigned）是邏輯右移（logical right shift），也就是直接在最高有效位補 0；</li>
<li>有符號整數（signed）則是算術右移（arithmetic right shift），右移之後符號會被保留。</li>
</ul>
</blockquote>
<p>實際上，Rust 提供了一個原生的計算整數有多少個零的方法 <a href="https://doc.rust-lang.org/stable/std/?search=count_ones"><code>{integer_type}::count_ones</code></a>，可以省去自己做位元運算的麻煩，實作如下，帥：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn hamming_distance(source: u64, target: u64) -&gt; u32 {
     (source ^ target).count_ones()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="字串版實作"><a class="header" href="#字串版實作">字串版實作</a></h2>
<p>字串版的漢明距離就相對好懂了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn hamming_distance_str(source: &amp;str, target: &amp;str) -&gt; usize {
    let mut count = 0;
    // 1
    let mut source = source.chars();
    let mut target = target.chars();

    loop {
        // 2
        match (source.next(), target.next()) {
            // 3
            (Some(c1), Some(c2)) if c1 != c2 =&gt; count += 1,
            // 4
            (None, Some(_)) | (Some(_), None) =&gt; panic!("Must have the same length"),
            // 5
            (None, None) =&gt; break,
            // 6
            _ =&gt; continue,
        }
    }

    count
}
<span class="boring">}</span></code></pre></pre>
<p>字串版同樣吃 <code>source</code> 和 <code>target</code> 兩個輸入。</p>
<ol>
<li>用 <a href="http://doc.rust-lang.org/std/primitive.str.html#method.chars"><code>str::chars</code></a> 讓漢明距離可以比對 Unicode 字串，而非只有 ASCII，而 <code>str::chars</code> 是 <code>Iterator</code>，所以透過 <code>Iterator::next</code> 逐一比較每個字元。</li>
<li>這裡 <code>if c1 != c2</code> 叫做 <a href="https://doc.rust-lang.org/reference/expressions/match-expr.html#match-guards">match guard</a>，是在模式匹配之外，額外條件式檢查，因此，只有 <code>source</code> 和 <code>target</code> 都有下一個字元而且兩字元不相等才會進入這個匹配分支。</li>
<li>若有任何一個是 <code>None</code>，另外一個是 <code>Some</code>，標示輸入字串的長度不同，直接噴錯。</li>
<li>如果都沒有下一個字元，直接結束迴圈。</li>
<li>其他情況，例如兩個字元相同，就繼續疊代。</li>
</ol>
<h2 id="效能-21"><a class="header" href="#效能-21">效能</a></h2>
<p>長度為 n 的序列，計算漢明距離的時間複雜度為 $O(n)$，空間複雜度為 $O(1)$。</p>
<h2 id="參考資料-24"><a class="header" href="#參考資料-24">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Hamming_distance">Wiki: Hamming distance</a></li>
<li><a href="https://web.math.sinica.edu.tw/math_media/d184/18404.pdf">錯誤更正碼簡介</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="萊文斯坦距離-levenshtein-distance"><a class="header" href="#萊文斯坦距離-levenshtein-distance">萊文斯坦距離 Levenshtein distance</a></h1>
<p>萊文斯坦距離（Levenshtein distance）是一種量化兩字串間差異的演算法，代表從一個字串轉換為另一個字串最少需要多少次編輯操作，這種量化指標的演算法稱為<a href="https://en.wikipedia.org/wiki/Edit_distance">「編輯距離（Edit distance）」</a>，不同的演算法允許的編輯操作不盡相同，萊文斯坦距離允許使用：</p>
<ul>
<li>插入（insertion）</li>
<li>刪除（deletion）</li>
<li>置換（substitution）</li>
</ul>
<p>三種編輯操作，通常一般實作上三種操作的權重會相同。</p>
<p>萊文斯坦距離概念易理解，實作簡單，常用在簡易拼字修正與建議，為最具代表性的編輯距離演算法。</p>
<blockquote>
<p>本次實作的程式碼置於</p>
<ul>
<li><a href="levenshtein_distance//doc/rust_algorithm_club/fn.levenshtein_distance.html"><code>rust_algorithm_club::levenshtein_distance</code></a></li>
<li><a href="levenshtein_distance//doc/rust_algorithm_club/fn.levenshtein_distance_naive.html"><code>rust_algorithm_club::levenshtein_distance_naive</code></a></li>
</ul>
<p>API 文件中。</p>
</blockquote>
<h2 id="概念-2"><a class="header" href="#概念-2">概念</a></h2>
<h3 id="萊文斯坦的遞迴函數"><a class="header" href="#萊文斯坦的遞迴函數">萊文斯坦的遞迴函數</a></h3>
<p>編輯距離愛拿 kitten 和 sitting 當例子，這兩個單字的編輯距離為 3，可以透過以下步驟，算出 kitten 與 sitting 轉換會經歷三個編輯操作：</p>
<ol>
<li><strong>s</strong>itting -&gt; <strong>k</strong>itting：置換 /k</li>
<li>kitt<strong>i</strong>ng -&gt; kitt<strong>e</strong>ng：置換 i/e</li>
<li>kitten<strong>g</strong> -&gt; kitten <del><strong>g</strong></del>：刪除最末端 g</li>
</ol>
<p>等等，怎麼知道 3 就是最少編輯操作呢？我們可以經由下列函數計算萊文斯坦距離：</p>
<p>$$
\operatorname{lev} _{a,b}(i,j) =
\begin{cases}
\max(i,j)       &amp; \text{if} \min(i,j) = 0, \\
\min{
\begin{cases}
\operatorname{lev} _{a,b}(i-1,j) + 1, \\
\operatorname{lev} _{a,b}(i,j-1) + 1, \\
\operatorname{lev} _{a,b}(i-1,j-1) + 1 _{(a _{i} \neq b _{j})}
\end{cases}
}               &amp; \text{otherwise.}
\end{cases}
$$</p>
<blockquote>
<p>$\operatorname{lev}_{a,b}(i,j)$ 代表字串 $a$ 前 $i$ 個字元，與 $b$ 前 $j$ 個字元的萊文斯坦距離。（$i$、$j$ 索引從 1 開始計算）</p>
</blockquote>
<p>別怕，這個函數是一個分段函數（piecewise function），由兩個子函數組成，接下來將一一拆解。</p>
<p>首先來看第一個子函數：</p>
<p>$$
\max(i,j) \hspace{10 pt} \text{if} \min(i,j) = 0
$$</p>
<p>根據函數定義，$i$ $j$ 可以視為 $a$ $b$ 前幾個字元的子字串（substring），所以這個子函數白話翻譯是「若有子字串是空字串，則以較長的子字串長度作為編輯距離」。這其實非常直觀，如果有一空字串和另一個非空字串 <code>abc</code>，那編輯距離一定是插入三次或刪除三次，也就是該字串長度。這帶出萊文斯坦距離一個很重要的上界：「兩字串的編輯距離至多為較長字串的長度」。</p>
<p>第二個子函數稍微複雜，要再從三個函數中取最小值，但剛剛好，這三個函數分別代表了萊文斯坦距離接受的插入、刪除、置換三種操作：</p>
<ul>
<li>$\operatorname{lev} _{a,b}(i-1,j) + 1$：從 a 轉變到 b 要刪除 1 字元。</li>
<li>$\operatorname{lev} _{a,b}(i,j-1) + 1$：從 a 轉換到 b 要插入 1 字元。</li>
<li>$\operatorname{lev} _{a,b}(i-1,j-1) + 1 _{(a _{i} \neq b _{j})}$：若 a 等於 b，就不需任何操作，直接一起跳過；反之則置換一次。</li>
</ul>
<p>這是子函數是遞迴函數，每次都會分出三個子程序計算萊文斯坦距離，空間複雜度直逼 $O(3^{m + n - 1})$，驚人！</p>
<blockquote>
<p>複雜度的 3 次方會減一是因為只要 m n 其中一個歸零，該路徑就不再遞迴。</p>
</blockquote>
<h3 id="動態規劃的距離矩陣"><a class="header" href="#動態規劃的距離矩陣">動態規劃的距離矩陣</a></h3>
<p>由於上述遞迴複雜度過搞，因此處理萊文斯坦距離，通常會選擇由下至上（bottom-up） 的動態規劃（Dynamic programming），利用一個距離矩陣，將兩個字串所有子字串間的萊文斯坦距離累積紀錄起來，省去重複計算的成本。</p>
<p>首先，先將最基礎的 a、b 其一為空字串時的編輯距離寫上去，因為其中一個為空字串，編輯距離必定是隨著另一字串增加，逐一插入字元（最左方的直行）或刪除字元（上方橫列）。</p>
<blockquote>
<p>註：若插入刪除權重相等，對萊文斯坦來說這兩種操作其實一樣，只是由 a 到 b 或 b 到 a 的差異。</p>
</blockquote>
<p><img src="levenshtein_distance/base.png" alt="" /></p>
<p><em>圖一：空字串與編輯距離</em></p>
<p>接下來我們要來算 k 與 s 子字串的編輯距離，按照公式來計算：</p>
<ol>
<li>紅字上方是執行刪除的累積編輯距離（1），加上刪除操作的成本（1），為 1 + 1 = 2</li>
<li>紅字左方是執行插入的累積編輯距離（1），加上插入操作的成本（1），為 1 + 1 = 2</li>
<li>紅字對角是執行置換的累積編輯距離（1），加上當前 k s 字元不相等的置換成本（1），為 0 + 1 = 1</li>
<li>從刪除、插入、置換的成本中選一個最小值 MIN(2,2,1) 填入矩陣中，完成。</li>
</ol>
<p><img src="levenshtein_distance/1.png" alt="" /></p>
<p><em>圖二：子字串 k 與 s 的編輯距離</em></p>
<p>我們再來看一組範例，k 與 si 的距離為 2：</p>
<ol>
<li>紅字上方是執行刪除的累積編輯距離（2），加上刪除操作的成本（1），為 2 + 1 = 3</li>
<li>紅字左方是執行插入的累積編輯距離（1），加上插入操作的成本（1），為 1 + 1 = 2</li>
<li>紅字對角是執行置換的累積編輯距離（1），加上當前 k i 字元不相等的置換成本（1），為 1 + 1 = 2</li>
<li>從刪除、插入、置換的成本中選一個最小值 MIN(3,2,2) 填入矩陣中，完成。</li>
</ol>
<p><img src="levenshtein_distance/2.png" alt="" /></p>
<p><em>圖三：子字串 k 與 si 的編輯距離</em></p>
<p>最後計算出來整個編輯距離矩陣會長得如下，取矩陣最後一行一列的元素就是累積計算出來的 kitten 與 sitting 的編輯距離。</p>
<p><img src="levenshtein_distance/matrix.png" alt="" /></p>
<p><em>圖三：字串 kitten 與 sitting 的完整編輯距離矩陣</em></p>
<p>這就是透過動態規劃，將會重複計算的子字串編輯距離紀錄起來，降低原始算式的時空間複雜度，非常簡單暴力的演算法。</p>
<h2 id="實作-14"><a class="header" href="#實作-14">實作</a></h2>
<p>萊文斯坦距離的函式簽名很簡單，就是吃兩個 string 回傳一個距離：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn levenshtein_distance(source: &amp;str, target: &amp;str) -&gt; usize
<span class="boring">}</span></code></pre></pre>
<p>首先，先實作第一個子函數</p>
<p>$$
\max(i,j) \hspace{10 pt} \text{if} \min(i,j) = 0
$$</p>
<p>當任一字串長度為 0 時（min(i,j）），編輯距離為另一字串之長度。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn levenshtein_distance(source: &amp;str, target: &amp;str) -&gt; usize {
    if source.is_empty() {
        return target.len()
    }
    if target.is_empty() {
        return source.len()
    }
    /// ...snip
}
<span class="boring">}</span></code></pre></pre>
<h3 id="距離矩陣"><a class="header" href="#距離矩陣">距離矩陣</a></h3>
<p>接下來實作矩陣的部分，這是純天然沒有特別最佳化的版本，要做三件事：</p>
<ul>
<li>建立一個 a+1 x b+1 的空矩陣，加一是因為要算入 a b 為空字串的狀況。</li>
<li>填入 a b 為空字串時第一列與第一行的編輯距離，也就是全插入和全刪除的狀況。</li>
<li>按照前一節的概念計算整個距離矩陣。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // ...snip
    let source_count = source.chars().count(); // 1
    let target_count = target.chars().count();

    let mut distances = vec![vec![0; target_count + 1]; source_count + 1]; // 2

    // 3
    for i in 1..=source_count {
        distances[i][0] = i;
    }

    for j in 1..=target_count {
        distances[0][j] = j;
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>使用 <a href="http://doc.rust-lang.org/std/primitive.str.html#method.chars"><code>str::chars</code></a> 計算字串長度，Rust 的 <a href="http://doc.rust-lang.org/std/primitive.str.html#method.len"><code>str::len</code></a> 回傳的是位元組（byte）的長度，沒有考慮人類閱讀 UTF-8 編碼字串的視覺字元長度。選用 Chars 可以處理絕大部分常見的 UTF-8 字串問題（支援 CJK）。</li>
<li>使用 <code>vec!</code> 巨集建立一個 vector of vector，也就是我們的距離矩陣。</li>
<li>填入第一行和第一列空字串時的狀況，也就是初始化成圖一的情形。</li>
</ol>
<p>第二步則是撰寫計算距離矩陣編輯操作的邏輯：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // ...snip
    for (i, ch1) in source.chars().enumerate() {
        for (j, ch2) in target.chars().enumerate() {
            let ins = distances[i + 1][j] + 1; // 1
            let del = distances[i][j + 1] + 1; // 2
            let sub = distances[i][j] + (ch1 != ch2) as usize; // 3
            distances[i + 1][j + 1] = cmp::min(cmp::min(ins, del), sub); // 4
        }
    }

    // 5
    *distances.last().and_then(|d| d.last()).unwrap()
<span class="boring">}</span></code></pre></pre>
<ol>
<li>計算插入操作成本，對應萊文斯坦函數中 $\operatorname{lev} _{a,b}(i,j-1) + 1$ 子函數。</li>
<li>計算刪除操作成本，對應萊文斯坦函數中 $\operatorname{lev} _{a,b}(i-1,j) + 1$ 子函數。</li>
<li>計算刪除操作成本，對應萊文斯坦函數中 $\operatorname{lev} _{a,b}(i-1,j-1) + 1 _{(a _{i} \neq b _{j})}$，這裡用了 <a href="http://doc.rust-lang.org/std/keyword.as.html"><code>as</code></a> 運算子，可以在原生型別（primitive type）間互相轉型。</li>
<li>取最小值並紀錄在當前的位置，也就是圖二圖三的綠底紅字。</li>
<li>算完整個距離矩陣後，最後一列最後一行元素就是 a b 兩字串的萊文斯坦距離，你可能好奇，直接呼叫 <code>unwrap</code> 沒有處理錯誤合理嗎？其實在「一定不可能出錯」的地方，呼叫 <code>unwrap</code> 完全可接受，省去不必要的空值處理。</li>
</ol>
<p>完整程式碼如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn levenshtein_distance_naive(source: &amp;str, target: &amp;str) -&gt; usize {
    if source.is_empty() {
        return target.len();
    }
    if target.is_empty() {
        return source.len();
    }

    let source_count = source.chars().count(); // 1
    let target_count = target.chars().count();

    let mut distances = vec![vec![0; target_count + 1]; source_count + 1]; // 2

    // 3
    for i in 1..=source_count {
        distances[i][0] = i;
    }

    for j in 1..=target_count {
        distances[0][j] = j;
    }

    for (i, ch1) in source.chars().enumerate() {
        for (j, ch2) in target.chars().enumerate() {
            let ins = distances[i + 1][j] + 1; // 1
            let del = distances[i][j + 1] + 1; // 2
            let sub = distances[i][j] + (ch1 != ch2) as usize; // 3
            distances[i + 1][j + 1] = cmp::min(cmp::min(ins, del), sub); // 4
        }
    }

    // 5
    *distances.last().and_then(|d| d.last()).unwrap()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="使用一維陣列減少記憶體配置"><a class="header" href="#使用一維陣列減少記憶體配置">使用一維陣列減少記憶體配置</a></h3>
<p>Rust 的 <code>Vec</code> 並非簡單的 array，而是在堆積（heap）上配置記憶體，而每一個 <code>Vec</code> 都會帶一個指標和兩個值：指標指向在堆積上的資料，一個值儲存資料當前的長度，一個值儲存容量（圖解請參考 <a href="https://cheats.rs/#general-purpose-heap-storage">cheats.rs</a>）。所以 <code>Vec</code> 會佔三個 usize 的大小，在 64 位元作業系統中就是 24 個位元組。</p>
<p>但實際上，我們的距離矩陣根本不需要真的矩陣，只需要兩個東西</p>
<ul>
<li>一個一維的 <code>Vec</code></li>
<li>一個將二維索引映射到一維空間的函數</li>
</ul>
<p>再稍微做些小調整就行，如下：</p>
<pre><code class="language-patch">    // ...snip
    // 1
+    let index = |i, j| i * (target_count + 1) + j;

    // 2
-    let mut distances = vec![vec![0; target_count + 1]; source_count + 1];
+    let mut distances = vec![0; (target_count + 1) * (source_count + 1)];

    for i in 1..=source_count {
    // 3
-        distances[i][0] = i;
+        distances[index(i, 0)] = i;
    }
    // ...change matrix indexing as above
</code></pre>
<ol>
<li>二維索引轉換成一維索引的閉包（closure）</li>
<li>原本的 <code>Vec&lt;Vec&lt;usize&gt;&gt;</code> 變為 <code>Vec&lt;usize&gt;</code> 的一維矩陣，總元素量不變</li>
<li>改寫所有矩陣索引</li>
</ol>
<blockquote>
<p>若要更有趣的索引方式，可以實作 <a href="http://doc.rust-lang.org/core/ops/trait.Index.html"><code>core::ops::Index</code></a> trait，這裡就不贅述了。</p>
</blockquote>
<h3 id="拋棄矩陣降低空間複雜度"><a class="header" href="#拋棄矩陣降低空間複雜度">拋棄矩陣：降低空間複雜度</a></h3>
<p>回想一下，當我們在計算一個編輯距離時，其實只需要取得三個累積的編輯距離：插入 <code>matrix[i, j-1]</code>、刪除 <code>matrix[i-1, j]</code>，以及置換 <code>matrix[i-1, j-1]</code>。如圖四</p>
<p><img src="levenshtein_distance/pre-opt-1.png" alt="" /></p>
<p><em>圖四：計算一個編輯距離所需之資料。</em></p>
<p>這就表示，根本「<strong>無需儲存完整距離矩陣</strong>」，只需儲存前一列的資訊 + 額外一個變數儲存置換操作的成本就行。我們需要儲存的資訊從 (a + 1) x (b + 1) 大小的矩陣，縮小至 a + 1 或 b + 1 長度的一維陣列。</p>
<p><img src="levenshtein_distance/opt-1.png" alt="" /></p>
<p><em>圖五：僅使用一維陣列儲存前一列的資訊。黃色為儲存的陣列，藍色為額外儲存的置換的累積編輯距離</em></p>
<p>這個最佳化的程式碼，比起矩陣解法又更簡短了，以下一一說明：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn levenshtein_distance(source: &amp;str, target: &amp;str) -&gt; usize {
    // 1
    if source.is_empty() {
        return target.len();
    }
    if target.is_empty() {
        return source.len();
    }

    // 2
    let mut distances = (0..=target.chars().count()).collect::&lt;Vec&lt;_&gt;&gt;();

    for (i, ch1) in source.chars().enumerate() {
        let mut sub = i; // 3
        distances[0] = sub + 1; // 4
        for (j, ch2) in target.chars().enumerate() {
            let dist = cmp::min(
                // 5
                cmp::min(
                    distances[j],     // insert
                    distances[j + 1], // delete
                ) + 1,
                sub + (ch1 != ch2) as usize, // substitute
            );

            sub = distances[j + 1]; // 6
            distances[j + 1] = dist; // 7
        }
    }

    *distances.last().unwrap() // 8
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>和前一段相同，計算空字串的距離。</li>
<li>不需要初始化 a x b 個元素，只需要初始化最多一列的陣列。這裡利用 <code>0..=count</code> 這種 <a href="http://doc.rust-lang.org/core/ops/struct.RangeInclusive.html"><code>core::ops::RangeInclusive</code></a> 的寫法，直接產出含有 0 到字串長度的 <code>Vec&lt;usize&gt;</code>，這段等同 naive 作法中填入第一列全插入的編輯距離，但省下自己手寫一個迴圈。</li>
<li>將索引 i 作為初始化的刪除編輯距離，等同於 naive 作法中填入第一行全刪除的編輯距離，但尚未用到的距離就跟著索引 i 遞增，不需事先計算了。這個 <code>sub</code> 也等同於置換的累積編輯距離。</li>
<li>置換的累積編輯距離 + 1 就會等於插入的累積編輯距離。</li>
<li>前面步驟配置好陣列後，就可以來計算函數：
<ul>
<li>插入：索引 j 的元素就是插入的累積編輯距離（圖五紅字左方）。</li>
<li>刪除：索引 j + 1 的元素就是刪除的累積編輯距離（圖五紅字上方）。</li>
<li>置換：<code>sub</code> 變數儲存的就是置換的累積編輯距離（圖五藍色）。</li>
</ul>
</li>
<li>更新 <code>sub</code> 置換的累積編輯距離，也就是這一輪的刪除的累積編輯距離（圖六藍色），以供內層迴圈下個 target char 疊代使用。</li>
<li>將計算所得的編輯距離填入陣列中（圖五紅字/圖六紅字左方），以供外層迴圈計算下一列疊代時使用。</li>
<li>計算完成，取最後一個元素就是兩字串的編輯距離了。</li>
</ol>
<p><img src="levenshtein_distance/opt-2.png" alt="" /></p>
<p><em>圖六：使用一維陣列疊代計算，藍色為額外儲存的置換的累積編輯距離</em></p>
<h2 id="效能-22"><a class="header" href="#效能-22">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Complexity</th></tr></thead><tbody>
<tr><td>Worst</td><td>$O(mn)$</td></tr>
<tr><td>Worst space</td><td>$O(\min(m,n))$</td></tr>
<tr><td>Worst space (naive)</td><td>$O(mn)$</td></tr>
</tbody></table>
</div>
<blockquote>
<p>$m$：字串 a 的長度<br />
$n$：字串 b 的長度</p>
</blockquote>
<p>顯而易見，萊文斯坦距離最差時間複雜度就是內外兩個迴圈疊代兩個字串的所有字元。而空間複雜度原本是 $m \cdot n$ 的矩陣，在最佳化動態規劃後，只需兩字串長度 m 或 n 中最小值長度陣列作為儲存空間。</p>
<h2 id="參考資料-25"><a class="header" href="#參考資料-25">參考資料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Wiki: Levenshtein distance</a></li>
<li><a href="https://github.com/rust-lang/cargo/blob/7d7fe6797ad07f313706380d251796702272b150/src/cargo/util/lev_distance.rs">Levenshtein distance in Cargo</a></li>
<li><a href="https://github.com/rust-lang/rust/commit/4908017d59da8694b9ceaf743baf1163c1e19086#diff-4bb86c087880e113f4d68d0b846eff3f5078612f8c08915a2b58162c332fb7dc">Levenshtein distance in Rust Std (1.0.0-alpha)</a></li>
<li><a href="https://thaumant.me/optimizing-loop-heavy-rust/">Ilia Schelokov: Optimizing loop heavy Rust code</a></li>
<li><a href="https://turnerj.com/blog/levenshtein-distance-part-2-gotta-go-fast">Turnerj: Levenshtein Distance (Part 2: Gotta Go Fast)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="貢獻指南"><a class="header" href="#貢獻指南">貢獻指南</a></h1>
<p>感謝您有興趣貢獻 Rust 演算法俱樂部。我們歡迎各種形式的協助。這裡列出幾種任務供你挑選。</p>
<ul>
<li>增加新的演算法</li>
<li>修正已知的漏洞</li>
<li>改善文件的品質</li>
</ul>
<p>接下來，將介紹幾個貢獻的注意事項。</p>
<h2 id="開始貢獻之前"><a class="header" href="#開始貢獻之前">開始貢獻之前</a></h2>
<p>若您決定著手做些厲害的事，請先在<a href="https://github.com/weihanglo/rust-algorithm-club/search?q=&amp;type=Issues&amp;utf8=%E2%9C%93">已知 issues 與 pull requests</a> 搜尋，那裡可能已有回報相似的問題。</p>
<p>若沒有重複的問題，請發起一個「進行中（work-in-progress）」的 issue，告知其他人你正在做這項功能。你的時間很寶貴，必須防止重工發生。維護團隊也會追蹤這些 issue 以利管理俱樂部。</p>
<p>有些 meta issue 專門追蹤尚未完成的工作 🚧，可以去看看是否有感興趣的主題。</p>
<h2 id="提交你的成果"><a class="header" href="#提交你的成果">提交你的成果</a></h2>
<p>在提交你的貢獻之前，確認成果滿足下列需求：</p>
<ul>
<li>不要搞壞既有測試。發起 pull request 前執行 <code>cargo test</code>。新的演算法也需包含自身的單元測試。</li>
<li>每個對外介面都需要有文件。這個文件不需要完美無缺，但至少清楚說明它的目的與用法。</li>
<li>儘量維持文章間寫作風格與結構一致。例如：首段需包含簡扼的敘述、解釋效能時請愛用漸進符號。</li>
<li>程式碼撰寫風格應貼近 Rust 的慣例，例如：涉及所有權轉移請使用 <code>into</code>、替額外建構式命名請添加 <code>with</code> 前綴。目前為止，並不強制使用 <a href="https://github.com/rust-lang-nursery/rust-clippy">Clippy</a> 與 <a href="https://github.com/rust-lang-nursery/rustfmt">rustfmt</a>。</li>
</ul>
<h3 id="歡迎加入-rust-演算法俱樂部願演算法與你同在"><a class="header" href="#歡迎加入-rust-演算法俱樂部願演算法與你同在">歡迎加入 Rust 演算法俱樂部，願演算法與你同在！</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oops-something-went-wrong"><a class="header" href="#oops-something-went-wrong">Oops! Something went wrong…</a></h1>
<p><img src="https://weihanglo.tw/assets/ferris-404.png" alt="" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/custom.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
