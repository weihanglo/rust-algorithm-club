var N=null,E="",T="t",U="u",searchIndex={};
var R=["usize","option","remove","is_empty","Checks whether the container is empty.","Creates an iterator that yields immutable reference of…","iter_mut","Creates an iterator that yields mutable reference of each…","insert","hashset","with_capacity","rust_algorithm_club","rust_algorithm_club::collections","into_iter","result","try_from","try_into","borrow_mut","type_id","ordering","SinglyLinkedList"];

searchIndex["rust_algorithm_club"]={"doc":E,"i":[[0,"collections",R[11],"Collections.",N,N],[3,R[20],R[12],"A singly-linked list with owned nodes.",N,N],[3,"HashMap",E,"A hash map implemented with separate chaining collision…",N,N],[3,"HashSet",E,"A hash set implementation based on `HashMap`.",N,N],[3,"Stack",E,"A stack-like data structure implemented through a `Vec`.",N,N],[11,"new",E,"Constructs a new, empty `SinglyLinkedList<T>`.",0,[[],["self"]]],[11,"push_front",E,"Prepends the given element value to the beginning of the…",0,[[["self"],[T]]]],[11,"pop_front",E,"Removes and returns the first element of the container. If…",0,[[["self"]],[R[1]]]],[11,"insert_after",E,"Inserts an element after the specified position in the…",0,[[["self"],[R[0]],[T]],[[R[14],[R[0]]],[R[0]]]]],[11,R[2],E,"Removes and returns an element at specified position from…",0,[[["self"],[R[0]]],[R[1]]]],[11,"clear",E,"Removes all elements from the container.",0,[[["self"]]]],[11,R[3],E,R[4],0,[[["self"]],["bool"]]],[11,"len",E,"Gets the number of elements in the container.",0,[[["self"]],[R[0]]]],[11,"reverse",E,"Reverses the order of the elements in the container.",0,[[["self"]]]],[11,"iter",E,R[5],0,[[["self"]],["iter"]]],[11,R[6],E,R[7],0,[[["self"]],["itermut"]]],[11,"new",E,"Creates an empty map with capacity 0.",1,[[],["self"]]],[11,R[10],E,"Creates a map with a given capacity as the number of…",1,[[[R[0]]],["self"]]],[11,"get",E,"Gets a reference to the value under the specified key.",1,[[["self"],["q"]],[["v"],[R[1]]]]],[11,"get_mut",E,"Gets a mutable reference to the value under the specified…",1,[[["self"],["q"]],[[R[1]],["v"]]]],[11,R[8],E,"Inserts key-value pair into the map. Replaces previous…",1,[[["self"],["k"],["v"]],[R[1]]]],[11,R[2],E,"Removes a pair with specified key.",1,[[["self"],["q"]],[R[1]]]],[11,"clear",E,"Removes all key-value pairs but keeps the allocated memory…",1,[[["self"]]]],[11,R[3],E,R[4],1,[[["self"]],["bool"]]],[11,"len",E,"Gets the number of key-value pairs in the container.",1,[[["self"]],[R[0]]]],[11,"bucket_count",E,"Gets the number of underlying buckets.",1,[[["self"]],[R[0]]]],[11,"iter",E,R[5],1,[[["self"]]]],[11,R[6],E,R[7],1,[[["self"]]]],[11,R[13],E,"Creates a consuming iterator yielding elements in…",1,[[]]],[11,"new",E,"Creates an empty set.",2,[[],["self"]]],[11,"len",E,"Gets the number of non-repetitive elements, equivalently…",2,[[["self"]],[R[0]]]],[11,R[3],E,"Returns whether there is no any element in the set.",2,[[["self"]],["bool"]]],[11,R[8],E,"Inserts an element into the set.",2,[[["self"],[T]],["bool"]]],[11,"contains",E,"Returns whether an element is present in the set.",2,[[["self"],["q"]],["bool"]]],[11,R[2],E,"Removes an element from the set.",2,[[["self"],["q"]],["bool"]]],[11,"iter",E,"Creates an iterator yielding immutable reference of each…",2,[[["self"]]]],[11,"union",E,"Returns an iterator visiting items that exists in `self`,…",2,[[["self"],[R[9]]]]],[11,"difference",E,"Returns an iterator visiting items that exists in `self`…",2,[[["self"],[R[9]]]]],[11,"symmetric_difference",E,"Returns an iterator visiting items that only exists in…",2,[[["self"],[R[9]]]]],[11,"intersection",E,"Returns an iterator visiting items that exists in both…",2,[[["self"],[R[9]]]]],[11,"is_disjoint",E,"Returns true if `self` has no elements in common with…",2,[[["self"],[R[9]]],["bool"]]],[11,"is_subset",E,"Returns true if `other` contains at least all elements in…",2,[[["self"],[R[9]]],["bool"]]],[11,"is_superset",E,"Returns true if `self` contains at least all elements in…",2,[[["self"],[R[9]]],["bool"]]],[11,R[10],E,"Initialize a stack of certain capacity.",3,[[[R[0]]],["self"]]],[11,"pop",E,"Removes the most recently added element that was not yet…",3,[[["self"]],[R[1]]]],[11,"push",E,"Adds an element to the collection.",3,[[["self"],[T]],["bool"]]],[11,"size",E,"Returns",3,[[["self"]],[R[0]]]],[11,"peek",E,"Peeks the last element added without tampering the…",3,[[["self"]],[[R[1]],[T]]]],[0,"searching",R[11],"Searching algorithms.",N,N],[5,"linear_search","rust_algorithm_club::searching","Linear search.",N,[[[T]],[[R[1],[R[0]]],[R[0]]]]],[5,"binary_search",E,"Handmade binary search for a sorted sequence.",N,[[[T]],[[R[14],[R[0],R[0]]],[R[0]]]]],[5,"interpolation_search",E,"Search in sorted sequences by checking the next position…",N,[[["i32"]],[[R[14],[R[0],R[0]]],[R[0]]]]],[5,"exponential_search",E,"Exponential search. An binary search variant that can…",N,[[[T]],[[R[14],[R[0],R[0]]],[R[0]]]]],[0,"sorting",R[11],"Sorting algorithms.",N,N],[5,"bubble_sort","rust_algorithm_club::sorting","Bubble sort",N,[[]]],[5,"bubble_sort_optimized",E,"Optimized bubble sort",N,[[]]],[5,"binary_insertion_sort",E,"Binary insertion sort.",N,[[]]],[5,"insertion_sort",E,"Insertion sort.",N,[[]]],[5,"selection_sort",E,"Selection sort.",N,[[]]],[5,"shellsort",E,"Shellsort",N,[[]]],[5,"mergesort",E,"Mergesort.",N,[[]]],[5,"mergesort_bottom_up",E,"Mergesort bottom-up version.",N,[[]]],[5,"heapsort",E,"Heapsort.",N,[[]]],[5,"quicksort",E,"Quicksort with Lomuto parition scheme.",N,[[]]],[5,"quicksort_3way",E,"Quicksort with 3-way parition scheme.",N,[[]]],[5,"quicksort_hoare",E,"Quicksort with Hoare parition scheme",N,[[]]],[5,"quicksort_manual_tco",E,"Manual tail-call opitimized quicksort with Lomuto parition…",N,[[]]],[5,"quicksort_optimized",E,"Tail-call opitimized quicksort with Lomuto parition scheme.",N,[[]]],[5,"bucket_sort",E,"Bucket sort",N,[[["f"]]]],[5,"counting_sort",E,"Counting sort",N,[[[R[0]],["f"]]]],[5,"radix_sort",E,"Radix sort for sorting unsigned integers.",N,[[]]],[5,"timsort",E,"Timsort.",N,[[]]],[5,"introsort",E,"Introsort.",N,[[]]],[5,"pdqsort",E,"Pattern-defeating quicksort.",N,[[]]],[17,"MARCIN_GAPS",E,"Marcin Ciura's gap sequence.",N,N],[11,"from",R[12],E,0,[[[T]],[T]]],[11,R[13],E,E,0,[[],["i"]]],[11,"into",E,E,0,[[],[U]]],[11,R[15],E,E,0,[[[U]],[R[14]]]],[11,R[16],E,E,0,[[],[R[14]]]],[11,R[17],E,E,0,[[["self"]],[T]]],[11,"borrow",E,E,0,[[["self"]],[T]]],[11,R[18],E,E,0,[[["self"]],["typeid"]]],[11,"from",E,E,1,[[[T]],[T]]],[11,"into",E,E,1,[[],[U]]],[11,R[15],E,E,1,[[[U]],[R[14]]]],[11,R[16],E,E,1,[[],[R[14]]]],[11,R[17],E,E,1,[[["self"]],[T]]],[11,"borrow",E,E,1,[[["self"]],[T]]],[11,R[18],E,E,1,[[["self"]],["typeid"]]],[11,"from",E,E,2,[[[T]],[T]]],[11,"into",E,E,2,[[],[U]]],[11,R[15],E,E,2,[[[U]],[R[14]]]],[11,R[16],E,E,2,[[],[R[14]]]],[11,R[17],E,E,2,[[["self"]],[T]]],[11,"borrow",E,E,2,[[["self"]],[T]]],[11,R[18],E,E,2,[[["self"]],["typeid"]]],[11,"from",E,E,3,[[[T]],[T]]],[11,"into",E,E,3,[[],[U]]],[11,R[15],E,E,3,[[[U]],[R[14]]]],[11,R[16],E,E,3,[[],[R[14]]]],[11,R[17],E,E,3,[[["self"]],[T]]],[11,"borrow",E,E,3,[[["self"]],[T]]],[11,R[18],E,E,3,[[["self"]],["typeid"]]],[11,"partial_cmp",E,"Compares sets to determine whether one is a subset of the…",2,[[["self"],[R[9]]],[[R[1],[R[19]]],[R[19]]]]],[11,"default",E,E,1,[[],["self"]]],[11,"default",E,E,2,[[],["self"]]],[11,R[13],E,"Creates a consuming iterator, that is, one that moves each…",0,[[]]],[11,"drop",E,E,0,[[["self"]]]],[11,"eq",E,E,0,[[["self"]],["bool"]]],[11,"eq",E,"Checks the equality of sets.",2,[[["self"],[R[9]]],["bool"]]],[11,"fmt",E,E,0,[[["self"],["formatter"]],[R[14]]]],[11,"from_iter",E,E,2,[[["i"]],["self"]]]],"p":[[3,R[20]],[3,"HashMap"],[3,"HashSet"],[3,"Stack"]]};
initSearch(searchIndex);addSearchOptions(searchIndex);