<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>單向鏈結串列 Singly linked list - Rust Algorithm Club</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Learn algorithms and data structures with Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Algorithm Club</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/weihanglo/rust-algorithm-club" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="單向鏈結串列-singly-linked-list"><a class="header" href="#單向鏈結串列-singly-linked-list">單向鏈結串列 Singly linked list</a></h1>
<p>單向鏈結串列是鏈結串列家族中最簡單的版本，特色是每兩個節點間只有一個單向的鏈結。</p>
<pre><code>   head
    |
    v
+--------+   +--------+   +--------+
|        |   |        |   |        |
| node 0 |--&gt;| node 1 |--&gt;| node 2 |--&gt; NULL
|        |   |        |   |        |
+--------+   +--------+   +--------+
</code></pre>
<p>比起 <a href="doubly.html">雙向鏈結串列</a>，單向鏈結串列少了一個額外的指標開銷，在基本操作的花費也較低。在不需要雙向疊代情形下單向鏈結串列很適用。</p>
<p>此外，單向鏈結串列也支援 tail-sharing，也就是共享 sublist。藉由共享 sublist，單向鏈結串列很容易實作 <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">persistent data structure</a>，再配合 immutable 特性，使得單向鏈結串列幾乎成為函數式程式語言最常見的集合型別之一。可以參考這篇 <a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/third.html">persistent immutable stack 實作</a>文章。</p>
<blockquote>
<p>本次實作的程式碼置於 <a href="/doc/rust_algorithm_club/collections/struct.SinglyLinkedList.html"><code>rust_algorithm_club::collections::SinglyLinkedList</code></a> API 文件中。</p>
</blockquote>
<h2 id="實作設計"><a class="header" href="#實作設計">實作設計</a></h2>
<h3 id="node"><a class="header" href="#node">Node</a></h3>
<p>先建立最基本的節點 Node。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// cannot compile
struct Node&lt;T&gt; {
    elem: T,
    next: Node&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Node.elem</code> 很直觀地儲存實際資料。而 <code>Node.next</code> 則是指向下個 Node。但這樣編譯不會成功，Rust 編譯時需要決定每個型別該配置多少記憶體空間，這種遞迴型別使得編譯器無限循環，無法決定配置大小。</p>
<p><img src="node-recursive.svg" alt="node-recursive" /></p>
<p>很簡單，我們使用 <a href="https://doc.rust-lang.org/std/boxed/index.html"><code>Box&lt;T&gt;</code></a> 這個<a href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html">智慧指標</a>，直接將 Node 配置在記憶體 heap 上。如此以來，編譯器就會知道 <code>next</code> 只佔了一個指標的空間。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Node&lt;T&gt; {
    elem: T,
    next: Box&lt;Node&lt;T&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><img src="node-box.svg" alt="node-box" /></p>
<p>由於 Rust 沒有 null pointer，但照鏈結串列的定義，<code>Node.next</code> 可以是 NULL，因此我們使用 <a href="https://doc.rust-lang.org/std/option/index.html"><code>Option&lt;T&gt;</code></a> 模擬 null pointer 的行為。最後，Node 的定義如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Node&lt;T&gt; {
    elem: T,
    next: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="singlylinkedlist"><a class="header" href="#singlylinkedlist">SinglyLinkedList</a></h3>
<p>在開始實作各種增刪節點的操作之前，我們需要建立一個 struct 存放指向鏈結串列 head 的指標，同時，各種操作也會實作在這個 struct 上。事實上，這個 struct 就是對外公開的資料結構。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SinglyLinkedList&lt;T&gt; {
    head: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>選擇把操作串列的函式寫在另一個 struct 而非 Node 上有幾個原因，1）外部並不需知道串列內部如何實作，公開 Node 會暴露實作。2）每個 Node 都帶有成員函式的話，函式指標會佔用太多額外資源。</p>
<h2 id="基本操作"><a class="header" href="#基本操作">基本操作</a></h2>
<p>串列的基本操作如下：</p>
<ul>
<li><code>new</code>：初始化一個空串列。</li>
<li><code>push_front</code>：新增節點到開頭的位置。</li>
<li><code>pop_front</code>：將開頭第一個節點移除。</li>
<li><code>insert_after</code>：在指定索引位置後插入一個新節點。</li>
<li><code>remove</code>：移除任意索引下的節點。</li>
<li><code>clear</code>：清除所有節點。</li>
<li><code>is_empty</code>：檢查串列是否沒有任何節點。</li>
<li><code>reverse</code>：反轉整個串列（head 變成 tail）。</li>
</ul>
<h3 id="初始化與清除資料"><a class="header" href="#初始化與清除資料">初始化與清除資料</a></h3>
<p>實做初始化與清除資料非常直觀。其中清除其實就只是將 <code>self</code> 指向新的串列實例。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; SinglyLinkedList&lt;T&gt; {
    pub fn new() -&gt; Self {
        Self { head: None }
    }


}
<span class="boring">}</span></code></pre></pre>
<p>你可能會想，在清除所有資料時，資源需不需要手動釋放？</p>
<p>和 C++ 的 RAII 一樣，Rust 有一個名叫 <code>drop</code> 的解構式，只要程式執行離開了資源擁有者的可視範圍（out of scope），就會自動呼叫 <code>drop</code>。我們在 <a href="#drop-trait">Drop trait</a> 一節會再深入探討。</p>
<h3 id="增刪首個節點"><a class="header" href="#增刪首個節點">增刪首個節點</a></h3>
<p>單向鏈結串列在第一個節點前增加新節點，或是刪除第一個節點，都可以在常數時間完成。新增節點 <code>push_front</code> 的概念很簡單，1）建立新的節點，並把新節點 <code>next</code> 指標指向串列第一個節點。2）把串列的 head 指向新建立的節點。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn push_front(&amp;mut self, elem: T) {
        let next = self.head.take(); // 1
        self.head = Some(Box::new(Node { elem, next })); // 2
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>釋放 SinglyLinkedList 對第一個節點的所有權</li>
<li>建立一新節點，並將原本第一個節點所有權轉移給新節點。再將新節點所有權轉移到串列本身。</li>
</ol>
<p>刪除第一個節點 <code>pop_front</code> 的實作步驟如下：首先取得第一個節點的所有權，再將 head 指向第一個節點 <code>Node.next</code> 下一個節點，再返回第一個節點的資料給呼叫端。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
        // Take ownership of head
        let head = self.head.take()?; // 1
        self.head = head.next; // 2
        Some(head.elem) // 3
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>取得第一個元素的所有權，若無首個元素，表示串列為空，此處利用 <a href="http://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html"><code>?</code> 運算子</a>直接回傳 <code>None</code>。</li>
<li>將 head 指向下一個節點。</li>
<li>返回即將刪除節點的資料。</li>
</ol>
<h3 id="插入刪除任意節點"><a class="header" href="#插入刪除任意節點">插入刪除任意節點</a></h3>
<p>鏈結串列新增和刪除第一個節點都可以在 $O(1)$ 時間內做完，那為什麼插入刪除任意節點沒有辦法呢？原因是鏈結串列不支援隨機存取（random access），就是無法透過索引在常數時間內取得資料，每次的搜尋都只能從 head 開始。因此，當我們需要在某個索引的節點後新增一筆資料，我們會需要最差 $O(n)$ 的複雜度。</p>
<p>實作插入 <code>insert_after</code> 分為幾個步驟：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn insert_after(&amp;mut self, pos: usize, elem: T) -&gt; Result&lt;(), usize&gt; {
        let mut curr = &amp;mut self.head;
        let mut pos_ = pos;

        // Find the node at `pos`.
        while pos_ &gt; 0 {
            // 1
            curr = match curr.as_mut() {
                Some(node) =&gt; &amp;mut node.next,
                None =&gt; return Err(pos - pos_),
            };
            pos_ -= 1;
        }

        // Take the ownership of current node.
        match curr.take() {
            // 2
            Some(mut node) =&gt; {
                // Node A
                // Create new node.
                let new_node = Box::new(Node {
                    // 3: Node B
                    elem,
                    next: node.next,
                });
                // Re-link new node and current node.
                node.next = Some(new_node); // 4

                // Assign current node back to the list.
                *curr = Some(node); // 5
            }
            None =&gt; return Err(pos - pos_),
        }
        Ok(())
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>找到對應索引值的節點 A，若找不到則回傳這個串列的資料長度。</li>
<li>先取得節點 A 的所有權，才能修改它的值。</li>
<li>建立新節點 B，同時將節點 B 的 <code>next</code> 指向 A 的後一個節點。</li>
<li>將新節點 B 做為節點 A 後一個節點 <code>next</code>。</li>
<li>把修改過的節點 A，重新賦值給指向節點 A 的指標 <code>curr</code>（可視為歸還所有權）。</li>
</ol>
<p>而實作刪除任意索引下的節點 <code>remove</code> 和插入非常相似。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn remove(&amp;mut self, pos: usize) -&gt; Option&lt;T&gt; {
        let mut curr = &amp;mut self.head;
        let mut pos = pos;

        // Find the node at `pos`.
        while pos &gt; 0 {
            // 1
            curr = &amp;mut curr.as_mut()?.next;
            pos -= 1;
        }

        // Assign next node to previous node.next pointer.
        let node = curr.take()?; // 2: Node A
        *curr = node.next; // 3: node.next is Node B
        Some(node.elem) // 4
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>找到對應索引值的節點 A，若找不到則回傳 <code>None</code>。</li>
<li>先取得節點 A 的所有權，才能修改它的值。</li>
<li>把節點 A 的後一個節點 B 賦值給原本指向節點 A 的指標 <code>curr</code>。</li>
<li>回傳節點 A 的值。</li>
</ol>
<h3 id="反轉"><a class="header" href="#反轉">反轉</a></h3>
<p>反轉鏈結串列是工作面試時很常見的考題，這裡來實作看看。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn reverse(&amp;mut self) {
        let mut prev = None; // 1: prev -&gt; Node P
        let mut curr = self.head.take(); // 2
        while let Some(mut node) = curr {
            // 3: node -&gt; Node A
            let next = node.next; // 3-1: next -&gt; Node B
            node.next = prev.take(); // 3-2: Take ownership from previous node.
            prev = Some(node); // 3-3: Transfer ownership from current node to previous.
            curr = next; // 3-4: curr references to next node for next iteration.
        }
        self.head = prev.take(); // 4
    }
<span class="boring">}</span></code></pre></pre>
<ol>
<li>先建立一個暫時變數 <code>prev</code>，儲存疊代時的前一個節點。</li>
<li>從串列 head 取得第一個節點的所有權。</li>
<li>依序疊代整個串列
<ol>
<li>將節點 A 的後一個節點 B 暫存起來。</li>
<li>節點 A 的 <code>next</code> 指向暫存在變數 <code>prev</code> 的節點 P。</li>
<li>節點 A 暫存在變數 <code>prev</code> 內，保留到下一個疊代使用。</li>
<li>將節點 B 儲存在變數 <code>curr</code> 內。此時<br />
<code>prev</code>：節點 A，A 的 <code>next</code> 指向 P，<br />
<code>curr</code>：節點 B，B 的 <code>next</code> 指向 A。</li>
</ol>
</li>
<li>最後一次疊代時，變數 <code>prev</code> 會儲存原始串列末端節點，這時轉移所有權到 head，完成反轉。</li>
</ol>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>除了基本操作，<code>SinglyLinkedList</code> 實作了許多 trait，使用上更方便更符合 Rust 的慣例。</p>
<h3 id="drop-trait"><a class="header" href="#drop-trait">Drop trait</a></h3>
<p>如果一個 struct 有許多成員，則會遞迴呼叫 struct 的 <code>drop</code> 成員函式。因此，一個串列的解構式很可能發生深層的巢狀遞迴：</p>
<pre><code># a linked list
a -&gt; b -&gt; c -&gt; x -&gt; y -&gt; z

# call stack when `drop` being called

(a.drop
  (b.drop
    (c.drop
      (x.drop
        (y.drop
          (z.drop
          (z.dropped
        (y.dropped
      (x.dropped
    (c.dropped
  (b.dropped
(a.dropped
</code></pre>
<p>如果節點一多，肯定會 stack overflow，太可怕了！</p>
<p>既然如此，那麼就透過 <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop trait</a>，實作一個疊代版本的解構式，消弭可怕的 call stack 吧。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Drop for SinglyLinkedList&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut link = self.head.take(); // 1
        while let Some(mut node) = link {
            // 2
            link = node.next.take(); // 3: Take ownership of next `link` here.
        }
        // 4: Previous `node` goes out of scope and gets dropped here.
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>取得 head 的所有權。</li>
<li>透過 pattern matching 取得 Node 裡面 Box 的所有權。</li>
<li>取得下一個 Node 的所有權，並將它指向共用的變數 <code>link</code>。</li>
<li>離開了 <code>node</code> 的 scope，<code>node</code> 呼叫 <code>drop</code> 釋放自身資源。</li>
</ol>
<blockquote>
<p>詳細思路過程可查看 Learning Rust With Entirely Too Many Linked Lists 的 <a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/first-drop.html">Drop</a> 章節，該章完整闡述為什麼不能用 tail recursive 來實作，但最大的原因是 Rust core team 暫時延緩實踐 <a href="https://github.com/rust-lang/rfcs/pull/1888">tail call optimization</a>。</p>
</blockquote>
<p>實際上，透過呼叫 <code>pop_front()</code>，不斷移除第一個節點，並使用 <code>is_some()</code> 檢查是否仍有節點，幾乎可以達到同樣的 drop 效果，而且更簡潔易懂。差別僅在於，相較於前個實作自己處理 call stack，這個實作每次移除元素都需要 <code>pop_front()</code> 與 <code>is_some()</code> 的 stack，多了些微小的開銷，雖然可透過 <a href="https://doc.rust-lang.org/1.49.0/reference/attributes/codegen.html#the-inline-attribute"><code>#[inline]</code></a> attribute 提示編譯器，但終究只是提示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Drop for SinglyLinkedList&lt;T&gt; {
    fn drop(&amp;mut self) {
        while self.pop_front().is_some() {}
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="iterator-and-intoiterator-traits"><a class="header" href="#iterator-and-intoiterator-traits">Iterator and IntoIterator traits</a></h3>
<p>既然鏈結串列是一種序列（sequence，有序的資料結構），少不了實作 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Iterator</a>、<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html">IntoIterator</a> 等 trait，使串列可以輕鬆使用 for-in loop 遍歷（traverse）。</p>
<p>首先，先定義幾個疊代器的 struct。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IntoIter&lt;T&gt;(SinglyLinkedList&lt;T&gt;);

pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;, // 1
}

pub struct IterMut&lt;'a, T&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>建立這三個 iterator struct 是常見的 Rust 設計模式。</p>
<ul>
<li><code>IntoIter</code>：產生 <code>T</code>，實作會吃掉元素所有權的 <code>IntoIterator</code> trait</li>
<li><code>Iter</code>：產生 <code>&amp;T</code>，實作提供 immutable borrow 的 <code>Iterator</code> trait。</li>
<li><code>IterMut</code>：產生 <code>&amp;mut T</code>，實作提供 mutable borrow 的 <code>Iterator</code> trait。</li>
</ul>
<p>相對應的，<code>SinglyLinkedList</code> 則新增三個成員函式：</p>
<ul>
<li><code>fn into_iter(self) -&gt; IntoIter&lt;T&gt;</code>：轉移所有權的疊代器。<em>Into</em> 一詞慣例上指涉所有權移轉。</li>
<li><code>fn iter(&amp;self) -&gt; Iter&lt;T&gt;</code>：以 immutable reference 疊代串列。</li>
<li><code>fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt;</code>：以 mutable reference 疊代串列。</li>
</ul>
<p>先來看 <code>IntoIter</code> 實作。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1
pub struct IntoIter&lt;T&gt;(SinglyLinkedList&lt;T&gt;);

// 2
impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.pop_front()
    }
}

// 3
impl&lt;T&gt; IntoIterator for SinglyLinkedList&lt;T&gt; {
    type Item = T;
    type IntoIter = IntoIter&lt;T&gt;;

    /// Creates a consuming iterator, that is, one that moves each value out of
    /// the list (from start to end). The list cannot be used after calling this.
    fn into_iter(self) -&gt; Self::IntoIter {
        IntoIter(self)
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>宣告一個 tuple struct，唯一的成員是 <code>SinglyLinkedList</code>。</li>
<li>實作 <code>Iterator</code> trait 的 required method <code>next</code>，為了達成 <em>Into</em> 會消耗原始資料，轉換所有權的特性，我們利用 <code>pop_front()</code> 將節點的資料依序刪除（pop）。</li>
<li><code>IntoInterator</code> 的 required method 傳遞 <code>self</code> 進來，所以無論怎麼實作 <code>IntoIter</code> struct，呼叫 <code>into_iter()</code> 後，外部就無法再次存取此 <code>SinglyLinkedList</code> 實例，達到所有權轉移的目標。</li>
</ol>
<blockquote>
<p>可能有人會疑惑，<code>IntoIter</code> 並沒有內部狀態記錄欄位，疊代器如何依據狀態產生下一筆資料？受惠於 <code>IntoIterator</code> 傳遞所有權的特性，<code>IntoIter</code> 可直接改變原始串列的內部狀態，例如 <code>pop_front</code> 會移除原始串列的節點。因此，相較於 <code>Iter</code>、<code>IterMut</code> 額外記錄狀態，<code>IntoIter</code> 不需自行記錄疊代器的疊代狀態。</p>
</blockquote>
<p>再來看看 <code>Iter</code> 怎麼實踐。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;, // 1
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T; // 2

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let node = self.next?;
        self.next = node.next.as_deref(); // 3
        Some(&amp;node.elem)
    }
}

impl&lt;T&gt; SinglyLinkedList&lt;T&gt; {
    // ...

    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        // 4
        Iter {
            next: self.head.as_deref(), // 5
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>這個 struct 的 <code>next</code> 是為了儲存 <code>Node</code> 資訊，方便記錄疊代器當前的狀態。加上生命週期 <code>'a</code> 是因編譯器無法推敲 <code>Option&lt;&amp;Node&lt;T&gt;&gt;</code> 會活多久，需要顯著標明 <code>&amp;Node</code> 至少與該疊代器同生共死。</li>
<li>由於 <code>Iter</code> 是為了實作產生 <code>&amp;T</code> 的疊代器，associated type 設為  <code>&amp;'a T</code>。</li>
<li>將當前節點的後一個節點設為 <code>Iter</code> 疊代器的狀態。並回傳當前節點的資料。<br />
這邊用了 <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.as_deref"><code>Option::as_deref()</code></a>，可直接將 <code>Option&lt;T&gt;</code> 轉換成 <code>Option&lt;&amp;T&gt;</code>，若 <code>T</code> 有實作 <a href="http://doc.rust-lang.org/core/ops/trait.Deref.html"><code>Deref</code></a> 特徵，更可以將 <code>T</code> 轉為 <code>Deref::Target</code>，例如這裡就是藉由 <a href="http://doc.rust-lang.org/alloc/boxed/struct.Box.html#method.deref"><code>Box::deref()</code></a> 將 <code>Box&lt;Node&lt;T&gt;&gt;</code> 轉換為 <code>&amp;Node&lt;T&gt;</code>。</li>
<li>在 <code>SinglyLinkedList</code> 上加 <code>iter()</code> 成員函式回傳 <code>Iter</code> 疊代器。</li>
<li>產生疊代器初始化狀態，和第三步一模一樣。</li>
</ol>
<p>最後，<code>IterMut</code> 與 <code>Iter</code> 疊代器實作上大同小異。把 <code>Iter</code> 用到 <code>Option::as_deref()</code> 改為 <code>Option::as_deref_mut()</code>，其他 <code>&amp;</code> 改成 <code>&amp;mut</code> 即可。</p>
<h3 id="partialeq-trait"><a class="header" href="#partialeq-trait">PartialEq trait</a></h3>
<p><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">PartialEq trait</a> 是用來實現兩個串列是否能夠比較，而我們在此定義如下：</p>
<p>有兩個 <code>SinglyLinkedList</code> Sa、Sb，Sa、Sb 的元素皆符合 <code>PartialEq</code> trait。當</p>
<ul>
<li>Sa 的總節點數 等於 Sb 的總節點數，</li>
<li>Sa 所有元素依序等於 Sb 所有元素，</li>
</ul>
<p>則稱 Sa 與 Sb 有 partial equiavalence（<code>Sa == Sb</code>）。</p>
<p>實作上我們用了 <code>iter</code> 成員函式把兩個串列 <code>zip</code> 在一起，在用 <code>all</code> 確認元素兩兩相等，十分 Rust 風格的作法。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: PartialEq&gt; PartialEq for SinglyLinkedList&lt;T&gt; {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        if self.len() != other.len() {
            return false;
        }
        self.iter().zip(other.iter()).all(|pair| pair.0 == pair.1)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="debug-trait"><a class="header" href="#debug-trait">Debug trait</a></h3>
<p>為了方便修復臭蟲，通常會實作 <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug trait</a> 印出有助於解決問題的資料。歸功於 <code>Iterator</code> 的實踐，我們可以快速用 <code>self.iter()</code> 印出所有節點內的元素，客製化 <code>Debug</code> 的顯示方式。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: std::fmt::Debug&gt; std::fmt::Debug for SinglyLinkedList&lt;T&gt; {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
        for node in self.iter() {
            write!(f, "{:?} -&gt; ", node)?
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="效能"><a class="header" href="#效能">效能</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Complexity</th></tr></thead><tbody>
<tr><td>get</td><td>$O(n)$</td></tr>
<tr><td>insert</td><td>節點已知：$O(1)$ ；節點未知：$O(n - i)$</td></tr>
<tr><td>remove</td><td>節點已知：$O(1)$ ；節點未知：$O(n - i)$</td></tr>
<tr><td>append</td><td>$O(n)$</td></tr>
<tr><td>prepend</td><td>$O(1)$</td></tr>
<tr><td>pop first</td><td>$O(1)$</td></tr>
<tr><td>pop last</td><td>$O(n)$</td></tr>
<tr><td>space</td><td>$O(n)$ + 各節點額外一個指標 $n$ 個</td></tr>
</tbody></table>
</div>
<blockquote>
<p>$n$：資料筆數。<br />
$i$：相對於整個容器的索引位置。</p>
</blockquote>
<p>值得觀察的是，許多操作因為單向鏈結串列只能從 head 開始搜索的緣故，執行時間都呈線性，使用上要特別注意。</p>
<h2 id="參考資料"><a class="header" href="#參考資料">參考資料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/src/alloc/linked_list.rs.html">Rust Documentation: LinkedList</a></li>
<li><a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/README.html">Learning Rust With Entirely Too Many Linked Lists</a></li>
<li><a href="https://stackoverflow.com/questions/51134192/">Duscussions at Stackoverflow</a></li>
<li><a href="https://codereview.stackexchange.com/questions/150906">StackExchange: Reversal of a singly-linked list in Rust</a></li>
<li>SVG of node memory representation modified from <a href="https://doc.rust-lang.org/book">The Rust Programming Language</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../collections/linked_list/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../collections/associative-container/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../collections/linked_list/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../collections/associative-container/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/custom.js"></script>


    </div>
    </body>
</html>
